"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vis.gl";
exports.ids = ["vendor-chunks/@vis.gl"];
exports.modules = {

/***/ "(ssr)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APILoadingStatus: () => (/* binding */ APILoadingStatus),\n/* harmony export */   APIProvider: () => (/* binding */ APIProvider),\n/* harmony export */   APIProviderContext: () => (/* binding */ APIProviderContext),\n/* harmony export */   AdvancedMarker: () => (/* binding */ AdvancedMarker),\n/* harmony export */   AdvancedMarkerAnchorPoint: () => (/* binding */ AdvancedMarkerAnchorPoint),\n/* harmony export */   AdvancedMarkerContext: () => (/* binding */ AdvancedMarkerContext),\n/* harmony export */   CollisionBehavior: () => (/* binding */ CollisionBehavior),\n/* harmony export */   ColorScheme: () => (/* binding */ ColorScheme),\n/* harmony export */   ControlPosition: () => (/* binding */ ControlPosition),\n/* harmony export */   GoogleMapsContext: () => (/* binding */ GoogleMapsContext),\n/* harmony export */   InfoWindow: () => (/* binding */ InfoWindow),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   MapControl: () => (/* binding */ MapControl),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   Pin: () => (/* binding */ Pin),\n/* harmony export */   RenderingType: () => (/* binding */ RenderingType),\n/* harmony export */   StaticMap: () => (/* binding */ StaticMap),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   createStaticMapsUrl: () => (/* binding */ createStaticMapsUrl),\n/* harmony export */   isAdvancedMarker: () => (/* binding */ isAdvancedMarker),\n/* harmony export */   isLatLngLiteral: () => (/* binding */ isLatLngLiteral),\n/* harmony export */   latLngEquals: () => (/* binding */ latLngEquals),\n/* harmony export */   limitTiltRange: () => (/* binding */ limitTiltRange),\n/* harmony export */   toLatLngLiteral: () => (/* binding */ toLatLngLiteral),\n/* harmony export */   useAdvancedMarkerRef: () => (/* binding */ useAdvancedMarkerRef),\n/* harmony export */   useApiIsLoaded: () => (/* binding */ useApiIsLoaded),\n/* harmony export */   useApiLoadingStatus: () => (/* binding */ useApiLoadingStatus),\n/* harmony export */   useMap: () => (/* binding */ useMap),\n/* harmony export */   useMapsLibrary: () => (/* binding */ useMapsLibrary),\n/* harmony export */   useMarkerRef: () => (/* binding */ useMarkerRef)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/./node_modules/fast-deep-equal/index.js\");\n\n\n\n// This file is automatically updated by the build process.\nconst VERSION = \"1.7.1\";\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst APILoadingStatus = {\n    NOT_LOADED: \"NOT_LOADED\",\n    LOADING: \"LOADING\",\n    LOADED: \"LOADED\",\n    FAILED: \"FAILED\",\n    AUTH_FAILURE: \"AUTH_FAILURE\"\n};\nconst MAPS_API_BASE_URL = \"https://maps.googleapis.com/maps/api/js\";\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */ class GoogleMapsApiLoader {\n    /**\n     * Loads the Maps JavaScript API with the specified parameters.\n     * Since the Maps library can only be loaded once per page, this will\n     * produce a warning when called multiple times with different\n     * parameters.\n     *\n     * The returned promise resolves when loading completes\n     * and rejects in case of an error or when the loading was aborted.\n     */ static load(params, onLoadingStatusChange) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const libraries = params.libraries ? params.libraries.split(\",\") : [];\n            const serializedParams = this.serializeParams(params);\n            this.listeners.push(onLoadingStatusChange);\n            // Note: if `google.maps.importLibrary` has been defined externally, we\n            //   assume that loading is complete and successful.\n            //   If it was defined by a previous call to this method, a warning\n            //   message is logged if there are differences in api-parameters used\n            //   for both calls.\n            if ((_b = (_a = window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary) {\n                // no serialized parameters means it was loaded externally\n                if (!this.serializedApiParams) {\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                }\n                this.notifyLoadingStatusListeners();\n            } else {\n                this.serializedApiParams = serializedParams;\n                this.initImportLibrary(params);\n            }\n            if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n                console.warn(`[google-maps-api-loader] The maps API has already been loaded ` + `with different parameters and will not be loaded again. Refresh the ` + `page for new values to have effect.`);\n            }\n            const librariesToLoad = [\n                \"maps\",\n                ...libraries\n            ];\n            yield Promise.all(librariesToLoad.map((name)=>google.maps.importLibrary(name)));\n        });\n    }\n    /**\n     * Serialize the parameters used to load the library for easier comparison.\n     */ static serializeParams(params) {\n        return [\n            params.v,\n            params.key,\n            params.language,\n            params.region,\n            params.authReferrerPolicy,\n            params.solutionChannel\n        ].join(\"/\");\n    }\n    /**\n     * Creates the global `google.maps.importLibrary` function for bootstrapping.\n     * This is essentially a formatted version of the dynamic loading script\n     * from the official documentation with some minor adjustments.\n     *\n     * The created importLibrary function will load the Google Maps JavaScript API,\n     * which will then replace the `google.maps.importLibrary` function with the full\n     * implementation.\n     *\n     * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n     */ static initImportLibrary(params) {\n        if (!window.google) window.google = {};\n        if (!window.google.maps) window.google.maps = {};\n        if (window.google.maps[\"importLibrary\"]) {\n            console.error(\"[google-maps-api-loader-internal]: initImportLibrary must only be called once\");\n            return;\n        }\n        let apiPromise = null;\n        const loadApi = ()=>{\n            if (apiPromise) return apiPromise;\n            apiPromise = new Promise((resolve, reject)=>{\n                var _a;\n                const scriptElement = document.createElement(\"script\");\n                const urlParams = new URLSearchParams();\n                for (const [key, value] of Object.entries(params)){\n                    const urlParamName = key.replace(/[A-Z]/g, (t)=>\"_\" + t[0].toLowerCase());\n                    urlParams.set(urlParamName, String(value));\n                }\n                urlParams.set(\"loading\", \"async\");\n                urlParams.set(\"callback\", \"__googleMapsCallback__\");\n                scriptElement.async = true;\n                scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n                scriptElement.nonce = ((_a = document.querySelector(\"script[nonce]\")) === null || _a === void 0 ? void 0 : _a.nonce) || \"\";\n                scriptElement.onerror = ()=>{\n                    this.loadingStatus = APILoadingStatus.FAILED;\n                    this.notifyLoadingStatusListeners();\n                    reject(new Error(\"The Google Maps JavaScript API could not load.\"));\n                };\n                window.__googleMapsCallback__ = ()=>{\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                    this.notifyLoadingStatusListeners();\n                    resolve();\n                };\n                window.gm_authFailure = ()=>{\n                    this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n                    this.notifyLoadingStatusListeners();\n                };\n                this.loadingStatus = APILoadingStatus.LOADING;\n                this.notifyLoadingStatusListeners();\n                document.head.append(scriptElement);\n            });\n            return apiPromise;\n        };\n        // for the first load, we declare an importLibrary function that will\n        // be overwritten once the api is loaded.\n        google.maps.importLibrary = (libraryName)=>loadApi().then(()=>google.maps.importLibrary(libraryName));\n    }\n    /**\n     * Calls all registered loadingStatusListeners after a status update.\n     */ static notifyLoadingStatusListeners() {\n        for (const fn of this.listeners){\n            fn(this.loadingStatus);\n        }\n    }\n}\n/**\n * The current loadingStatus of the API.\n */ GoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\n/**\n * A list of functions to be notified when the loading status changes.\n */ GoogleMapsApiLoader.listeners = [];\nconst DEFAULT_SOLUTION_CHANNEL = \"GMP_visgl_rgmlibrary_v1_default\";\nconst DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS = [\n    `gmp_visgl_reactgooglemaps_v${VERSION}`\n];\nconst APIProviderContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */ function useMapInstances() {\n    const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const addMapInstance = (mapInstance, id = \"default\")=>{\n        setMapInstances((instances)=>Object.assign(Object.assign({}, instances), {\n                [id]: mapInstance\n            }));\n    };\n    const removeMapInstance = (id = \"default\")=>{\n        setMapInstances((_a)=>{\n            var _b = id;\n            _a[_b];\n            var remaining = __rest(_a, [\n                typeof _b === \"symbol\" ? _b : _b + \"\"\n            ]);\n            return remaining;\n        });\n    };\n    const clearMapInstances = ()=>{\n        setMapInstances({});\n    };\n    return {\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances\n    };\n}\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */ function useGoogleMapsApiLoader(props) {\n    const { onLoad, onError, apiKey, version, libraries = [] } = props, otherApiParams = __rest(props, [\n        \"onLoad\",\n        \"onError\",\n        \"apiKey\",\n        \"version\",\n        \"libraries\"\n    ]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n    const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action)=>{\n        return loadedLibraries[action.name] ? loadedLibraries : Object.assign(Object.assign({}, loadedLibraries), {\n            [action.name]: action.value\n        });\n    }, {});\n    const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>libraries === null || libraries === void 0 ? void 0 : libraries.join(\",\"), [\n        libraries\n    ]);\n    const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>JSON.stringify(Object.assign({\n            apiKey,\n            version\n        }, otherApiParams)), [\n        apiKey,\n        version,\n        otherApiParams\n    ]);\n    const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name)=>__awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (loadedLibraries[name]) {\n                return loadedLibraries[name];\n            }\n            if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.importLibrary)) {\n                throw new Error(\"[api-provider-internal] importLibrary was called before \" + \"google.maps.importLibrary was defined.\");\n            }\n            const res = yield window.google.maps.importLibrary(name);\n            addLoadedLibrary({\n                name,\n                value: res\n            });\n            return res;\n        }), [\n        loadedLibraries\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        (()=>__awaiter(this, void 0, void 0, function*() {\n                try {\n                    const params = Object.assign({\n                        key: apiKey\n                    }, otherApiParams);\n                    if (version) params.v = version;\n                    if ((librariesString === null || librariesString === void 0 ? void 0 : librariesString.length) > 0) params.libraries = librariesString;\n                    if (params.channel === undefined || params.channel < 0 || params.channel > 999) delete params.channel;\n                    if (params.solutionChannel === undefined) params.solutionChannel = DEFAULT_SOLUTION_CHANNEL;\n                    else if (params.solutionChannel === \"\") delete params.solutionChannel;\n                    yield GoogleMapsApiLoader.load(params, (status)=>setStatus(status));\n                    for (const name of [\n                        \"core\",\n                        \"maps\",\n                        ...libraries\n                    ]){\n                        yield importLibrary(name);\n                    }\n                    if (onLoad) {\n                        onLoad();\n                    }\n                } catch (error) {\n                    if (onError) {\n                        onError(error);\n                    } else {\n                        console.error(\"<ApiProvider> failed to load the Google Maps JavaScript API\", error);\n                    }\n                }\n            }))();\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        apiKey,\n        librariesString,\n        serializedParams\n    ]);\n    return {\n        status,\n        loadedLibraries,\n        importLibrary\n    };\n}\nfunction useInternalUsageAttributionIds(props) {\n    const internalUsageAttributionIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disableUsageAttribution ? null : DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS, [\n        props.disableUsageAttribution\n    ]);\n    return internalUsageAttributionIds;\n}\n/**\n * Component to wrap the components from this library and load the Google Maps JavaScript API\n */ const APIProvider = (props)=>{\n    const { children } = props, loaderProps = __rest(props, [\n        \"children\"\n    ]);\n    const { mapInstances, addMapInstance, removeMapInstance, clearMapInstances } = useMapInstances();\n    const { status, loadedLibraries, importLibrary } = useGoogleMapsApiLoader(loaderProps);\n    const internalUsageAttributionIds = useInternalUsageAttributionIds(loaderProps);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            mapInstances,\n            addMapInstance,\n            removeMapInstance,\n            clearMapInstances,\n            status,\n            loadedLibraries,\n            importLibrary,\n            internalUsageAttributionIds\n        }), [\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary,\n        internalUsageAttributionIds\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, {\n        value: contextValue\n    }, children);\n};\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */ function useMapEvents(map, props) {\n    // note: calling a useEffect hook from within a loop is prohibited by the\n    // rules of hooks, but it's ok here since it's unconditional and the number\n    // and order of iterations is always strictly the same.\n    // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n    for (const propName of eventPropNames){\n        // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n        //   a proper solution seems way too complicated right now\n        const handler = props[propName];\n        const eventType = propNameToEventType[propName];\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            if (!map) return;\n            if (!handler) return;\n            const listener = google.maps.event.addListener(map, eventType, (ev)=>{\n                handler(createMapEvent(eventType, map, ev));\n            });\n            return ()=>listener.remove();\n        }, [\n            map,\n            eventType,\n            handler\n        ]);\n    }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */ function createMapEvent(type, map, srcEvent) {\n    var _a;\n    const ev = {\n        type,\n        map,\n        detail: {},\n        stoppable: false,\n        stop: ()=>{}\n    };\n    if (cameraEventTypes.includes(type)) {\n        const camEvent = ev;\n        const center = map.getCenter();\n        const zoom = map.getZoom();\n        const heading = map.getHeading() || 0;\n        const tilt = map.getTilt() || 0;\n        const bounds = map.getBounds();\n        if (!center || !bounds || !Number.isFinite(zoom)) {\n            console.warn(\"[createEvent] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n        }\n        camEvent.detail = {\n            center: (center === null || center === void 0 ? void 0 : center.toJSON()) || {\n                lat: 0,\n                lng: 0\n            },\n            zoom: zoom || 0,\n            heading: heading,\n            tilt: tilt,\n            bounds: (bounds === null || bounds === void 0 ? void 0 : bounds.toJSON()) || {\n                north: 90,\n                east: 180,\n                south: -90,\n                west: -180\n            }\n        };\n        return camEvent;\n    } else if (mouseEventTypes.includes(type)) {\n        if (!srcEvent) throw new Error(\"[createEvent] mouse events must provide a srcEvent\");\n        const mouseEvent = ev;\n        mouseEvent.domEvent = srcEvent.domEvent;\n        mouseEvent.stoppable = true;\n        mouseEvent.stop = ()=>srcEvent.stop();\n        mouseEvent.detail = {\n            latLng: ((_a = srcEvent.latLng) === null || _a === void 0 ? void 0 : _a.toJSON()) || null,\n            placeId: srcEvent.placeId\n        };\n        return mouseEvent;\n    }\n    return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */ const propNameToEventType = {\n    onBoundsChanged: \"bounds_changed\",\n    onCenterChanged: \"center_changed\",\n    onClick: \"click\",\n    onContextmenu: \"contextmenu\",\n    onDblclick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragend: \"dragend\",\n    onDragstart: \"dragstart\",\n    onHeadingChanged: \"heading_changed\",\n    onIdle: \"idle\",\n    onIsFractionalZoomEnabledChanged: \"isfractionalzoomenabled_changed\",\n    onMapCapabilitiesChanged: \"mapcapabilities_changed\",\n    onMapTypeIdChanged: \"maptypeid_changed\",\n    onMousemove: \"mousemove\",\n    onMouseout: \"mouseout\",\n    onMouseover: \"mouseover\",\n    onProjectionChanged: \"projection_changed\",\n    onRenderingTypeChanged: \"renderingtype_changed\",\n    onTilesLoaded: \"tilesloaded\",\n    onTiltChanged: \"tilt_changed\",\n    onZoomChanged: \"zoom_changed\",\n    // note: onCameraChanged is an alias for the bounds_changed event,\n    // since that is going to be fired in every situation where the camera is\n    // updated.\n    onCameraChanged: \"bounds_changed\"\n};\nconst cameraEventTypes = [\n    \"bounds_changed\",\n    \"center_changed\",\n    \"heading_changed\",\n    \"tilt_changed\",\n    \"zoom_changed\"\n];\nconst mouseEventTypes = [\n    \"click\",\n    \"contextmenu\",\n    \"dblclick\",\n    \"mousemove\",\n    \"mouseout\",\n    \"mouseover\"\n];\nconst eventPropNames = Object.keys(propNameToEventType);\n/**\n * A hook to store the previous value of a variable.\n * @param value The value to store\n * @returns The previous value\n */ function usePrevious(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    });\n    // eslint-disable-next-line react-hooks/refs\n    return ref.current;\n}\nfunction useMemoized(value, isEqual) {\n    const previous = usePrevious(value);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (previous && isEqual(previous, value)) {\n            return previous;\n        }\n        return value;\n    }, [\n        value,\n        previous,\n        isEqual\n    ]);\n}\nfunction useCustomCompareEffect(effect, dependencies, isEqual) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, [\n        useMemoized(dependencies, isEqual)\n    ]);\n}\nfunction useDeepCompareEffect(effect, dependencies) {\n    useCustomCompareEffect(effect, dependencies, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n}\nconst mapOptionKeys = new Set([\n    \"backgroundColor\",\n    \"clickableIcons\",\n    \"controlSize\",\n    \"disableDefaultUI\",\n    \"disableDoubleClickZoom\",\n    \"draggable\",\n    \"draggableCursor\",\n    \"draggingCursor\",\n    \"fullscreenControl\",\n    \"fullscreenControlOptions\",\n    \"gestureHandling\",\n    \"headingInteractionEnabled\",\n    \"isFractionalZoomEnabled\",\n    \"keyboardShortcuts\",\n    \"mapTypeControl\",\n    \"mapTypeControlOptions\",\n    \"mapTypeId\",\n    \"maxZoom\",\n    \"minZoom\",\n    \"noClear\",\n    \"panControl\",\n    \"panControlOptions\",\n    \"restriction\",\n    \"rotateControl\",\n    \"rotateControlOptions\",\n    \"scaleControl\",\n    \"scaleControlOptions\",\n    \"scrollwheel\",\n    \"streetView\",\n    \"streetViewControl\",\n    \"streetViewControlOptions\",\n    \"styles\",\n    \"tiltInteractionEnabled\",\n    \"zoomControl\",\n    \"zoomControlOptions\"\n]);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */ function useMapOptions(map, mapProps) {\n    /* eslint-disable react-hooks/exhaustive-deps --\n     *\n     * The following effects aren't triggered when the map is changed.\n     * In that case, the values will be or have been passed to the map\n     * constructor via mapOptions.\n     */ const mapOptions = {};\n    const keys = Object.keys(mapProps);\n    for (const key of keys){\n        if (!mapOptionKeys.has(key)) continue;\n        mapOptions[key] = mapProps[key];\n    }\n    // update the map options when mapOptions is changed\n    // Note: due to the destructuring above, mapOptions will be seen as changed\n    //   with every re-render, so we're assuming the maps-api will properly\n    //   deal with unchanged option-values passed into setOptions.\n    useDeepCompareEffect(()=>{\n        if (!map) return;\n        map.setOptions(mapOptions);\n    }, [\n        mapOptions\n    ]);\n/* eslint-enable react-hooks/exhaustive-deps */ }\nfunction useApiLoadingStatus() {\n    var _a;\n    return ((_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) === null || _a === void 0 ? void 0 : _a.status) || APILoadingStatus.NOT_LOADED;\n}\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */ function useDeckGLCameraUpdate(map, props) {\n    const { viewport, viewState } = props;\n    const isDeckGlControlled = !!viewport;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !viewState) return;\n        const { latitude, longitude, bearing: heading, pitch: tilt, zoom } = viewState;\n        map.moveCamera({\n            center: {\n                lat: latitude,\n                lng: longitude\n            },\n            heading,\n            tilt,\n            zoom: zoom + 1\n        });\n    }, [\n        map,\n        viewState\n    ]);\n    return isDeckGlControlled;\n}\nfunction isLatLngLiteral(obj) {\n    if (!obj || typeof obj !== \"object\") return false;\n    if (!(\"lat\" in obj && \"lng\" in obj)) return false;\n    return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n    if (!a || !b) return false;\n    const A = toLatLngLiteral(a);\n    const B = toLatLngLiteral(b);\n    if (A.lat !== B.lat || A.lng !== B.lng) return false;\n    return true;\n}\nfunction toLatLngLiteral(obj) {\n    if (isLatLngLiteral(obj)) return obj;\n    return obj.toJSON();\n}\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n    const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const zoom = Number.isFinite(mapProps.zoom) ? mapProps.zoom : null;\n    const heading = Number.isFinite(mapProps.heading) ? mapProps.heading : null;\n    const tilt = Number.isFinite(mapProps.tilt) ? mapProps.tilt : null;\n    // the following effect runs for every render of the map component and checks\n    // if there are differences between the known state of the map instance\n    // (cameraStateRef, which is updated by all bounds_changed events) and the\n    // desired state in the props.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map) return;\n        const nextCamera = {};\n        let needsUpdate = false;\n        if (lat !== null && lng !== null && (cameraStateRef.current.center.lat !== lat || cameraStateRef.current.center.lng !== lng)) {\n            nextCamera.center = {\n                lat,\n                lng\n            };\n            needsUpdate = true;\n        }\n        if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n            nextCamera.zoom = zoom;\n            needsUpdate = true;\n        }\n        if (heading !== null && cameraStateRef.current.heading !== heading) {\n            nextCamera.heading = heading;\n            needsUpdate = true;\n        }\n        if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n            nextCamera.tilt = tilt;\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            map.moveCamera(nextCamera);\n        }\n    });\n}\nconst AuthFailureMessage = ()=>{\n    const style = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        zIndex: 999,\n        display: \"flex\",\n        flexFlow: \"column nowrap\",\n        textAlign: \"center\",\n        justifyContent: \"center\",\n        fontSize: \".8rem\",\n        color: \"rgba(0,0,0,0.6)\",\n        background: \"#dddddd\",\n        padding: \"1rem 1.5rem\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: style\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\nfunction useCallbackRef() {\n    const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>setEl(value), [\n        setEl\n    ]);\n    return [\n        el,\n        ref\n    ];\n}\n/**\n * Hook to check if the Maps JavaScript API is loaded\n */ function useApiIsLoaded() {\n    const status = useApiLoadingStatus();\n    return status === APILoadingStatus.LOADED;\n}\nfunction useForceUpdate() {\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((x)=>x + 1, 0);\n    return forceUpdate;\n}\nfunction handleBoundsChange(map, ref) {\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n        console.warn(\"[useTrackedCameraState] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n    }\n    // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n    Object.assign(ref.current, {\n        center: (center === null || center === void 0 ? void 0 : center.toJSON()) || {\n            lat: 0,\n            lng: 0\n        },\n        zoom: zoom || 0,\n        heading: heading,\n        tilt: tilt\n    });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */ function useTrackedCameraStateRef(map) {\n    const forceUpdate = useForceUpdate();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        center: {\n            lat: 0,\n            lng: 0\n        },\n        heading: 0,\n        tilt: 0,\n        zoom: 0\n    });\n    // Record camera state with every bounds_changed event dispatched by the map.\n    // This data is used to prevent feeding these values back to the\n    // map-instance when a typical \"controlled component\" setup (state variable is\n    // fed into and updated by the map).\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const listener = google.maps.event.addListener(map, \"bounds_changed\", ()=>{\n            handleBoundsChange(map, ref);\n            // When an event is occured, we have to update during the next cycle.\n            // The application could decide to ignore the event and not update any\n            // camera props of the map, meaning that in that case we will have to\n            // 'undo' the change to the camera.\n            forceUpdate();\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        forceUpdate\n    ]);\n    return ref;\n}\n/**\n * Stores a stack of map-instances for each mapId. Whenever an\n * instance is used, it is removed from the stack while in use,\n * and returned to the stack when the component unmounts.\n * This allows us to correctly implement caching for multiple\n * maps om the same page, while reusing as much as possible.\n *\n * FIXME: while it should in theory be possible to reuse maps solely\n *   based on the mapId (as all other parameters can be changed at\n *   runtime), we don't yet have good enough tracking of options to\n *   reliably unset all the options that have been set.\n */ class CachedMapStack {\n    static has(key) {\n        return this.entries[key] && this.entries[key].length > 0;\n    }\n    static pop(key) {\n        if (!this.entries[key]) return null;\n        return this.entries[key].pop() || null;\n    }\n    static push(key, value) {\n        if (!this.entries[key]) this.entries[key] = [];\n        this.entries[key].push(value);\n    }\n}\nCachedMapStack.entries = {};\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */ function useMapInstance(props, context) {\n    const apiIsLoaded = useApiIsLoaded();\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [container, containerRef] = useCallbackRef();\n    const cameraStateRef = useTrackedCameraStateRef(map);\n    const { id, defaultBounds, defaultCenter, defaultZoom, defaultHeading, defaultTilt, reuseMaps, renderingType, colorScheme } = props, mapOptions = __rest(props, [\n        \"id\",\n        \"defaultBounds\",\n        \"defaultCenter\",\n        \"defaultZoom\",\n        \"defaultHeading\",\n        \"defaultTilt\",\n        \"reuseMaps\",\n        \"renderingType\",\n        \"colorScheme\"\n    ]);\n    const hasZoom = props.zoom !== undefined || props.defaultZoom !== undefined;\n    const hasCenter = props.center !== undefined || props.defaultCenter !== undefined;\n    if (!defaultBounds && (!hasZoom || !hasCenter)) {\n        console.warn(\"<Map> component is missing configuration. \" + \"You have to provide zoom and center (via the `zoom`/`defaultZoom` and \" + \"`center`/`defaultCenter` props) or specify the region to show using \" + \"`defaultBounds`. See \" + \"https://visgl.github.io/react-google-maps/docs/api-reference/components/map#required\");\n    }\n    // apply default camera props if available and not overwritten by controlled props\n    if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n    if (!mapOptions.zoom && Number.isFinite(defaultZoom)) mapOptions.zoom = defaultZoom;\n    if (!mapOptions.heading && Number.isFinite(defaultHeading)) mapOptions.heading = defaultHeading;\n    if (!mapOptions.tilt && Number.isFinite(defaultTilt)) mapOptions.tilt = defaultTilt;\n    // Handle internalUsageAttributionIds\n    const customIds = mapOptions.internalUsageAttributionIds;\n    if (customIds == null) {\n        // Not specified - use context default (which may be null if disabled)\n        mapOptions.internalUsageAttributionIds = context.internalUsageAttributionIds;\n    } else {\n        // Merge context defaults with custom IDs\n        mapOptions.internalUsageAttributionIds = [\n            ...context.internalUsageAttributionIds || [],\n            ...customIds\n        ];\n    }\n    for (const key of Object.keys(mapOptions))if (mapOptions[key] === undefined) delete mapOptions[key];\n    const savedMapStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    // create the map instance and register it in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!container || !apiIsLoaded) return;\n        const { addMapInstance, removeMapInstance } = context;\n        // note: colorScheme (upcoming feature) isn't yet in the typings, remove once that is fixed:\n        const { mapId } = props;\n        const cacheKey = `${mapId || \"default\"}:${renderingType || \"default\"}:${colorScheme || \"LIGHT\"}`;\n        let mapDiv;\n        let map;\n        if (reuseMaps && CachedMapStack.has(cacheKey)) {\n            map = CachedMapStack.pop(cacheKey);\n            mapDiv = map.getDiv();\n            container.appendChild(mapDiv);\n            map.setOptions(mapOptions);\n            // detaching the element from the DOM lets the map fall back to its default\n            // size, setting the center will trigger reloading the map.\n            setTimeout(()=>map.setCenter(map.getCenter()), 0);\n        } else {\n            mapDiv = document.createElement(\"div\");\n            mapDiv.style.height = \"100%\";\n            container.appendChild(mapDiv);\n            map = new google.maps.Map(mapDiv, Object.assign(Object.assign(Object.assign({}, mapOptions), renderingType ? {\n                renderingType: renderingType\n            } : {}), colorScheme ? {\n                colorScheme: colorScheme\n            } : {}));\n        }\n        setMap(map);\n        addMapInstance(map, id);\n        if (defaultBounds) {\n            const { padding } = defaultBounds, defBounds = __rest(defaultBounds, [\n                \"padding\"\n            ]);\n            map.fitBounds(defBounds, padding);\n        } else if (!hasZoom || !hasCenter) {\n            map.fitBounds({\n                east: 180,\n                west: -180,\n                south: -90,\n                north: 90\n            });\n        }\n        // the savedMapState is used to restore the camera parameters when the mapId is changed\n        if (savedMapStateRef.current) {\n            const { mapId: savedMapId, cameraState: savedCameraState } = savedMapStateRef.current;\n            if (savedMapId !== mapId) {\n                map.setOptions(savedCameraState);\n            }\n        }\n        return ()=>{\n            savedMapStateRef.current = {\n                mapId,\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                cameraState: cameraStateRef.current\n            };\n            // detach the map-div from the dom\n            mapDiv.remove();\n            if (reuseMaps) {\n                // push back on the stack\n                CachedMapStack.push(cacheKey, map);\n            } else {\n                // remove all event-listeners to minimize the possibility of memory-leaks\n                google.maps.event.clearInstanceListeners(map);\n            }\n            setMap(null);\n            removeMapInstance(id);\n        };\n    }, // some dependencies are ignored in the list below:\n    //  - defaultBounds and the default* camera props will only be used once, and\n    //    changes should be ignored\n    //  - mapOptions has special hooks that take care of updating the options\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        container,\n        apiIsLoaded,\n        id,\n        // these props can't be changed after initialization and require a new\n        // instance to be created\n        props.mapId,\n        props.renderingType,\n        props.colorScheme\n    ]);\n    return [\n        map,\n        containerRef,\n        cameraStateRef\n    ];\n}\nconst GoogleMapsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// ColorScheme and RenderingType are redefined here to make them usable before the\n// maps API has been fully loaded.\nconst ColorScheme = {\n    DARK: \"DARK\",\n    LIGHT: \"LIGHT\",\n    FOLLOW_SYSTEM: \"FOLLOW_SYSTEM\"\n};\nconst RenderingType = {\n    VECTOR: \"VECTOR\",\n    RASTER: \"RASTER\",\n    UNINITIALIZED: \"UNINITIALIZED\"\n};\nconst Map = (props)=>{\n    const { children, id, className, style } = props;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const loadingStatus = useApiLoadingStatus();\n    if (!context) {\n        throw new Error(\"<Map> can only be used inside an <ApiProvider> component.\");\n    }\n    const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n    useMapCameraParams(map, cameraStateRef, props);\n    useMapEvents(map, props);\n    useMapOptions(map, props);\n    const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n    const isControlledExternally = !!props.controlled;\n    // disable interactions with the map for externally controlled maps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n        //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n        //   any default map controls pretty much useless\n        if (isDeckGlControlled) {\n            map.setOptions({\n                disableDefaultUI: true\n            });\n        }\n        // disable all control-inputs when the map is controlled externally\n        if (isDeckGlControlled || isControlledExternally) {\n            map.setOptions({\n                gestureHandling: \"none\",\n                keyboardShortcuts: false\n            });\n        }\n        return ()=>{\n            map.setOptions({\n                gestureHandling: props.gestureHandling,\n                keyboardShortcuts: props.keyboardShortcuts\n            });\n        };\n    }, [\n        map,\n        isDeckGlControlled,\n        isControlledExternally,\n        props.gestureHandling,\n        props.keyboardShortcuts\n    ]);\n    // setup a stable cameraOptions object that can be used as dependency\n    const center = props.center ? toLatLngLiteral(props.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _a, _b, _c;\n        return {\n            center: {\n                lat: lat !== null && lat !== void 0 ? lat : 0,\n                lng: lng !== null && lng !== void 0 ? lng : 0\n            },\n            zoom: (_a = props.zoom) !== null && _a !== void 0 ? _a : 0,\n            heading: (_b = props.heading) !== null && _b !== void 0 ? _b : 0,\n            tilt: (_c = props.tilt) !== null && _c !== void 0 ? _c : 0\n        };\n    }, [\n        lat,\n        lng,\n        props.zoom,\n        props.heading,\n        props.tilt\n    ]);\n    // externally controlled mode: reject all camera changes that don't correspond to changes in props\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !isControlledExternally) return;\n        map.moveCamera(cameraOptions);\n        const listener = map.addListener(\"bounds_changed\", ()=>{\n            map.moveCamera(cameraOptions);\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        isControlledExternally,\n        cameraOptions\n    ]);\n    const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>Object.assign({\n            width: \"100%\",\n            height: \"100%\",\n            position: \"relative\",\n            // when using deckgl, the map should be sent to the back\n            zIndex: isDeckGlControlled ? -1 : 0\n        }, style), [\n        style,\n        isDeckGlControlled\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            map\n        }), [\n        map\n    ]);\n    if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            style: Object.assign({\n                position: \"relative\"\n            }, className ? {} : combinedStyle),\n            className: className\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({\n        ref: mapRef,\n        \"data-testid\": \"map\",\n        style: className ? undefined : combinedStyle,\n        className: className\n    }, id ? {\n        id\n    } : {}), map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, {\n        value: contextValue\n    }, children) : null);\n};\n// The deckGLViewProps flag here indicates to deck.gl that the Map component is\n// able to handle viewProps from deck.gl when deck.gl is used to control the map.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nMap.deckGLViewProps = true;\nconst shownMessages = new Set();\nfunction logErrorOnce(...args) {\n    const key = JSON.stringify(args);\n    if (!shownMessages.has(key)) {\n        shownMessages.add(key);\n        console.error(...args);\n    }\n}\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */ const useMap = (id = null)=>{\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const { map } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n    if (ctx === null) {\n        logErrorOnce(\"useMap(): failed to retrieve APIProviderContext. \" + \"Make sure that the <APIProvider> component exists and that the \" + \"component you are calling `useMap()` from is a sibling of the \" + \"<APIProvider>.\");\n        return null;\n    }\n    const { mapInstances } = ctx;\n    // if an id is specified, the corresponding map or null is returned\n    if (id !== null) return mapInstances[id] || null;\n    // otherwise, return the closest ancestor\n    if (map) return map;\n    // finally, return the default map instance\n    return mapInstances[\"default\"] || null;\n};\nfunction useMapsLibrary(name) {\n    const apiIsLoaded = useApiIsLoaded();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!apiIsLoaded || !ctx) return;\n        // Trigger loading the libraries via our proxy-method.\n        // The returned promise is ignored, since importLibrary will update loadedLibraries\n        // list in the context, triggering a re-render.\n        void ctx.importLibrary(name);\n    }, [\n        apiIsLoaded,\n        ctx,\n        name\n    ]);\n    return (ctx === null || ctx === void 0 ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Internally used to bind events to Maps JavaScript API objects.\n * @internal\n */ function useMapsEventListener(target, name, callback) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!target || !name || !callback) return;\n        const listener = google.maps.event.addListener(target, name, callback);\n        return ()=>listener.remove();\n    }, [\n        target,\n        name,\n        callback\n    ]);\n}\n/**\n * Internally used to copy values from props into API-Objects\n * whenever they change.\n *\n * @example\n *   usePropBinding(marker, 'position', position);\n *\n * @internal\n */ function usePropBinding(object, prop, value) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!object) return;\n        // eslint-disable-next-line react-hooks/immutability\n        object[prop] = value;\n    }, [\n        object,\n        prop,\n        value\n    ]);\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Internally used to bind events to DOM nodes.\n * @internal\n */ function useDomEventListener(target, name, callback) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!target || !name || !callback) return;\n        target.addEventListener(name, callback);\n        return ()=>target.removeEventListener(name, callback);\n    }, [\n        target,\n        name,\n        callback\n    ]);\n}\n// Global style manager to track rendered styles and avoid duplicates\nclass GlobalStyleManager {\n    constructor(){\n        this.renderedStyles = new Set();\n        this.styleElement = null;\n    }\n    getStyleElement() {\n        if (!this.styleElement) {\n            this.styleElement = document.createElement(\"style\");\n            this.styleElement.setAttribute(\"data-rgm-anchor-styles\", \"\");\n            document.head.appendChild(this.styleElement);\n        }\n        return this.styleElement;\n    }\n    addAdvancedMarkerPointerEventsOverwrite() {\n        if (this.renderedStyles.has(\"marker-pointer-events\")) {\n            return;\n        }\n        const styleElement = this.getStyleElement();\n        styleElement.textContent += `\n      gmp-advanced-marker[data-origin='rgm'] {\n        pointer-events: none !important;\n      }\n    `;\n        this.renderedStyles.add(\"marker-pointer-events\");\n    }\n    cleanup() {\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n            this.renderedStyles.clear();\n        }\n    }\n}\nconst globalStyleManager = new GlobalStyleManager();\nfunction isVersionGreaterEqual(major, minor) {\n    var _a;\n    if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.version)) return undefined;\n    const version = google.maps.version.split(\".\");\n    const currentMajor = parseInt(version[0], 10);\n    const currentMinor = parseInt(version[1], 10);\n    return currentMajor > major || currentMajor === major && currentMinor >= minor;\n}\n/* eslint-disable react-hooks/immutability */ // The `react-hooks/immutability` rule is disabled in this file because the\n// google.maps.marker.AdvancedMarkerElement object is designed to be mutated\n// directly. This is a common pattern when working with imperative APIs like\n// the Google Maps JavaScript API. While this goes against the principles of\n// immutable state in React, it is a necessary evil to integrate with the\n// Google Maps API. The mutations are carefully managed within the `useEffect`\n// hooks to ensure that they only happen when the props change.\n/**\n * Copy of the `google.maps.CollisionBehavior` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */ const CollisionBehavior = {\n    REQUIRED: \"REQUIRED\",\n    REQUIRED_AND_HIDES_OPTIONAL: \"REQUIRED_AND_HIDES_OPTIONAL\",\n    OPTIONAL_AND_HIDES_LOWER_PRIORITY: \"OPTIONAL_AND_HIDES_LOWER_PRIORITY\"\n};\nconst AdvancedMarkerContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// [xPosition, yPosition] when the top left corner is [0, 0]\n/**\n * @deprecated Using `anchorPosition` is deprecated.\n *   Use `anchorLeft` and `anchorTop` instead.\n */ const AdvancedMarkerAnchorPoint = {\n    TOP_LEFT: [\n        \"0%\",\n        \"0%\"\n    ],\n    TOP_CENTER: [\n        \"50%\",\n        \"0%\"\n    ],\n    TOP: [\n        \"50%\",\n        \"0%\"\n    ],\n    TOP_RIGHT: [\n        \"100%\",\n        \"0%\"\n    ],\n    LEFT_CENTER: [\n        \"0%\",\n        \"50%\"\n    ],\n    LEFT_TOP: [\n        \"0%\",\n        \"0%\"\n    ],\n    LEFT: [\n        \"0%\",\n        \"50%\"\n    ],\n    LEFT_BOTTOM: [\n        \"0%\",\n        \"100%\"\n    ],\n    RIGHT_TOP: [\n        \"100%\",\n        \"0%\"\n    ],\n    RIGHT: [\n        \"100%\",\n        \"50%\"\n    ],\n    RIGHT_CENTER: [\n        \"100%\",\n        \"50%\"\n    ],\n    RIGHT_BOTTOM: [\n        \"100%\",\n        \"100%\"\n    ],\n    BOTTOM_LEFT: [\n        \"0%\",\n        \"100%\"\n    ],\n    BOTTOM_CENTER: [\n        \"50%\",\n        \"100%\"\n    ],\n    BOTTOM: [\n        \"50%\",\n        \"100%\"\n    ],\n    BOTTOM_RIGHT: [\n        \"100%\",\n        \"100%\"\n    ],\n    CENTER: [\n        \"50%\",\n        \"50%\"\n    ]\n};\nconst AdvancedMarker = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>{\n    const { children, style, className, anchorPoint } = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n    const advancedMarkerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>marker ? {\n            marker\n        } : null, [\n        marker\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    if (!contentContainer) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, {\n        value: advancedMarkerContextValue\n    }, /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerContent, {\n        anchorPoint: anchorPoint,\n        styles: style,\n        className: className\n    }, children), contentContainer));\n});\nAdvancedMarker.displayName = \"AdvancedMarker\";\nfunction useAdvancedMarkerRef() {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\nfunction isAdvancedMarker(marker) {\n    return marker.content !== undefined;\n}\nfunction isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\nconst MarkerContent = ({ children, styles, className })=>{\n    /* AdvancedMarker div that user can give styles and classes */ return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: className,\n        style: styles\n    }, children);\n};\nfunction useAdvancedMarker(props) {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const markerLibrary = useMapsLibrary(\"marker\");\n    const { children, onClick, className, onMouseEnter, onMouseLeave, onDrag, onDragStart, onDragEnd, collisionBehavior, clickable, draggable, position, title, zIndex, anchorPoint, anchorLeft, anchorTop } = props;\n    const numChildren = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n    // create an AdvancedMarkerElement instance and add it to the map once available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map || !markerLibrary) return;\n        const newMarker = new markerLibrary.AdvancedMarkerElement();\n        newMarker.map = map;\n        setMarker(newMarker);\n        // create the container for marker content if there are children\n        let contentElement = null;\n        if (numChildren > 0) {\n            contentElement = document.createElement(\"div\");\n            newMarker.content = contentElement;\n            setContentContainer(contentElement);\n        }\n        return ()=>{\n            newMarker.map = null;\n            contentElement === null || contentElement === void 0 ? void 0 : contentElement.remove();\n            setMarker(null);\n            setContentContainer(null);\n        };\n    }, [\n        map,\n        markerLibrary,\n        numChildren\n    ]);\n    // When no children are present we don't have our own wrapper div\n    // which usually gets the user provided className. In this case\n    // we set the className directly on the marker.content element that comes\n    // with the AdvancedMarker.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!(marker === null || marker === void 0 ? void 0 : marker.content) || !isElementNode(marker.content) || numChildren > 0) return;\n        marker.content.className = className !== null && className !== void 0 ? className : \"\";\n    }, [\n        marker,\n        className,\n        numChildren\n    ]);\n    useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, numChildren > 0);\n    // copy other props\n    usePropBinding(marker, \"position\", position);\n    usePropBinding(marker, \"title\", title !== null && title !== void 0 ? title : \"\");\n    usePropBinding(marker, \"zIndex\", zIndex);\n    usePropBinding(marker, \"collisionBehavior\", collisionBehavior);\n    // set gmpDraggable from props (when unspecified, it's true if any drag-event\n    // callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (draggable !== undefined) marker.gmpDraggable = draggable;\n        else if (onDrag || onDragStart || onDragEnd) marker.gmpDraggable = true;\n        else marker.gmpDraggable = false;\n    }, [\n        marker,\n        draggable,\n        onDrag,\n        onDragEnd,\n        onDragStart\n    ]);\n    // set gmpClickable from props (when unspecified, it's true if the onClick or one of\n    // the hover events callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const gmpClickable = clickable !== undefined || Boolean(onClick) || Boolean(onMouseEnter) || Boolean(onMouseLeave);\n        // gmpClickable is only available in beta version of the\n        // maps api (as of 2024-10-10)\n        marker.gmpClickable = gmpClickable;\n        // enable pointer events for the markers with custom content\n        if (gmpClickable && (marker === null || marker === void 0 ? void 0 : marker.content) && isElementNode(marker.content)) {\n            marker.content.style.pointerEvents = \"all\";\n            if (onClick) {\n                marker.content.style.cursor = \"pointer\";\n            }\n        }\n    }, [\n        marker,\n        clickable,\n        onClick,\n        onMouseEnter,\n        onMouseLeave\n    ]);\n    useMapsEventListener(marker, \"click\", onClick);\n    useMapsEventListener(marker, \"drag\", onDrag);\n    useMapsEventListener(marker, \"dragstart\", onDragStart);\n    useMapsEventListener(marker, \"dragend\", onDragEnd);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, \"mouseenter\", onMouseEnter);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, \"mouseleave\", onMouseLeave);\n    return [\n        marker,\n        contentContainer\n    ];\n}\nfunction useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, hasChildren) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker || !hasChildren) return;\n        // The anchorLeft and anchorTop options are available since version 3.62.9c\n        // With the release of 3.65 (~May 2026) there will no longer be a version\n        // that doesn't support it.\n        const anchorOptionsSupported = isVersionGreaterEqual(3, 62);\n        const contentElement = marker.content;\n        if (!contentElement || !isElementNode(contentElement)) return;\n        if (anchorLeft !== undefined || anchorTop !== undefined) {\n            if (!anchorOptionsSupported) {\n                console.warn(\"AdvancedMarker: The anchorLeft and anchorTop props are only supported \" + \"in Google Maps API version 3.62 and above. \" + `The current version is ${google.maps.version}.`);\n            }\n            marker.anchorLeft = anchorLeft;\n            marker.anchorTop = anchorTop;\n            // when anchorLeft and/or anchorTop are set, we'll ignore the anchorPoint\n            if (anchorPoint !== undefined) {\n                console.warn(\"AdvancedMarker: the anchorPoint prop is ignored when anchorLeft \" + \"and/or anchorTop are set.\");\n            }\n            return;\n        }\n        if (anchorPoint !== undefined) {\n            // TODO: add console.warn in a future version to inform about deprecation\n            const [x, y] = anchorPoint !== null && anchorPoint !== void 0 ? anchorPoint : AdvancedMarkerAnchorPoint[\"BOTTOM\"];\n            // NOTE: since x and y can be any valid CSS length-percentage\n            //   value, we need to use calc() to negate them.\n            const translateX = `calc(-1 * ${x})`;\n            const translateY = `calc(-1 * ${y})`;\n            if (anchorOptionsSupported) {\n                // implement anchorPoint using the new anchorLeft and anchorTop options\n                marker.anchorLeft = translateX;\n                marker.anchorTop = translateY;\n                // reset transform from legacy implementation\n                contentElement.style.transform = \"\";\n            } else {\n                // The \"translate(50%, 100%)\" counters and resets the default\n                // anchoring of the advanced marker element from the api\n                contentElement.style.transform = `translate(50%, 100%) translate(${translateX}, ${translateY})`;\n                // data-origin is needed to identify the custom marker content in the\n                // InfoWindow component as well as in the global CSS used to disable\n                // the pointer event when anchor points are used in older Google Maps\n                // versions.\n                marker.dataset.origin = \"rgm\";\n                globalStyleManager.addAdvancedMarkerPointerEventsOverwrite();\n            }\n        }\n    }, [\n        marker,\n        anchorPoint,\n        anchorLeft,\n        anchorTop,\n        hasChildren\n    ]);\n}\nfunction setValueForStyles(element, styles, prevStyles) {\n    if (styles != null && typeof styles !== \"object\") {\n        throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n    }\n    const elementStyle = element.style;\n    // without `prevStyles`, just set all values\n    if (prevStyles == null) {\n        if (styles == null) return;\n        for(const styleName in styles){\n            if (!styles.hasOwnProperty(styleName)) continue;\n            setValueForStyle(elementStyle, styleName, styles[styleName]);\n        }\n        return;\n    }\n    // unset all styles in `prevStyles` that aren't in `styles`\n    for(const styleName in prevStyles){\n        if (prevStyles.hasOwnProperty(styleName) && (styles == null || !styles.hasOwnProperty(styleName))) {\n            // Clear style\n            const isCustomProperty = styleName.indexOf(\"--\") === 0;\n            if (isCustomProperty) {\n                elementStyle.setProperty(styleName, \"\");\n            } else if (styleName === \"float\") {\n                elementStyle.cssFloat = \"\";\n            } else {\n                elementStyle[styleName] = \"\";\n            }\n        }\n    }\n    // only assign values from `styles` that are different from `prevStyles`\n    if (styles == null) return;\n    for(const styleName in styles){\n        const value = styles[styleName];\n        if (styles.hasOwnProperty(styleName) && prevStyles[styleName] !== value) {\n            setValueForStyle(elementStyle, styleName, value);\n        }\n    }\n}\nfunction setValueForStyle(elementStyle, styleName, value) {\n    const isCustomProperty = styleName.indexOf(\"--\") === 0;\n    // falsy values will unset the style property\n    if (value == null || typeof value === \"boolean\" || value === \"\") {\n        if (isCustomProperty) {\n            elementStyle.setProperty(styleName, \"\");\n        } else if (styleName === \"float\") {\n            elementStyle.cssFloat = \"\";\n        } else {\n            elementStyle[styleName] = \"\";\n        }\n    } else if (isCustomProperty) {\n        elementStyle.setProperty(styleName, value);\n    } else if (typeof value === \"number\" && value !== 0 && !isUnitlessNumber(styleName)) {\n        elementStyle[styleName] = value + \"px\"; // Presumes implicit 'px' suffix for unitless numbers\n    } else {\n        if (styleName === \"float\") {\n            elementStyle.cssFloat = value;\n        } else {\n            elementStyle[styleName] = (\"\" + value).trim();\n        }\n    }\n}\n// CSS properties which accept numbers but are not in units of \"px\".\nconst unitlessNumbers = new Set([\n    \"animationIterationCount\",\n    \"aspectRatio\",\n    \"borderImageOutset\",\n    \"borderImageSlice\",\n    \"borderImageWidth\",\n    \"boxFlex\",\n    \"boxFlexGroup\",\n    \"boxOrdinalGroup\",\n    \"columnCount\",\n    \"columns\",\n    \"flex\",\n    \"flexGrow\",\n    \"flexPositive\",\n    \"flexShrink\",\n    \"flexNegative\",\n    \"flexOrder\",\n    \"gridArea\",\n    \"gridRow\",\n    \"gridRowEnd\",\n    \"gridRowSpan\",\n    \"gridRowStart\",\n    \"gridColumn\",\n    \"gridColumnEnd\",\n    \"gridColumnSpan\",\n    \"gridColumnStart\",\n    \"fontWeight\",\n    \"lineClamp\",\n    \"lineHeight\",\n    \"opacity\",\n    \"order\",\n    \"orphans\",\n    \"scale\",\n    \"tabSize\",\n    \"widows\",\n    \"zIndex\",\n    \"zoom\",\n    \"fillOpacity\",\n    \"floodOpacity\",\n    \"stopOpacity\",\n    \"strokeDasharray\",\n    \"strokeDashoffset\",\n    \"strokeMiterlimit\",\n    \"strokeOpacity\",\n    \"strokeWidth\"\n]);\nfunction isUnitlessNumber(name) {\n    return unitlessNumbers.has(name);\n}\n/**\n * Component to render an Info Window with the Maps JavaScript API\n */ const InfoWindow = (props)=>{\n    const { // content options\n    children, headerContent, style, className, pixelOffset, // open options\n    anchor, shouldFocus, // events\n    onClose, onCloseClick } = props, // other options\n    volatileInfoWindowOptions = __rest(props, [\n        \"children\",\n        \"headerContent\",\n        \"style\",\n        \"className\",\n        \"pixelOffset\",\n        \"anchor\",\n        \"shouldFocus\",\n        \"onClose\",\n        \"onCloseClick\"\n    ]);\n    // ## create infowindow instance once the mapsLibrary is available.\n    const mapsLibrary = useMapsLibrary(\"maps\");\n    const [infoWindow, setInfoWindow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const contentContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const headerContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const infoWindowOptions = useMemoized(volatileInfoWindowOptions, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!mapsLibrary) return;\n        contentContainerRef.current = document.createElement(\"div\");\n        headerContainerRef.current = document.createElement(\"div\");\n        const opts = infoWindowOptions;\n        if (pixelOffset) {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (headerContent) {\n            // if headerContent is specified as string we can directly forward it,\n            // otherwise we'll pass the element the portal will render into\n            opts.headerContent = typeof headerContent === \"string\" ? headerContent : headerContainerRef.current;\n        }\n        // intentionally shadowing the state variables here\n        const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n        infoWindow.setContent(contentContainerRef.current);\n        setInfoWindow(infoWindow);\n        // unmount: remove infoWindow and content elements (note: close is called in a different effect-cleanup)\n        return ()=>{\n            var _a, _b;\n            infoWindow.setContent(null);\n            (_a = contentContainerRef.current) === null || _a === void 0 ? void 0 : _a.remove();\n            (_b = headerContainerRef.current) === null || _b === void 0 ? void 0 : _b.remove();\n            contentContainerRef.current = null;\n            headerContainerRef.current = null;\n            setInfoWindow(null);\n        };\n    }, // `infoWindowOptions` and other props are missing from dependencies:\n    //\n    // We don't want to re-create the infowindow instance\n    // when the options change.\n    // Updating the options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        mapsLibrary\n    ]);\n    // ---- update className and styles for `contentContainer`\n    // prevStyleRef stores previously applied style properties, so they can be\n    // removed when unset\n    const prevStyleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!infoWindow || !contentContainerRef.current) return;\n        setValueForStyles(contentContainerRef.current, style || null, prevStyleRef.current);\n        prevStyleRef.current = style || null;\n        if (className !== contentContainerRef.current.className) contentContainerRef.current.className = className || \"\";\n    }, [\n        infoWindow,\n        className,\n        style\n    ]);\n    // ---- update options\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!infoWindow) return;\n        const opts = infoWindowOptions;\n        if (!pixelOffset) {\n            opts.pixelOffset = null;\n        } else {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (!headerContent) {\n            opts.headerContent = null;\n        } else {\n            opts.headerContent = typeof headerContent === \"string\" ? headerContent : headerContainerRef.current;\n        }\n        infoWindow.setOptions(infoWindowOptions);\n    }, // dependency `infoWindow` isn't needed since options are also passed\n    // to the constructor when a new infoWindow is created.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        infoWindowOptions,\n        pixelOffset,\n        headerContent\n    ]);\n    // ## bind event handlers\n    useMapsEventListener(infoWindow, \"close\", onClose);\n    useMapsEventListener(infoWindow, \"closeclick\", onCloseClick);\n    // ---- open info window when content and map are available\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        // `anchor === null` means an anchor is defined but not ready yet.\n        if (!map || !infoWindow || anchor === null) return;\n        const isOpenedWithAnchor = !!anchor;\n        const openOptions = {\n            map\n        };\n        if (anchor) {\n            openOptions.anchor = anchor;\n            // Only do the infowindow adjusting when dealing with an AdvancedMarker\n            if (isAdvancedMarker(anchor) && anchor.content instanceof Element) {\n                const anchorBcr = anchor === null || anchor === void 0 ? void 0 : anchor.getBoundingClientRect();\n                // This checks whether or not the anchor has custom content with our own\n                // div wrapper. If not, that means we have a regular AdvancedMarker without\n                // children, or an AdvancedMarker that uses the anchorLeft/anchorTop props.\n                // In that case we do not want to adjust the infowindow since it is all handled correctly\n                // by the Google Maps API.\n                if (anchorBcr && anchor.dataset.origin === \"rgm\") {\n                    // We can safely typecast here since we control that element and we know that\n                    // it is a div\n                    const anchorDomContent = (_a = anchor.content.firstElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild;\n                    const contentBcr = anchorDomContent === null || anchorDomContent === void 0 ? void 0 : anchorDomContent.getBoundingClientRect();\n                    // center infowindow above marker\n                    const anchorOffsetX = contentBcr.x - anchorBcr.x + (contentBcr.width - anchorBcr.width) / 2;\n                    const anchorOffsetY = contentBcr.y - anchorBcr.y;\n                    const opts = infoWindowOptions;\n                    opts.pixelOffset = new google.maps.Size(pixelOffset ? pixelOffset[0] + anchorOffsetX : anchorOffsetX, pixelOffset ? pixelOffset[1] + anchorOffsetY : anchorOffsetY);\n                    infoWindow.setOptions(opts);\n                }\n            }\n        }\n        if (shouldFocus !== undefined) {\n            openOptions.shouldFocus = shouldFocus;\n        }\n        infoWindow.open(openOptions);\n        return ()=>{\n            // Note: when the infowindow has an anchor, it will automatically show up again when the\n            // anchor was removed from the map before infoWindow.close() is called but the it gets\n            // added back to the map after that.\n            // More information here: https://issuetracker.google.com/issues/343750849\n            if (isOpenedWithAnchor) infoWindow.set(\"anchor\", null);\n            infoWindow.close();\n        };\n    }, [\n        infoWindow,\n        anchor,\n        map,\n        shouldFocus,\n        infoWindowOptions,\n        pixelOffset\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, contentContainerRef.current && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainerRef.current), headerContainerRef.current !== null && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(headerContent, headerContainerRef.current));\n};\n/**\n * Formats a location into a string representation suitable for Google Static Maps API.\n *\n * @param location - The location to format, can be either a string or an object with lat/lng properties\n * @returns A string representation of the location in the format \"lat,lng\" or the original string\n *\n * @example\n * // Returns \"40.714728,-73.998672\"\n * formatLocation({ lat: 40.714728, lng: -73.998672 })\n *\n * @example\n * // Returns \"New York, NY\"\n * formatLocation(\"New York, NY\")\n */ function formatLocation(location) {\n    return typeof location === \"string\" ? location : `${location.lat},${location.lng}`;\n}\n// Used for removing the leading pipe from the param string\nfunction formatParam(string) {\n    return string.slice(1);\n}\n/**\n * Assembles marker parameters for static maps.\n *\n * This function takes an array of markers and groups them by their style properties.\n * It then creates a string representation of these markers, including their styles and locations,\n * which can be used as parameters for static map APIs.\n *\n * @param {StaticMapsMarker[]} [markers=[]] - An array of markers to be processed. Each marker can have properties such as color, label, size, scale, icon, anchor, and location.\n * @returns {string[]} An array of strings, each representing a group of markers with their styles and locations.\n *\n * @example\n * const markers = [\n *   { color: 'blue', label: 'A', size: 'mid', location: '40.714728,-73.998672' },\n *   { color: 'blue', label: 'B', size: 'mid', location: '40.714728,-73.998672' },\n *   { icon: 'http://example.com/icon.png', location: { lat: 40.714728, lng: -73.998672 } }\n * ];\n * const params = assembleMarkerParams(markers);\n * // Params will be an array of strings representing the marker parameters\n * Example output: [\n *   \"color:blue|label:A|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"color:blue|label:B|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"icon:http://example.com/icon.png|40.714728,-73.998672\"\n * ]\n */ function assembleMarkerParams(markers = []) {\n    const markerParams = [];\n    // Group markers by style\n    const markersByStyle = markers === null || markers === void 0 ? void 0 : markers.reduce((styles, marker)=>{\n        const { color = \"red\", label, size, scale, icon, anchor } = marker;\n        // Create a unique style key based on either icon properties or standard marker properties\n        const relevantProps = icon ? [\n            icon,\n            anchor,\n            scale\n        ] : [\n            color,\n            label,\n            size\n        ];\n        const key = relevantProps.filter(Boolean).join(\"-\");\n        styles[key] = styles[key] || [];\n        styles[key].push(marker);\n        return styles;\n    }, {});\n    Object.values(markersByStyle !== null && markersByStyle !== void 0 ? markersByStyle : {}).forEach((markers)=>{\n        let markerParam = \"\";\n        const { icon } = markers[0];\n        // Create marker style from first marker in group since all markers share the same style.\n        Object.entries(markers[0]).forEach(([key, value])=>{\n            // Determine which properties to include based on whether marker uses custom icon\n            const relevantKeys = icon ? [\n                \"icon\",\n                \"anchor\",\n                \"scale\"\n            ] : [\n                \"color\",\n                \"label\",\n                \"size\"\n            ];\n            if (relevantKeys.includes(key)) {\n                markerParam += `|${key}:${value}`;\n            }\n        });\n        // Add location coordinates for each marker in the style group\n        // Handles both string locations and lat/lng object formats.\n        for (const marker of markers){\n            const location = typeof marker.location === \"string\" ? marker.location : `${marker.location.lat},${marker.location.lng}`;\n            markerParam += `|${location}`;\n        }\n        markerParams.push(markerParam);\n    });\n    return markerParams.map(formatParam);\n}\n// Style properties that can be applied to paths in the Static Maps API\nconst PATH_STYLE_KEYS = [\n    \"color\",\n    \"weight\",\n    \"fillcolor\",\n    \"geodesic\"\n];\n/**\n * Builds the style portion of a path parameter string.\n * @param path - The path object containing style properties\n * @returns A string with style parameters in the format \"|key:value\"\n */ function buildStyleParams(path) {\n    let styleParams = \"\";\n    PATH_STYLE_KEYS.forEach((key)=>{\n        if (path[key] !== undefined) {\n            styleParams += `|${key}:${path[key]}`;\n        }\n    });\n    return styleParams;\n}\n/**\n * Builds the coordinates portion of a path parameter string.\n * @param coordinates - Either a string or array of location objects\n * @returns A string with coordinates in the format \"|lat,lng|lat,lng\"\n */ function buildCoordinateParams(coordinates) {\n    if (typeof coordinates === \"string\") {\n        return `|${decodeURIComponent(coordinates)}`;\n    }\n    return coordinates.map((location)=>`|${formatLocation(location)}`).join(\"\");\n}\n/**\n * Assembles path parameters for the Static Maps API from an array of paths.\n *\n * This function constructs a string of path parameters for each path. Each path parameter string\n * includes the style properties and the coordinates of the paths.\n *\n * @param {Array<StaticMapsPath>} [paths=[]] - An array of paths to be assembled into path parameters.\n * @returns {Array<string>} An array of path parameter strings.\n *\n * @example\n * ```typescript\n * const paths = [\n *   {\n *     color: 'red',\n *     weight: 5,\n *     coordinates: [\n *       { lat: 40.714728, lng: -73.998672 },\n *       { lat: 40.718217, lng: -73.998284 }\n *     ]\n *   }\n * ];\n *\n * const pathParams = assemblePathParams(paths);\n * // Output: ['color:red|weight:5|40.714728,-73.998672|40.718217,-73.998284']\n * ```\n */ function assemblePathParams(paths = []) {\n    return paths.map((path)=>{\n        const styleParams = buildStyleParams(path);\n        const coordinateParams = buildCoordinateParams(path.coordinates);\n        const pathParam = styleParams + coordinateParams;\n        return formatParam(pathParam);\n    });\n}\n/**\n * Converts an array of Google Maps style objects into an array of style strings\n * compatible with the Google Static Maps API.\n *\n * @param styles - An array of Google Maps MapTypeStyle objects that define the styling rules\n * @returns An array of formatted style strings ready to be used with the Static Maps API\n *\n * @example\n * const styles = [{\n *   featureType: \"road\",\n *   elementType: \"geometry\",\n *   stylers: [{color: \"#ff0000\"}, {weight: 1}]\n * }];\n *\n * const styleStrings = assembleMapTypeStyles(styles);\n * // Returns: [\"|feature:road|element:geometry|color:0xff0000|weight:1\"]\n *\n * Each style string follows the format:\n * \"feature:{featureType}|element:{elementType}|{stylerName}:{stylerValue}\"\n *\n * Note: Color values with hexadecimal notation (#) are automatically converted\n * to the required 0x format for the Static Maps API.\n */ function assembleMapTypeStyles(styles) {\n    return styles.map((mapTypeStyle)=>{\n        const { featureType, elementType, stylers = [] } = mapTypeStyle;\n        let styleString = \"\";\n        if (featureType) {\n            styleString += `|feature:${featureType}`;\n        }\n        if (elementType) {\n            styleString += `|element:${elementType}`;\n        }\n        for (const styler of stylers){\n            Object.entries(styler).forEach(([name, value])=>{\n                styleString += `|${name}:${String(value).replace(\"#\", \"0x\")}`;\n            });\n        }\n        return styleString;\n    }).map(formatParam);\n}\nconst STATIC_MAPS_BASE = \"https://maps.googleapis.com/maps/api/staticmap\";\n/**\n * Creates a URL for the Google Static Maps API with the specified parameters.\n *\n * @param {Object} options - The configuration options for the static map\n * @param {string} options.apiKey - Your Google Maps API key (required)\n * @param {number} options.width - The width of the map image in pixels (required)\n * @param {number} options.height - The height of the map image in pixels (required)\n * @param {StaticMapsLocation} [options.center] - The center point of the map (lat/lng or address).\n *  Required if no markers or paths or \"visible locations\" are provided.\n * @param {number} [options.zoom] - The zoom level of the map. Required if no markers or paths or \"visible locations\" are provided.\n * @param {1|2|4} [options.scale] - The resolution of the map (1, 2, or 4)\n * @param {string} [options.format] - The image format (png, png8, png32, gif, jpg, jpg-baseline)\n * @param {string} [options.mapType] - The type of map (roadmap, satellite, terrain, hybrid)\n * @param {string} [options.language] - The language of the map labels\n * @param {string} [options.region] - The region code for the map\n * @param {string} [options.map_id] - The Cloud-based map style ID\n * @param {StaticMapsMarker[]} [options.markers=[]] - Array of markers to display on the map\n * @param {StaticMapsPath[]} [options.paths=[]] - Array of paths to display on the map\n * @param {StaticMapsLocation[]} [options.visible=[]] - Array of locations that should be visible on the map\n * @param {MapTypeStyle[]} [options.style=[]] - Array of style objects to customize the map appearance\n *\n * @returns {string} The complete Google Static Maps API URL\n *\n * @throws {Error} If API key is not provided\n * @throws {Error} If width or height is not provided\n *\n * @example\n * const url = createStaticMapsUrl({\n *   apiKey: 'YOUR_API_KEY',\n *   width: 600,\n *   height: 400,\n *   center: { lat: 40.714728, lng: -73.998672 },\n *   zoom: 12,\n *   markers: [\n *     {\n *       location: { lat: 40.714728, lng: -73.998672 },\n *       color: 'red',\n *       label: 'A'\n *     }\n *   ],\n *   paths: [\n *     {\n *       coordinates: [\n *         { lat: 40.714728, lng: -73.998672 },\n *         { lat: 40.719728, lng: -73.991672 }\n *       ],\n *       color: '0x0000ff',\n *       weight: 5\n *     }\n *   ],\n *   style: [\n *     {\n *       featureType: 'road',\n *       elementType: 'geometry',\n *       stylers: [{color: '#00ff00'}]\n *     }\n *   ]\n * });\n *\n * // Results in URL similar to:\n * // https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY\n * // &size=600x400\n * // &center=40.714728,-73.998672&zoom=12\n * // &markers=color:red|label:A|40.714728,-73.998672\n * // &path=color:0x0000ff|weight:5|40.714728,-73.998672|40.719728,-73.991672\n * // &style=feature:road|element:geometry|color:0x00ff00\n */ function createStaticMapsUrl({ apiKey, width, height, center, zoom, scale, format, mapType, language, region, mapId, markers = [], paths = [], visible = [], style = [] }) {\n    if (!apiKey) {\n        console.warn(\"API key is required\");\n    }\n    if (!width || !height) {\n        console.warn(\"Width and height are required\");\n    }\n    const params = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        key: apiKey,\n        size: `${width}x${height}`\n    }, center && {\n        center: formatLocation(center)\n    }), zoom && {\n        zoom\n    }), scale && {\n        scale\n    }), format && {\n        format\n    }), mapType && {\n        maptype: mapType\n    }), language && {\n        language\n    }), region && {\n        region\n    }), mapId && {\n        map_id: mapId\n    });\n    const url = new URL(STATIC_MAPS_BASE);\n    // Params that don't need special handling\n    Object.entries(params).forEach(([key, value])=>{\n        url.searchParams.append(key, String(value));\n    });\n    // Assemble Markers\n    for (const markerParam of assembleMarkerParams(markers)){\n        url.searchParams.append(\"markers\", markerParam);\n    }\n    // Assemble Paths\n    for (const pathParam of assemblePathParams(paths)){\n        url.searchParams.append(\"path\", pathParam);\n    }\n    // Assemble visible locations\n    if (visible.length) {\n        url.searchParams.append(\"visible\", visible.map((location)=>formatLocation(location)).join(\"|\"));\n    }\n    // Assemble Map Type Styles\n    for (const styleString of assembleMapTypeStyles(style)){\n        url.searchParams.append(\"style\", styleString);\n    }\n    return url.toString();\n}\nconst StaticMap = (props)=>{\n    const { url, className } = props;\n    if (!url) throw new Error(\"URL is required\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        className: className,\n        src: url,\n        width: \"100%\"\n    });\n};\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */ const ControlPosition = {\n    TOP_LEFT: 1,\n    TOP_CENTER: 2,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    LEFT_CENTER: 4,\n    LEFT_TOP: 5,\n    LEFT: 5,\n    LEFT_BOTTOM: 6,\n    RIGHT_TOP: 7,\n    RIGHT: 7,\n    RIGHT_CENTER: 8,\n    RIGHT_BOTTOM: 9,\n    BOTTOM_LEFT: 10,\n    BOTTOM_CENTER: 11,\n    BOTTOM: 11,\n    BOTTOM_RIGHT: 12,\n    CENTER: 13,\n    BLOCK_START_INLINE_START: 14,\n    BLOCK_START_INLINE_CENTER: 15,\n    BLOCK_START_INLINE_END: 16,\n    INLINE_START_BLOCK_CENTER: 17,\n    INLINE_START_BLOCK_START: 18,\n    INLINE_START_BLOCK_END: 19,\n    INLINE_END_BLOCK_START: 20,\n    INLINE_END_BLOCK_CENTER: 21,\n    INLINE_END_BLOCK_END: 22,\n    BLOCK_END_INLINE_START: 23,\n    BLOCK_END_INLINE_CENTER: 24,\n    BLOCK_END_INLINE_END: 25\n};\nconst MapControl = ({ children, position })=>{\n    const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const controls = map.controls[position];\n        controls.push(controlContainer);\n        return ()=>{\n            const controlsArray = controls.getArray();\n            // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n            if (!controlsArray) return;\n            const index = controlsArray.indexOf(controlContainer);\n            controls.removeAt(index);\n        };\n    }, [\n        controlContainer,\n        map,\n        position\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\nfunction useMarker(props) {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const { onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut } = props, markerOptions = __rest(props, [\n        \"onClick\",\n        \"onDrag\",\n        \"onDragStart\",\n        \"onDragEnd\",\n        \"onMouseOver\",\n        \"onMouseOut\"\n    ]);\n    const { position, draggable } = markerOptions;\n    // create marker instance and add to the map once the map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) {\n            if (map === undefined) console.error(\"<Marker> has to be inside a Map component.\");\n            return;\n        }\n        const newMarker = new google.maps.Marker(markerOptions);\n        newMarker.setMap(map);\n        setMarker(newMarker);\n        return ()=>{\n            newMarker.setMap(null);\n            setMarker(null);\n        };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map\n    ]);\n    // attach and re-attach event-handlers when any of the properties change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const m = marker;\n        // Add event listeners\n        const gme = google.maps.event;\n        if (onClick) gme.addListener(m, \"click\", onClick);\n        if (onDrag) gme.addListener(m, \"drag\", onDrag);\n        if (onDragStart) gme.addListener(m, \"dragstart\", onDragStart);\n        if (onDragEnd) gme.addListener(m, \"dragend\", onDragEnd);\n        if (onMouseOver) gme.addListener(m, \"mouseover\", onMouseOver);\n        if (onMouseOut) gme.addListener(m, \"mouseout\", onMouseOut);\n        marker.setDraggable(Boolean(draggable));\n        return ()=>{\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDrag,\n        onDragStart,\n        onDragEnd,\n        onMouseOver,\n        onMouseOut\n    ]);\n    // update markerOptions (note the dependencies aren't properly checked\n    // here, we just assume that setOptions is smart enough to not waste a\n    // lot of time updating values that didn't change)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (markerOptions) marker.setOptions(markerOptions);\n    }, [\n        marker,\n        markerOptions\n    ]);\n    // update position when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Should not update position when draggable\n        if (draggable || !position || !marker) return;\n        marker.setPosition(position);\n    }, [\n        draggable,\n        position,\n        marker\n    ]);\n    return marker;\n}\n/**\n * Component to render a marker on a map\n */ const Marker = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>{\n    const marker = useMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n});\nMarker.displayName = \"Marker\";\nfunction useMarkerRef() {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\n/**\n * Component to configure the appearance of an AdvancedMarker\n */ const Pin = (props)=>{\n    var _a;\n    const advancedMarker = (_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) === null || _a === void 0 ? void 0 : _a.marker;\n    const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    // Create Pin View instance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!advancedMarker) {\n            if (advancedMarker === undefined) {\n                console.error(\"The <Pin> component can only be used inside <AdvancedMarker>.\");\n            }\n            return;\n        }\n        if (props.glyph && props.children) {\n            logErrorOnce(\"The <Pin> component only uses children to render the glyph if both the glyph property and children are present.\");\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n            logErrorOnce(\"Passing multiple children to the <Pin> component might lead to unexpected results.\");\n        }\n        const pinViewOptions = Object.assign({}, props);\n        const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n        // Set glyph to glyph container if children are present (rendered via portal).\n        // If both props.glyph and props.children are present, props.children takes priority.\n        if (props.children) {\n            pinElement.glyph = glyphContainer;\n        }\n        // Set content of Advanced Marker View to the Pin View element\n        // Here we are selecting the anchor container.\n        // The hierarchy is as follows:\n        // \"advancedMarker.content\" (from google) -> \"anchor container\"\n        const markerContent = (_a = advancedMarker.content) === null || _a === void 0 ? void 0 : _a.firstChild;\n        while(markerContent === null || markerContent === void 0 ? void 0 : markerContent.firstChild){\n            markerContent.removeChild(markerContent.firstChild);\n        }\n        if (markerContent) {\n            markerContent.appendChild(pinElement.element);\n        }\n    }, [\n        advancedMarker,\n        glyphContainer,\n        props\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\nconst mapLinear = (x, a1, a2, b1, b2)=>b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = (zoom)=>{\n    if (zoom <= 10) {\n        return 30;\n    }\n    if (zoom >= 15.5) {\n        return 67.5;\n    }\n    // range [10...14]\n    if (zoom <= 14) {\n        return mapLinear(zoom, 10, 14, 30, 45);\n    }\n    // range [14...15.5]\n    return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the Google map when updating the view state\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = ({ viewState })=>{\n    const pitch = viewState.pitch;\n    const gmZoom = viewState.zoom + 1;\n    const maxTilt = getMapMaxTilt(gmZoom);\n    return Object.assign(Object.assign({}, viewState), {\n        fovy: 25,\n        pitch: Math.min(maxTilt, pitch)\n    });\n};\n //# sourceMappingURL=index.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpcy5nbC9yZWFjdC1nb29nbGUtbWFwcy9kaXN0L2luZGV4Lm1vZGVybi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFLO0FBQzVIO0FBQ0M7QUFFMUMsMkRBQTJEO0FBQzNELE1BQU1jLFVBQVU7QUFFaEI7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDhEQUE4RCxHQUc5RCxTQUFTQyxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUlDLElBQUksR0FBR1AsSUFBSUMsT0FBT0sscUJBQXFCLENBQUNULElBQUlVLElBQUlQLEVBQUVRLE1BQU0sRUFBRUQsSUFBSztRQUNwRSxJQUFJVCxFQUFFTyxPQUFPLENBQUNMLENBQUMsQ0FBQ08sRUFBRSxJQUFJLEtBQUtOLE9BQU9DLFNBQVMsQ0FBQ08sb0JBQW9CLENBQUNMLElBQUksQ0FBQ1AsR0FBR0csQ0FBQyxDQUFDTyxFQUFFLEdBQ3pFUixDQUFDLENBQUNDLENBQUMsQ0FBQ08sRUFBRSxDQUFDLEdBQUdWLENBQUMsQ0FBQ0csQ0FBQyxDQUFDTyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPUjtBQUNYO0FBRUEsU0FBU1csVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUs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QUFPbVosVUFBVW5aLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDekM7QUFDQTs7Q0FFQyxHQUNELDhEQUE4RDtBQUM5RCxNQUFNeVosaUJBQWlCLENBQUMsRUFBRXhWLFNBQVMsRUFBRTtJQUNqQyxNQUFNSyxRQUFRTCxVQUFVSyxLQUFLO0lBQzdCLE1BQU1vVixTQUFTelYsVUFBVWpFLElBQUksR0FBRztJQUNoQyxNQUFNMlosVUFBVUgsY0FBY0U7SUFDOUIsT0FBTzFqQixPQUFPNEcsTUFBTSxDQUFDNUcsT0FBTzRHLE1BQU0sQ0FBQyxDQUFDLEdBQUdxSCxZQUFZO1FBQUUyVixNQUFNO1FBQUl0VixPQUFPdVYsS0FBS0MsR0FBRyxDQUFDSCxTQUFTclY7SUFBTztBQUNuRztBQUV3ZCxDQUN4ZCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9wbXViaS13ZWIvLi9ub2RlX21vZHVsZXMvQHZpcy5nbC9yZWFjdC1nb29nbGUtbWFwcy9kaXN0L2luZGV4Lm1vZGVybi5tanM/ZTdjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZHVjZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0LCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgaXNEZWVwRXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsJztcblxuLy8gVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBieSB0aGUgYnVpbGQgcHJvY2Vzcy5cbmNvbnN0IFZFUlNJT04gPSAnMS43LjEnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbmNvbnN0IEFQSUxvYWRpbmdTdGF0dXMgPSB7XG4gICAgTk9UX0xPQURFRDogJ05PVF9MT0FERUQnLFxuICAgIExPQURJTkc6ICdMT0FESU5HJyxcbiAgICBMT0FERUQ6ICdMT0FERUQnLFxuICAgIEZBSUxFRDogJ0ZBSUxFRCcsXG4gICAgQVVUSF9GQUlMVVJFOiAnQVVUSF9GQUlMVVJFJ1xufTtcblxuY29uc3QgTUFQU19BUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzJztcbi8qKlxuICogQSBHb29nbGVNYXBzQXBpTG9hZGVyIHRvIHJlbGlhYmx5IGxvYWQgYW5kIHVubG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkuXG4gKlxuICogVGhlIGFjdHVhbCBsb2FkaW5nIGFuZCB1bmxvYWRpbmcgaXMgZGVsYXllZCBpbnRvIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHRvXG4gKiBhbGxvdyB1c2luZyB0aGUgQVBJIGluIGFuIHVzZUVmZmVjdCBob29rLCB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IG11bHRpcGxlIEFQSSBsb2Fkcy5cbiAqL1xuY2xhc3MgR29vZ2xlTWFwc0FwaUxvYWRlciB7XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIE1hcHMgSmF2YVNjcmlwdCBBUEkgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gICAgICogU2luY2UgdGhlIE1hcHMgbGlicmFyeSBjYW4gb25seSBiZSBsb2FkZWQgb25jZSBwZXIgcGFnZSwgdGhpcyB3aWxsXG4gICAgICogcHJvZHVjZSBhIHdhcm5pbmcgd2hlbiBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnRcbiAgICAgKiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIGNvbXBsZXRlc1xuICAgICAqIGFuZCByZWplY3RzIGluIGNhc2Ugb2YgYW4gZXJyb3Igb3Igd2hlbiB0aGUgbG9hZGluZyB3YXMgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9hZChwYXJhbXMsIG9uTG9hZGluZ1N0YXR1c0NoYW5nZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IGxpYnJhcmllcyA9IHBhcmFtcy5saWJyYXJpZXMgPyBwYXJhbXMubGlicmFyaWVzLnNwbGl0KCcsJykgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXJhbXMgPSB0aGlzLnNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChvbkxvYWRpbmdTdGF0dXNDaGFuZ2UpO1xuICAgICAgICAgICAgLy8gTm90ZTogaWYgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGhhcyBiZWVuIGRlZmluZWQgZXh0ZXJuYWxseSwgd2VcbiAgICAgICAgICAgIC8vICAgYXNzdW1lIHRoYXQgbG9hZGluZyBpcyBjb21wbGV0ZSBhbmQgc3VjY2Vzc2Z1bC5cbiAgICAgICAgICAgIC8vICAgSWYgaXQgd2FzIGRlZmluZWQgYnkgYSBwcmV2aW91cyBjYWxsIHRvIHRoaXMgbWV0aG9kLCBhIHdhcm5pbmdcbiAgICAgICAgICAgIC8vICAgbWVzc2FnZSBpcyBsb2dnZWQgaWYgdGhlcmUgYXJlIGRpZmZlcmVuY2VzIGluIGFwaS1wYXJhbWV0ZXJzIHVzZWRcbiAgICAgICAgICAgIC8vICAgZm9yIGJvdGggY2FsbHMuXG4gICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gd2luZG93Lmdvb2dsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbXBvcnRMaWJyYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gc2VyaWFsaXplZCBwYXJhbWV0ZXJzIG1lYW5zIGl0IHdhcyBsb2FkZWQgZXh0ZXJuYWxseVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXJpYWxpemVkQXBpUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyA9IHNlcmlhbGl6ZWRQYXJhbXM7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0SW1wb3J0TGlicmFyeShwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyAhPT0gc2VyaWFsaXplZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW2dvb2dsZS1tYXBzLWFwaS1sb2FkZXJdIFRoZSBtYXBzIEFQSSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHdpdGggZGlmZmVyZW50IHBhcmFtZXRlcnMgYW5kIHdpbGwgbm90IGJlIGxvYWRlZCBhZ2Fpbi4gUmVmcmVzaCB0aGUgYCArXG4gICAgICAgICAgICAgICAgICAgIGBwYWdlIGZvciBuZXcgdmFsdWVzIHRvIGhhdmUgZWZmZWN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlicmFyaWVzVG9Mb2FkID0gWydtYXBzJywgLi4ubGlicmFyaWVzXTtcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGxpYnJhcmllc1RvTG9hZC5tYXAobmFtZSA9PiBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KG5hbWUpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBsb2FkIHRoZSBsaWJyYXJ5IGZvciBlYXNpZXIgY29tcGFyaXNvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VyaWFsaXplUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcGFyYW1zLnYsXG4gICAgICAgICAgICBwYXJhbXMua2V5LFxuICAgICAgICAgICAgcGFyYW1zLmxhbmd1YWdlLFxuICAgICAgICAgICAgcGFyYW1zLnJlZ2lvbixcbiAgICAgICAgICAgIHBhcmFtcy5hdXRoUmVmZXJyZXJQb2xpY3ksXG4gICAgICAgICAgICBwYXJhbXMuc29sdXRpb25DaGFubmVsXG4gICAgICAgIF0uam9pbignLycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBnbG9iYWwgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGZ1bmN0aW9uIGZvciBib290c3RyYXBwaW5nLlxuICAgICAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiB0aGUgZHluYW1pYyBsb2FkaW5nIHNjcmlwdFxuICAgICAqIGZyb20gdGhlIG9mZmljaWFsIGRvY3VtZW50YXRpb24gd2l0aCBzb21lIG1pbm9yIGFkanVzdG1lbnRzLlxuICAgICAqXG4gICAgICogVGhlIGNyZWF0ZWQgaW1wb3J0TGlicmFyeSBmdW5jdGlvbiB3aWxsIGxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJLFxuICAgICAqIHdoaWNoIHdpbGwgdGhlbiByZXBsYWNlIHRoZSBgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeWAgZnVuY3Rpb24gd2l0aCB0aGUgZnVsbFxuICAgICAqIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9sb2FkLW1hcHMtanMtYXBpI2R5bmFtaWMtbGlicmFyeS1pbXBvcnRcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5pdEltcG9ydExpYnJhcnkocGFyYW1zKSB7XG4gICAgICAgIGlmICghd2luZG93Lmdvb2dsZSlcbiAgICAgICAgICAgIHdpbmRvdy5nb29nbGUgPSB7fTtcbiAgICAgICAgaWYgKCF3aW5kb3cuZ29vZ2xlLm1hcHMpXG4gICAgICAgICAgICB3aW5kb3cuZ29vZ2xlLm1hcHMgPSB7fTtcbiAgICAgICAgaWYgKHdpbmRvdy5nb29nbGUubWFwc1snaW1wb3J0TGlicmFyeSddKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbZ29vZ2xlLW1hcHMtYXBpLWxvYWRlci1pbnRlcm5hbF06IGluaXRJbXBvcnRMaWJyYXJ5IG11c3Qgb25seSBiZSBjYWxsZWQgb25jZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhcGlQcm9taXNlID0gbnVsbDtcbiAgICAgICAgY29uc3QgbG9hZEFwaSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChhcGlQcm9taXNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlQcm9taXNlO1xuICAgICAgICAgICAgYXBpUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybFBhcmFtTmFtZSA9IGtleS5yZXBsYWNlKC9bQS1aXS9nLCB0ID0+ICdfJyArIHRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQodXJsUGFyYW1OYW1lLCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zLnNldCgnbG9hZGluZycsICdhc3luYycpO1xuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQoJ2NhbGxiYWNrJywgJ19fZ29vZ2xlTWFwc0NhbGxiYWNrX18nKTtcbiAgICAgICAgICAgICAgICBzY3JpcHRFbGVtZW50LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzY3JpcHRFbGVtZW50LnNyYyA9IE1BUFNfQVBJX0JBU0VfVVJMICsgYD9gICsgdXJsUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5ub25jZSA9XG4gICAgICAgICAgICAgICAgICAgICgoX2EgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbbm9uY2VdJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub25jZSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBjb3VsZCBub3QgbG9hZC4nKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19nb29nbGVNYXBzQ2FsbGJhY2tfXyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5MT0FERUQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZ21fYXV0aEZhaWx1cmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuQVVUSF9GQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BRElORztcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZChzY3JpcHRFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFwaVByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciB0aGUgZmlyc3QgbG9hZCwgd2UgZGVjbGFyZSBhbiBpbXBvcnRMaWJyYXJ5IGZ1bmN0aW9uIHRoYXQgd2lsbFxuICAgICAgICAvLyBiZSBvdmVyd3JpdHRlbiBvbmNlIHRoZSBhcGkgaXMgbG9hZGVkLlxuICAgICAgICBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5ID0gbGlicmFyeU5hbWUgPT4gbG9hZEFwaSgpLnRoZW4oKCkgPT4gZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShsaWJyYXJ5TmFtZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBhbGwgcmVnaXN0ZXJlZCBsb2FkaW5nU3RhdHVzTGlzdGVuZXJzIGFmdGVyIGEgc3RhdHVzIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpIHtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAgZm4odGhpcy5sb2FkaW5nU3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhlIGN1cnJlbnQgbG9hZGluZ1N0YXR1cyBvZiB0aGUgQVBJLlxuICovXG5Hb29nbGVNYXBzQXBpTG9hZGVyLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLk5PVF9MT0FERUQ7XG4vKipcbiAqIEEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgbG9hZGluZyBzdGF0dXMgY2hhbmdlcy5cbiAqL1xuR29vZ2xlTWFwc0FwaUxvYWRlci5saXN0ZW5lcnMgPSBbXTtcblxuY29uc3QgREVGQVVMVF9TT0xVVElPTl9DSEFOTkVMID0gJ0dNUF92aXNnbF9yZ21saWJyYXJ5X3YxX2RlZmF1bHQnO1xuY29uc3QgREVGQVVMVF9JTlRFUk5BTF9VU0FHRV9BVFRSSUJVVElPTl9JRFMgPSBbXG4gICAgYGdtcF92aXNnbF9yZWFjdGdvb2dsZW1hcHNfdiR7VkVSU0lPTn1gXG5dO1xuY29uc3QgQVBJUHJvdmlkZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxuICogbG9jYWwgaG9vayB0byBzZXQgdXAgdGhlIG1hcC1pbnN0YW5jZSBtYW5hZ2VtZW50IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlcygpIHtcbiAgICBjb25zdCBbbWFwSW5zdGFuY2VzLCBzZXRNYXBJbnN0YW5jZXNdID0gdXNlU3RhdGUoe30pO1xuICAgIGNvbnN0IGFkZE1hcEluc3RhbmNlID0gKG1hcEluc3RhbmNlLCBpZCA9ICdkZWZhdWx0JykgPT4ge1xuICAgICAgICBzZXRNYXBJbnN0YW5jZXMoaW5zdGFuY2VzID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlcyksIHsgW2lkXTogbWFwSW5zdGFuY2UgfSkpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZU1hcEluc3RhbmNlID0gKGlkID0gJ2RlZmF1bHQnKSA9PiB7XG4gICAgICAgIHNldE1hcEluc3RhbmNlcygoX2EpID0+IHtcbiAgICAgICAgICAgIHZhciBfYiA9IGlkOyBfYVtfYl07IHZhciByZW1haW5pbmcgPSBfX3Jlc3QoX2EsIFt0eXBlb2YgX2IgPT09IFwic3ltYm9sXCIgPyBfYiA6IF9iICsgXCJcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhck1hcEluc3RhbmNlcyA9ICgpID0+IHtcbiAgICAgICAgc2V0TWFwSW5zdGFuY2VzKHt9KTtcbiAgICB9O1xuICAgIHJldHVybiB7IG1hcEluc3RhbmNlcywgYWRkTWFwSW5zdGFuY2UsIHJlbW92ZU1hcEluc3RhbmNlLCBjbGVhck1hcEluc3RhbmNlcyB9O1xufVxuLyoqXG4gKiBsb2NhbCBob29rIHRvIGhhbmRsZSB0aGUgbG9hZGluZyBvZiB0aGUgbWFwcyBBUEksIHJldHVybnMgdGhlIGN1cnJlbnQgbG9hZGluZyBzdGF0dXNcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5mdW5jdGlvbiB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBvbkxvYWQsIG9uRXJyb3IsIGFwaUtleSwgdmVyc2lvbiwgbGlicmFyaWVzID0gW10gfSA9IHByb3BzLCBvdGhlckFwaVBhcmFtcyA9IF9fcmVzdChwcm9wcywgW1wib25Mb2FkXCIsIFwib25FcnJvclwiLCBcImFwaUtleVwiLCBcInZlcnNpb25cIiwgXCJsaWJyYXJpZXNcIl0pO1xuICAgIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZShHb29nbGVNYXBzQXBpTG9hZGVyLmxvYWRpbmdTdGF0dXMpO1xuICAgIGNvbnN0IFtsb2FkZWRMaWJyYXJpZXMsIGFkZExvYWRlZExpYnJhcnldID0gdXNlUmVkdWNlcigobG9hZGVkTGlicmFyaWVzLCBhY3Rpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIGxvYWRlZExpYnJhcmllc1thY3Rpb24ubmFtZV1cbiAgICAgICAgICAgID8gbG9hZGVkTGlicmFyaWVzXG4gICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9hZGVkTGlicmFyaWVzKSwgeyBbYWN0aW9uLm5hbWVdOiBhY3Rpb24udmFsdWUgfSk7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGxpYnJhcmllc1N0cmluZyA9IHVzZU1lbW8oKCkgPT4gbGlicmFyaWVzID09PSBudWxsIHx8IGxpYnJhcmllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlicmFyaWVzLmpvaW4oJywnKSwgW2xpYnJhcmllc10pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXJhbXMgPSB1c2VNZW1vKCgpID0+IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oeyBhcGlLZXksIHZlcnNpb24gfSwgb3RoZXJBcGlQYXJhbXMpKSwgW2FwaUtleSwgdmVyc2lvbiwgb3RoZXJBcGlQYXJhbXNdKTtcbiAgICBjb25zdCBpbXBvcnRMaWJyYXJ5ID0gdXNlQ2FsbGJhY2soKG5hbWUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobG9hZGVkTGlicmFyaWVzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVkTGlicmFyaWVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKChfYSA9IGdvb2dsZSA9PT0gbnVsbCB8fCBnb29nbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdvb2dsZS5tYXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW1wb3J0TGlicmFyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW2FwaS1wcm92aWRlci1pbnRlcm5hbF0gaW1wb3J0TGlicmFyeSB3YXMgY2FsbGVkIGJlZm9yZSAnICtcbiAgICAgICAgICAgICAgICAnZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSB3YXMgZGVmaW5lZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB3aW5kb3cuZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgICAgICAgYWRkTG9hZGVkTGlicmFyeSh7IG5hbWUsIHZhbHVlOiByZXMgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSksIFtsb2FkZWRMaWJyYXJpZXNdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHsga2V5OiBhcGlLZXkgfSwgb3RoZXJBcGlQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgaWYgKChsaWJyYXJpZXNTdHJpbmcgPT09IG51bGwgfHwgbGlicmFyaWVzU3RyaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaWJyYXJpZXNTdHJpbmcubGVuZ3RoKSA+IDApXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5saWJyYXJpZXMgPSBsaWJyYXJpZXNTdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jaGFubmVsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNoYW5uZWwgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jaGFubmVsID4gOTk5KVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zb2x1dGlvbkNoYW5uZWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNvbHV0aW9uQ2hhbm5lbCA9IERFRkFVTFRfU09MVVRJT05fQ0hBTk5FTDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuc29sdXRpb25DaGFubmVsID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5zb2x1dGlvbkNoYW5uZWw7XG4gICAgICAgICAgICAgICAgeWllbGQgR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkKHBhcmFtcywgc3RhdHVzID0+IHNldFN0YXR1cyhzdGF0dXMpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgWydjb3JlJywgJ21hcHMnLCAuLi5saWJyYXJpZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCc8QXBpUHJvdmlkZXI+IGZhaWxlZCB0byBsb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSScsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSgpO1xuICAgIH0sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbYXBpS2V5LCBsaWJyYXJpZXNTdHJpbmcsIHNlcmlhbGl6ZWRQYXJhbXNdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICAgICAgaW1wb3J0TGlicmFyeVxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VJbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMocHJvcHMpIHtcbiAgICBjb25zdCBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgPSB1c2VNZW1vKCgpID0+IHByb3BzLmRpc2FibGVVc2FnZUF0dHJpYnV0aW9uXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IERFRkFVTFRfSU5URVJOQUxfVVNBR0VfQVRUUklCVVRJT05fSURTLCBbcHJvcHMuZGlzYWJsZVVzYWdlQXR0cmlidXRpb25dKTtcbiAgICByZXR1cm4gaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gd3JhcCB0aGUgY29tcG9uZW50cyBmcm9tIHRoaXMgbGlicmFyeSBhbmQgbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUElcbiAqL1xuY29uc3QgQVBJUHJvdmlkZXIgPSBwcm9wcyA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHMsIGxvYWRlclByb3BzID0gX19yZXN0KHByb3BzLCBbXCJjaGlsZHJlblwiXSk7XG4gICAgY29uc3QgeyBtYXBJbnN0YW5jZXMsIGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSwgY2xlYXJNYXBJbnN0YW5jZXMgfSA9IHVzZU1hcEluc3RhbmNlcygpO1xuICAgIGNvbnN0IHsgc3RhdHVzLCBsb2FkZWRMaWJyYXJpZXMsIGltcG9ydExpYnJhcnkgfSA9IHVzZUdvb2dsZU1hcHNBcGlMb2FkZXIobG9hZGVyUHJvcHMpO1xuICAgIGNvbnN0IGludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyA9IHVzZUludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyhsb2FkZXJQcm9wcyk7XG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBtYXBJbnN0YW5jZXMsXG4gICAgICAgIGFkZE1hcEluc3RhbmNlLFxuICAgICAgICByZW1vdmVNYXBJbnN0YW5jZSxcbiAgICAgICAgY2xlYXJNYXBJbnN0YW5jZXMsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9hZGVkTGlicmFyaWVzLFxuICAgICAgICBpbXBvcnRMaWJyYXJ5LFxuICAgICAgICBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHNcbiAgICB9KSwgW1xuICAgICAgICBtYXBJbnN0YW5jZXMsXG4gICAgICAgIGFkZE1hcEluc3RhbmNlLFxuICAgICAgICByZW1vdmVNYXBJbnN0YW5jZSxcbiAgICAgICAgY2xlYXJNYXBJbnN0YW5jZXMsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9hZGVkTGlicmFyaWVzLFxuICAgICAgICBpbXBvcnRMaWJyYXJ5LFxuICAgICAgICBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHNcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQVBJUHJvdmlkZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgY2hpbGRyZW4pKTtcbn07XG5cbi8qKlxuICogU2V0cyB1cCBlZmZlY3RzIHRvIGJpbmQgZXZlbnQtaGFuZGxlcnMgZm9yIGFsbCBldmVudC1wcm9wcyBpbiBNYXBFdmVudFByb3BzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEV2ZW50cyhtYXAsIHByb3BzKSB7XG4gICAgLy8gbm90ZTogY2FsbGluZyBhIHVzZUVmZmVjdCBob29rIGZyb20gd2l0aGluIGEgbG9vcCBpcyBwcm9oaWJpdGVkIGJ5IHRoZVxuICAgIC8vIHJ1bGVzIG9mIGhvb2tzLCBidXQgaXQncyBvayBoZXJlIHNpbmNlIGl0J3MgdW5jb25kaXRpb25hbCBhbmQgdGhlIG51bWJlclxuICAgIC8vIGFuZCBvcmRlciBvZiBpdGVyYXRpb25zIGlzIGFsd2F5cyBzdHJpY3RseSB0aGUgc2FtZS5cbiAgICAvLyAoc2VlIGh0dHBzOi8vbGVnYWN5LnJlYWN0anMub3JnL2RvY3MvaG9va3MtcnVsZXMuaHRtbClcbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIGV2ZW50UHJvcE5hbWVzKSB7XG4gICAgICAgIC8vIGZpeG1lOiB0aGlzIGNhc3QgaXMgZXNzZW50aWFsbHkgYSAndHJ1c3QgbWUsIGJybycgZm9yIHR5cGVzY3JpcHQsIGJ1dFxuICAgICAgICAvLyAgIGEgcHJvcGVyIHNvbHV0aW9uIHNlZW1zIHdheSB0b28gY29tcGxpY2F0ZWQgcmlnaHQgbm93XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IHByb3BOYW1lVG9FdmVudFR5cGVbcHJvcE5hbWVdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghbWFwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgZXZlbnRUeXBlLCAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGNyZWF0ZU1hcEV2ZW50KGV2ZW50VHlwZSwgbWFwLCBldikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgIH0sIFttYXAsIGV2ZW50VHlwZSwgaGFuZGxlcl0pO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIHRoZSB3cmFwcGVkIG1hcC1ldmVudHMgdXNlZCBmb3IgdGhlIGV2ZW50LXByb3BzLlxuICogQHBhcmFtIHR5cGUgdGhlIGV2ZW50IHR5cGUgYXMgaXQgaXMgc3BlY2lmaWVkIHRvIHRoZSBtYXBzIGFwaVxuICogQHBhcmFtIG1hcCB0aGUgbWFwIGluc3RhbmNlIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb21cbiAqIEBwYXJhbSBzcmNFdmVudCB0aGUgc291cmNlLWV2ZW50IGlmIHRoZXJlIGlzIG9uZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFwRXZlbnQodHlwZSwgbWFwLCBzcmNFdmVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBldiA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbWFwLFxuICAgICAgICBkZXRhaWw6IHt9LFxuICAgICAgICBzdG9wcGFibGU6IGZhbHNlLFxuICAgICAgICBzdG9wOiAoKSA9PiB7IH1cbiAgICB9O1xuICAgIGlmIChjYW1lcmFFdmVudFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGNhbUV2ZW50ID0gZXY7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gICAgICAgIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gICAgICAgIGNvbnN0IHRpbHQgPSBtYXAuZ2V0VGlsdCgpIHx8IDA7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVFdmVudF0gYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgbWFwICcgK1xuICAgICAgICAgICAgICAgICdyZXR1cm5lZCB1bmRlZmluZWQuIFRoaXMgaXMgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi4gUGxlYXNlICcgK1xuICAgICAgICAgICAgICAgICdyZXBvcnQgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2dsL3JlYWN0LWdvb2dsZS1tYXBzL2lzc3Vlcy9uZXcnKTtcbiAgICAgICAgfVxuICAgICAgICBjYW1FdmVudC5kZXRhaWwgPSB7XG4gICAgICAgICAgICBjZW50ZXI6IChjZW50ZXIgPT09IG51bGwgfHwgY2VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZW50ZXIudG9KU09OKCkpIHx8IHsgbGF0OiAwLCBsbmc6IDAgfSxcbiAgICAgICAgICAgIHpvb206IHpvb20gfHwgMCxcbiAgICAgICAgICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgICAgICAgICB0aWx0OiB0aWx0LFxuICAgICAgICAgICAgYm91bmRzOiAoYm91bmRzID09PSBudWxsIHx8IGJvdW5kcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm91bmRzLnRvSlNPTigpKSB8fCB7XG4gICAgICAgICAgICAgICAgbm9ydGg6IDkwLFxuICAgICAgICAgICAgICAgIGVhc3Q6IDE4MCxcbiAgICAgICAgICAgICAgICBzb3V0aDogLTkwLFxuICAgICAgICAgICAgICAgIHdlc3Q6IC0xODBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbUV2ZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChtb3VzZUV2ZW50VHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgaWYgKCFzcmNFdmVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW2NyZWF0ZUV2ZW50XSBtb3VzZSBldmVudHMgbXVzdCBwcm92aWRlIGEgc3JjRXZlbnQnKTtcbiAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IGV2O1xuICAgICAgICBtb3VzZUV2ZW50LmRvbUV2ZW50ID0gc3JjRXZlbnQuZG9tRXZlbnQ7XG4gICAgICAgIG1vdXNlRXZlbnQuc3RvcHBhYmxlID0gdHJ1ZTtcbiAgICAgICAgbW91c2VFdmVudC5zdG9wID0gKCkgPT4gc3JjRXZlbnQuc3RvcCgpO1xuICAgICAgICBtb3VzZUV2ZW50LmRldGFpbCA9IHtcbiAgICAgICAgICAgIGxhdExuZzogKChfYSA9IHNyY0V2ZW50LmxhdExuZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpKSB8fCBudWxsLFxuICAgICAgICAgICAgcGxhY2VJZDogc3JjRXZlbnQucGxhY2VJZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW91c2VFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGV2O1xufVxuLyoqXG4gKiBtYXBzIHRoZSBjYW1lbENhc2VkIG5hbWVzIG9mIGV2ZW50LXByb3BzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LXR5cGVzXG4gKiB1c2VkIGluIHRoZSBtYXBzIEFQSS5cbiAqL1xuY29uc3QgcHJvcE5hbWVUb0V2ZW50VHlwZSA9IHtcbiAgICBvbkJvdW5kc0NoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCcsXG4gICAgb25DZW50ZXJDaGFuZ2VkOiAnY2VudGVyX2NoYW5nZWQnLFxuICAgIG9uQ2xpY2s6ICdjbGljaycsXG4gICAgb25Db250ZXh0bWVudTogJ2NvbnRleHRtZW51JyxcbiAgICBvbkRibGNsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ2VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ3N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbkhlYWRpbmdDaGFuZ2VkOiAnaGVhZGluZ19jaGFuZ2VkJyxcbiAgICBvbklkbGU6ICdpZGxlJyxcbiAgICBvbklzRnJhY3Rpb25hbFpvb21FbmFibGVkQ2hhbmdlZDogJ2lzZnJhY3Rpb25hbHpvb21lbmFibGVkX2NoYW5nZWQnLFxuICAgIG9uTWFwQ2FwYWJpbGl0aWVzQ2hhbmdlZDogJ21hcGNhcGFiaWxpdGllc19jaGFuZ2VkJyxcbiAgICBvbk1hcFR5cGVJZENoYW5nZWQ6ICdtYXB0eXBlaWRfY2hhbmdlZCcsXG4gICAgb25Nb3VzZW1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VvdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZW92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uUHJvamVjdGlvbkNoYW5nZWQ6ICdwcm9qZWN0aW9uX2NoYW5nZWQnLFxuICAgIG9uUmVuZGVyaW5nVHlwZUNoYW5nZWQ6ICdyZW5kZXJpbmd0eXBlX2NoYW5nZWQnLFxuICAgIG9uVGlsZXNMb2FkZWQ6ICd0aWxlc2xvYWRlZCcsXG4gICAgb25UaWx0Q2hhbmdlZDogJ3RpbHRfY2hhbmdlZCcsXG4gICAgb25ab29tQ2hhbmdlZDogJ3pvb21fY2hhbmdlZCcsXG4gICAgLy8gbm90ZTogb25DYW1lcmFDaGFuZ2VkIGlzIGFuIGFsaWFzIGZvciB0aGUgYm91bmRzX2NoYW5nZWQgZXZlbnQsXG4gICAgLy8gc2luY2UgdGhhdCBpcyBnb2luZyB0byBiZSBmaXJlZCBpbiBldmVyeSBzaXR1YXRpb24gd2hlcmUgdGhlIGNhbWVyYSBpc1xuICAgIC8vIHVwZGF0ZWQuXG4gICAgb25DYW1lcmFDaGFuZ2VkOiAnYm91bmRzX2NoYW5nZWQnXG59O1xuY29uc3QgY2FtZXJhRXZlbnRUeXBlcyA9IFtcbiAgICAnYm91bmRzX2NoYW5nZWQnLFxuICAgICdjZW50ZXJfY2hhbmdlZCcsXG4gICAgJ2hlYWRpbmdfY2hhbmdlZCcsXG4gICAgJ3RpbHRfY2hhbmdlZCcsXG4gICAgJ3pvb21fY2hhbmdlZCdcbl07XG5jb25zdCBtb3VzZUV2ZW50VHlwZXMgPSBbXG4gICAgJ2NsaWNrJyxcbiAgICAnY29udGV4dG1lbnUnLFxuICAgICdkYmxjbGljaycsXG4gICAgJ21vdXNlbW92ZScsXG4gICAgJ21vdXNlb3V0JyxcbiAgICAnbW91c2VvdmVyJ1xuXTtcbmNvbnN0IGV2ZW50UHJvcE5hbWVzID0gT2JqZWN0LmtleXMocHJvcE5hbWVUb0V2ZW50VHlwZSk7XG5cbi8qKlxuICogQSBob29rIHRvIHN0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhIHZhcmlhYmxlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzdG9yZVxuICogQHJldHVybnMgVGhlIHByZXZpb3VzIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlKSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcmVmc1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gdXNlTWVtb2l6ZWQodmFsdWUsIGlzRXF1YWwpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IHVzZVByZXZpb3VzKHZhbHVlKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91cyAmJiBpc0VxdWFsKHByZXZpb3VzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgW3ZhbHVlLCBwcmV2aW91cywgaXNFcXVhbF0pO1xufVxuXG5mdW5jdGlvbiB1c2VDdXN0b21Db21wYXJlRWZmZWN0KGVmZmVjdCwgZGVwZW5kZW5jaWVzLCBpc0VxdWFsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHVzZUVmZmVjdChlZmZlY3QsIFt1c2VNZW1vaXplZChkZXBlbmRlbmNpZXMsIGlzRXF1YWwpXSk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZXBDb21wYXJlRWZmZWN0KGVmZmVjdCwgZGVwZW5kZW5jaWVzKSB7XG4gICAgdXNlQ3VzdG9tQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcGVuZGVuY2llcywgaXNEZWVwRXF1YWwpO1xufVxuXG5jb25zdCBtYXBPcHRpb25LZXlzID0gbmV3IFNldChbXG4gICAgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgJ2NsaWNrYWJsZUljb25zJyxcbiAgICAnY29udHJvbFNpemUnLFxuICAgICdkaXNhYmxlRGVmYXVsdFVJJyxcbiAgICAnZGlzYWJsZURvdWJsZUNsaWNrWm9vbScsXG4gICAgJ2RyYWdnYWJsZScsXG4gICAgJ2RyYWdnYWJsZUN1cnNvcicsXG4gICAgJ2RyYWdnaW5nQ3Vyc29yJyxcbiAgICAnZnVsbHNjcmVlbkNvbnRyb2wnLFxuICAgICdmdWxsc2NyZWVuQ29udHJvbE9wdGlvbnMnLFxuICAgICdnZXN0dXJlSGFuZGxpbmcnLFxuICAgICdoZWFkaW5nSW50ZXJhY3Rpb25FbmFibGVkJyxcbiAgICAnaXNGcmFjdGlvbmFsWm9vbUVuYWJsZWQnLFxuICAgICdrZXlib2FyZFNob3J0Y3V0cycsXG4gICAgJ21hcFR5cGVDb250cm9sJyxcbiAgICAnbWFwVHlwZUNvbnRyb2xPcHRpb25zJyxcbiAgICAnbWFwVHlwZUlkJyxcbiAgICAnbWF4Wm9vbScsXG4gICAgJ21pblpvb20nLFxuICAgICdub0NsZWFyJyxcbiAgICAncGFuQ29udHJvbCcsXG4gICAgJ3BhbkNvbnRyb2xPcHRpb25zJyxcbiAgICAncmVzdHJpY3Rpb24nLFxuICAgICdyb3RhdGVDb250cm9sJyxcbiAgICAncm90YXRlQ29udHJvbE9wdGlvbnMnLFxuICAgICdzY2FsZUNvbnRyb2wnLFxuICAgICdzY2FsZUNvbnRyb2xPcHRpb25zJyxcbiAgICAnc2Nyb2xsd2hlZWwnLFxuICAgICdzdHJlZXRWaWV3JyxcbiAgICAnc3RyZWV0Vmlld0NvbnRyb2wnLFxuICAgICdzdHJlZXRWaWV3Q29udHJvbE9wdGlvbnMnLFxuICAgICdzdHlsZXMnLFxuICAgICd0aWx0SW50ZXJhY3Rpb25FbmFibGVkJyxcbiAgICAnem9vbUNvbnRyb2wnLFxuICAgICd6b29tQ29udHJvbE9wdGlvbnMnXG5dKTtcbi8qKlxuICogSW50ZXJuYWwgaG9vayB0byB1cGRhdGUgdGhlIG1hcC1vcHRpb25zIHdoZW4gcHJvcHMgYXJlIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIG1hcCB0aGUgbWFwIGluc3RhbmNlXG4gKiBAcGFyYW0gbWFwUHJvcHMgdGhlIHByb3BzIHRvIHVwZGF0ZSB0aGUgbWFwLWluc3RhbmNlIHdpdGhcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBPcHRpb25zKG1hcCwgbWFwUHJvcHMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgLS1cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgZWZmZWN0cyBhcmVuJ3QgdHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBpcyBjaGFuZ2VkLlxuICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIHZhbHVlcyB3aWxsIGJlIG9yIGhhdmUgYmVlbiBwYXNzZWQgdG8gdGhlIG1hcFxuICAgICAqIGNvbnN0cnVjdG9yIHZpYSBtYXBPcHRpb25zLlxuICAgICAqL1xuICAgIGNvbnN0IG1hcE9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobWFwUHJvcHMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFtYXBPcHRpb25LZXlzLmhhcyhrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIG1hcE9wdGlvbnNba2V5XSA9IG1hcFByb3BzW2tleV07XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0aGUgbWFwIG9wdGlvbnMgd2hlbiBtYXBPcHRpb25zIGlzIGNoYW5nZWRcbiAgICAvLyBOb3RlOiBkdWUgdG8gdGhlIGRlc3RydWN0dXJpbmcgYWJvdmUsIG1hcE9wdGlvbnMgd2lsbCBiZSBzZWVuIGFzIGNoYW5nZWRcbiAgICAvLyAgIHdpdGggZXZlcnkgcmUtcmVuZGVyLCBzbyB3ZSdyZSBhc3N1bWluZyB0aGUgbWFwcy1hcGkgd2lsbCBwcm9wZXJseVxuICAgIC8vICAgZGVhbCB3aXRoIHVuY2hhbmdlZCBvcHRpb24tdmFsdWVzIHBhc3NlZCBpbnRvIHNldE9wdGlvbnMuXG4gICAgdXNlRGVlcENvbXBhcmVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFwLnNldE9wdGlvbnMobWFwT3B0aW9ucyk7XG4gICAgfSwgW21hcE9wdGlvbnNdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xufVxuXG5mdW5jdGlvbiB1c2VBcGlMb2FkaW5nU3RhdHVzKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cykgfHwgQVBJTG9hZGluZ1N0YXR1cy5OT1RfTE9BREVEO1xufVxuXG4vKipcbiAqIEludGVybmFsIGhvb2sgdGhhdCB1cGRhdGVzIHRoZSBjYW1lcmEgd2hlbiBkZWNrLmdsIHZpZXdTdGF0ZSBjaGFuZ2VzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZURlY2tHTENhbWVyYVVwZGF0ZShtYXAsIHByb3BzKSB7XG4gICAgY29uc3QgeyB2aWV3cG9ydCwgdmlld1N0YXRlIH0gPSBwcm9wcztcbiAgICBjb25zdCBpc0RlY2tHbENvbnRyb2xsZWQgPSAhIXZpZXdwb3J0O1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwIHx8ICF2aWV3U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYmVhcmluZzogaGVhZGluZywgcGl0Y2g6IHRpbHQsIHpvb20gfSA9IHZpZXdTdGF0ZTtcbiAgICAgICAgbWFwLm1vdmVDYW1lcmEoe1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogbGF0aXR1ZGUsIGxuZzogbG9uZ2l0dWRlIH0sXG4gICAgICAgICAgICBoZWFkaW5nLFxuICAgICAgICAgICAgdGlsdCxcbiAgICAgICAgICAgIHpvb206IHpvb20gKyAxXG4gICAgICAgIH0pO1xuICAgIH0sIFttYXAsIHZpZXdTdGF0ZV0pO1xuICAgIHJldHVybiBpc0RlY2tHbENvbnRyb2xsZWQ7XG59XG5cbmZ1bmN0aW9uIGlzTGF0TG5nTGl0ZXJhbChvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghKCdsYXQnIGluIG9iaiAmJiAnbG5nJyBpbiBvYmopKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShvYmoubGF0KSAmJiBOdW1iZXIuaXNGaW5pdGUob2JqLmxuZyk7XG59XG5mdW5jdGlvbiBsYXRMbmdFcXVhbHMoYSwgYikge1xuICAgIGlmICghYSB8fCAhYilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IEEgPSB0b0xhdExuZ0xpdGVyYWwoYSk7XG4gICAgY29uc3QgQiA9IHRvTGF0TG5nTGl0ZXJhbChiKTtcbiAgICBpZiAoQS5sYXQgIT09IEIubGF0IHx8IEEubG5nICE9PSBCLmxuZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9MYXRMbmdMaXRlcmFsKG9iaikge1xuICAgIGlmIChpc0xhdExuZ0xpdGVyYWwob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xufVxuXG5mdW5jdGlvbiB1c2VNYXBDYW1lcmFQYXJhbXMobWFwLCBjYW1lcmFTdGF0ZVJlZiwgbWFwUHJvcHMpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBtYXBQcm9wcy5jZW50ZXIgPyB0b0xhdExuZ0xpdGVyYWwobWFwUHJvcHMuY2VudGVyKSA6IG51bGw7XG4gICAgbGV0IGxhdCA9IG51bGw7XG4gICAgbGV0IGxuZyA9IG51bGw7XG4gICAgaWYgKGNlbnRlciAmJiBOdW1iZXIuaXNGaW5pdGUoY2VudGVyLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sbmcpKSB7XG4gICAgICAgIGxhdCA9IGNlbnRlci5sYXQ7XG4gICAgICAgIGxuZyA9IGNlbnRlci5sbmc7XG4gICAgfVxuICAgIGNvbnN0IHpvb20gPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMuem9vbSlcbiAgICAgICAgPyBtYXBQcm9wcy56b29tXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBoZWFkaW5nID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLmhlYWRpbmcpXG4gICAgICAgID8gbWFwUHJvcHMuaGVhZGluZ1xuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgdGlsdCA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy50aWx0KVxuICAgICAgICA/IG1hcFByb3BzLnRpbHRcbiAgICAgICAgOiBudWxsO1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgZWZmZWN0IHJ1bnMgZm9yIGV2ZXJ5IHJlbmRlciBvZiB0aGUgbWFwIGNvbXBvbmVudCBhbmQgY2hlY2tzXG4gICAgLy8gaWYgdGhlcmUgYXJlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIGtub3duIHN0YXRlIG9mIHRoZSBtYXAgaW5zdGFuY2VcbiAgICAvLyAoY2FtZXJhU3RhdGVSZWYsIHdoaWNoIGlzIHVwZGF0ZWQgYnkgYWxsIGJvdW5kc19jaGFuZ2VkIGV2ZW50cykgYW5kIHRoZVxuICAgIC8vIGRlc2lyZWQgc3RhdGUgaW4gdGhlIHByb3BzLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXh0Q2FtZXJhID0ge307XG4gICAgICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAobGF0ICE9PSBudWxsICYmXG4gICAgICAgICAgICBsbmcgIT09IG51bGwgJiZcbiAgICAgICAgICAgIChjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmNlbnRlci5sYXQgIT09IGxhdCB8fFxuICAgICAgICAgICAgICAgIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuY2VudGVyLmxuZyAhPT0gbG5nKSkge1xuICAgICAgICAgICAgbmV4dENhbWVyYS5jZW50ZXIgPSB7IGxhdCwgbG5nIH07XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvb20gIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC56b29tICE9PSB6b29tKSB7XG4gICAgICAgICAgICBuZXh0Q2FtZXJhLnpvb20gPSB6b29tO1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkaW5nICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuaGVhZGluZyAhPT0gaGVhZGluZykge1xuICAgICAgICAgICAgbmV4dENhbWVyYS5oZWFkaW5nID0gaGVhZGluZztcbiAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGlsdCAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LnRpbHQgIT09IHRpbHQpIHtcbiAgICAgICAgICAgIG5leHRDYW1lcmEudGlsdCA9IHRpbHQ7XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICBtYXAubW92ZUNhbWVyYShuZXh0Q2FtZXJhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5jb25zdCBBdXRoRmFpbHVyZU1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHpJbmRleDogOTk5LFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhGbG93OiAnY29sdW1uIG5vd3JhcCcsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgZm9udFNpemU6ICcuOHJlbScsXG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjYpJyxcbiAgICAgICAgYmFja2dyb3VuZDogJyNkZGRkZGQnLFxuICAgICAgICBwYWRkaW5nOiAnMXJlbSAxLjVyZW0nXG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogc3R5bGUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgyXCIsIG51bGwsIFwiRXJyb3I6IEF1dGhGYWlsdXJlXCIpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLFxuICAgICAgICAgICAgXCJBIHByb2JsZW0gd2l0aCB5b3VyIEFQSSBrZXkgcHJldmVudHMgdGhlIG1hcCBmcm9tIHJlbmRlcmluZyBjb3JyZWN0bHkuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHZhbHVlIG9mIHRoZSBcIixcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIG51bGwsIFwiQVBJUHJvdmlkZXIuYXBpS2V5XCIpLFxuICAgICAgICAgICAgXCIgcHJvcCBpcyBjb3JyZWN0LiBDaGVjayB0aGUgZXJyb3ItbWVzc2FnZSBpbiB0aGUgY29uc29sZSBmb3IgZnVydGhlciBkZXRhaWxzLlwiKSkpO1xufTtcblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoKSB7XG4gICAgY29uc3QgW2VsLCBzZXRFbF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCByZWYgPSB1c2VDYWxsYmFjaygodmFsdWUpID0+IHNldEVsKHZhbHVlKSwgW3NldEVsXSk7XG4gICAgcmV0dXJuIFtlbCwgcmVmXTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGNoZWNrIGlmIHRoZSBNYXBzIEphdmFTY3JpcHQgQVBJIGlzIGxvYWRlZFxuICovXG5mdW5jdGlvbiB1c2VBcGlJc0xvYWRlZCgpIHtcbiAgICBjb25zdCBzdGF0dXMgPSB1c2VBcGlMb2FkaW5nU3RhdHVzKCk7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gQVBJTG9hZGluZ1N0YXR1cy5MT0FERUQ7XG59XG5cbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoeCA9PiB4ICsgMSwgMCk7XG4gICAgcmV0dXJuIGZvcmNlVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVCb3VuZHNDaGFuZ2UobWFwLCByZWYpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gICAgY29uc3QgaGVhZGluZyA9IG1hcC5nZXRIZWFkaW5nKCkgfHwgMDtcbiAgICBjb25zdCB0aWx0ID0gbWFwLmdldFRpbHQoKSB8fCAwO1xuICAgIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICBpZiAoIWNlbnRlciB8fCAhYm91bmRzIHx8ICFOdW1iZXIuaXNGaW5pdGUoem9vbSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdXNlVHJhY2tlZENhbWVyYVN0YXRlXSBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBtYXAgJyArXG4gICAgICAgICAgICAncmV0dXJuZWQgdW5kZWZpbmVkLiBUaGlzIGlzIG5vdCBleHBlY3RlZCB0byBoYXBwZW4uIFBsZWFzZSAnICtcbiAgICAgICAgICAgICdyZXBvcnQgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2dsL3JlYWN0LWdvb2dsZS1tYXBzL2lzc3Vlcy9uZXcnKTtcbiAgICB9XG4gICAgLy8gZml4bWU6IGRvIHdlIG5lZWQgdGhlIGB1bmRlZmluZWRgIGNhc2VzIGZvciB0aGUgY2FtZXJhLXBhcmFtcz8gV2hlbiBhcmUgdGhleSB1c2VkIGluIHRoZSBtYXBzIEFQST9cbiAgICBPYmplY3QuYXNzaWduKHJlZi5jdXJyZW50LCB7XG4gICAgICAgIGNlbnRlcjogKGNlbnRlciA9PT0gbnVsbCB8fCBjZW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbnRlci50b0pTT04oKSkgfHwgeyBsYXQ6IDAsIGxuZzogMCB9LFxuICAgICAgICB6b29tOiB6b29tIHx8IDAsXG4gICAgICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgICAgIHRpbHQ6IHRpbHRcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG11dGFibGUgcmVmIG9iamVjdCB0byB0cmFjayB0aGUgbGFzdCBrbm93biBzdGF0ZSBvZiB0aGUgbWFwIGNhbWVyYS5cbiAqIFRoaXMgaXMgdXNlZCBpbiBgdXNlTWFwQ2FtZXJhUGFyYW1zYCB0byByZWR1Y2Ugc3R1dHRlcmluZyBpbiBub3JtYWwgb3BlcmF0aW9uXG4gKiBieSBhdm9pZGluZyB1cGRhdGVzIG9mIHRoZSBtYXAgY2FtZXJhIHdpdGggdmFsdWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkLlxuICovXG5mdW5jdGlvbiB1c2VUcmFja2VkQ2FtZXJhU3RhdGVSZWYobWFwKSB7XG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZih7XG4gICAgICAgIGNlbnRlcjogeyBsYXQ6IDAsIGxuZzogMCB9LFxuICAgICAgICBoZWFkaW5nOiAwLFxuICAgICAgICB0aWx0OiAwLFxuICAgICAgICB6b29tOiAwXG4gICAgfSk7XG4gICAgLy8gUmVjb3JkIGNhbWVyYSBzdGF0ZSB3aXRoIGV2ZXJ5IGJvdW5kc19jaGFuZ2VkIGV2ZW50IGRpc3BhdGNoZWQgYnkgdGhlIG1hcC5cbiAgICAvLyBUaGlzIGRhdGEgaXMgdXNlZCB0byBwcmV2ZW50IGZlZWRpbmcgdGhlc2UgdmFsdWVzIGJhY2sgdG8gdGhlXG4gICAgLy8gbWFwLWluc3RhbmNlIHdoZW4gYSB0eXBpY2FsIFwiY29udHJvbGxlZCBjb21wb25lbnRcIiBzZXR1cCAoc3RhdGUgdmFyaWFibGUgaXNcbiAgICAvLyBmZWQgaW50byBhbmQgdXBkYXRlZCBieSB0aGUgbWFwKS5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdib3VuZHNfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZUJvdW5kc0NoYW5nZShtYXAsIHJlZik7XG4gICAgICAgICAgICAvLyBXaGVuIGFuIGV2ZW50IGlzIG9jY3VyZWQsIHdlIGhhdmUgdG8gdXBkYXRlIGR1cmluZyB0aGUgbmV4dCBjeWNsZS5cbiAgICAgICAgICAgIC8vIFRoZSBhcHBsaWNhdGlvbiBjb3VsZCBkZWNpZGUgdG8gaWdub3JlIHRoZSBldmVudCBhbmQgbm90IHVwZGF0ZSBhbnlcbiAgICAgICAgICAgIC8vIGNhbWVyYSBwcm9wcyBvZiB0aGUgbWFwLCBtZWFuaW5nIHRoYXQgaW4gdGhhdCBjYXNlIHdlIHdpbGwgaGF2ZSB0b1xuICAgICAgICAgICAgLy8gJ3VuZG8nIHRoZSBjaGFuZ2UgdG8gdGhlIGNhbWVyYS5cbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW21hcCwgZm9yY2VVcGRhdGVdKTtcbiAgICByZXR1cm4gcmVmO1xufVxuXG4vKipcbiAqIFN0b3JlcyBhIHN0YWNrIG9mIG1hcC1pbnN0YW5jZXMgZm9yIGVhY2ggbWFwSWQuIFdoZW5ldmVyIGFuXG4gKiBpbnN0YW5jZSBpcyB1c2VkLCBpdCBpcyByZW1vdmVkIGZyb20gdGhlIHN0YWNrIHdoaWxlIGluIHVzZSxcbiAqIGFuZCByZXR1cm5lZCB0byB0aGUgc3RhY2sgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzLlxuICogVGhpcyBhbGxvd3MgdXMgdG8gY29ycmVjdGx5IGltcGxlbWVudCBjYWNoaW5nIGZvciBtdWx0aXBsZVxuICogbWFwcyBvbSB0aGUgc2FtZSBwYWdlLCB3aGlsZSByZXVzaW5nIGFzIG11Y2ggYXMgcG9zc2libGUuXG4gKlxuICogRklYTUU6IHdoaWxlIGl0IHNob3VsZCBpbiB0aGVvcnkgYmUgcG9zc2libGUgdG8gcmV1c2UgbWFwcyBzb2xlbHlcbiAqICAgYmFzZWQgb24gdGhlIG1hcElkIChhcyBhbGwgb3RoZXIgcGFyYW1ldGVycyBjYW4gYmUgY2hhbmdlZCBhdFxuICogICBydW50aW1lKSwgd2UgZG9uJ3QgeWV0IGhhdmUgZ29vZCBlbm91Z2ggdHJhY2tpbmcgb2Ygb3B0aW9ucyB0b1xuICogICByZWxpYWJseSB1bnNldCBhbGwgdGhlIG9wdGlvbnMgdGhhdCBoYXZlIGJlZW4gc2V0LlxuICovXG5jbGFzcyBDYWNoZWRNYXBTdGFjayB7XG4gICAgc3RhdGljIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1trZXldICYmIHRoaXMuZW50cmllc1trZXldLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIHN0YXRpYyBwb3Aoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyaWVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1trZXldLnBvcCgpIHx8IG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBwdXNoKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVudHJpZXNba2V5XSlcbiAgICAgICAgICAgIHRoaXMuZW50cmllc1trZXldID0gW107XG4gICAgICAgIHRoaXMuZW50cmllc1trZXldLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbkNhY2hlZE1hcFN0YWNrLmVudHJpZXMgPSB7fTtcbi8qKlxuICogVGhlIG1haW4gaG9vayB0YWtlcyBjYXJlIG9mIGNyZWF0aW5nIG1hcC1pbnN0YW5jZXMgYW5kIHJlZ2lzdGVyaW5nIHRoZW0gaW5cbiAqIHRoZSBhcGktcHJvdmlkZXIgY29udGV4dC5cbiAqIEByZXR1cm4gYSB0dXBsZSBvZiB0aGUgbWFwLWluc3RhbmNlIGNyZWF0ZWQgKG9yIG51bGwpIGFuZCB0aGUgY2FsbGJhY2tcbiAqICAgcmVmIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBhc3MgdGhlIG1hcC1jb250YWluZXIgaW50byB0aGlzIGhvb2suXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwSW5zdGFuY2UocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBhcGlJc0xvYWRlZCA9IHVzZUFwaUlzTG9hZGVkKCk7XG4gICAgY29uc3QgW21hcCwgc2V0TWFwXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtjb250YWluZXIsIGNvbnRhaW5lclJlZl0gPSB1c2VDYWxsYmFja1JlZigpO1xuICAgIGNvbnN0IGNhbWVyYVN0YXRlUmVmID0gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCk7XG4gICAgY29uc3QgeyBpZCwgZGVmYXVsdEJvdW5kcywgZGVmYXVsdENlbnRlciwgZGVmYXVsdFpvb20sIGRlZmF1bHRIZWFkaW5nLCBkZWZhdWx0VGlsdCwgcmV1c2VNYXBzLCByZW5kZXJpbmdUeXBlLCBjb2xvclNjaGVtZSB9ID0gcHJvcHMsIG1hcE9wdGlvbnMgPSBfX3Jlc3QocHJvcHMsIFtcImlkXCIsIFwiZGVmYXVsdEJvdW5kc1wiLCBcImRlZmF1bHRDZW50ZXJcIiwgXCJkZWZhdWx0Wm9vbVwiLCBcImRlZmF1bHRIZWFkaW5nXCIsIFwiZGVmYXVsdFRpbHRcIiwgXCJyZXVzZU1hcHNcIiwgXCJyZW5kZXJpbmdUeXBlXCIsIFwiY29sb3JTY2hlbWVcIl0pO1xuICAgIGNvbnN0IGhhc1pvb20gPSBwcm9wcy56b29tICE9PSB1bmRlZmluZWQgfHwgcHJvcHMuZGVmYXVsdFpvb20gIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBoYXNDZW50ZXIgPSBwcm9wcy5jZW50ZXIgIT09IHVuZGVmaW5lZCB8fCBwcm9wcy5kZWZhdWx0Q2VudGVyICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFkZWZhdWx0Qm91bmRzICYmICghaGFzWm9vbSB8fCAhaGFzQ2VudGVyKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJzxNYXA+IGNvbXBvbmVudCBpcyBtaXNzaW5nIGNvbmZpZ3VyYXRpb24uICcgK1xuICAgICAgICAgICAgJ1lvdSBoYXZlIHRvIHByb3ZpZGUgem9vbSBhbmQgY2VudGVyICh2aWEgdGhlIGB6b29tYC9gZGVmYXVsdFpvb21gIGFuZCAnICtcbiAgICAgICAgICAgICdgY2VudGVyYC9gZGVmYXVsdENlbnRlcmAgcHJvcHMpIG9yIHNwZWNpZnkgdGhlIHJlZ2lvbiB0byBzaG93IHVzaW5nICcgK1xuICAgICAgICAgICAgJ2BkZWZhdWx0Qm91bmRzYC4gU2VlICcgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vdmlzZ2wuZ2l0aHViLmlvL3JlYWN0LWdvb2dsZS1tYXBzL2RvY3MvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL21hcCNyZXF1aXJlZCcpO1xuICAgIH1cbiAgICAvLyBhcHBseSBkZWZhdWx0IGNhbWVyYSBwcm9wcyBpZiBhdmFpbGFibGUgYW5kIG5vdCBvdmVyd3JpdHRlbiBieSBjb250cm9sbGVkIHByb3BzXG4gICAgaWYgKCFtYXBPcHRpb25zLmNlbnRlciAmJiBkZWZhdWx0Q2VudGVyKVxuICAgICAgICBtYXBPcHRpb25zLmNlbnRlciA9IGRlZmF1bHRDZW50ZXI7XG4gICAgaWYgKCFtYXBPcHRpb25zLnpvb20gJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRab29tKSlcbiAgICAgICAgbWFwT3B0aW9ucy56b29tID0gZGVmYXVsdFpvb207XG4gICAgaWYgKCFtYXBPcHRpb25zLmhlYWRpbmcgJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRIZWFkaW5nKSlcbiAgICAgICAgbWFwT3B0aW9ucy5oZWFkaW5nID0gZGVmYXVsdEhlYWRpbmc7XG4gICAgaWYgKCFtYXBPcHRpb25zLnRpbHQgJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRUaWx0KSlcbiAgICAgICAgbWFwT3B0aW9ucy50aWx0ID0gZGVmYXVsdFRpbHQ7XG4gICAgLy8gSGFuZGxlIGludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkc1xuICAgIGNvbnN0IGN1c3RvbUlkcyA9IG1hcE9wdGlvbnMuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzO1xuICAgIGlmIChjdXN0b21JZHMgPT0gbnVsbCkge1xuICAgICAgICAvLyBOb3Qgc3BlY2lmaWVkIC0gdXNlIGNvbnRleHQgZGVmYXVsdCAod2hpY2ggbWF5IGJlIG51bGwgaWYgZGlzYWJsZWQpXG4gICAgICAgIG1hcE9wdGlvbnMuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzID1cbiAgICAgICAgICAgIGNvbnRleHQuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTWVyZ2UgY29udGV4dCBkZWZhdWx0cyB3aXRoIGN1c3RvbSBJRHNcbiAgICAgICAgbWFwT3B0aW9ucy5pbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgPSBbXG4gICAgICAgICAgICAuLi4oY29udGV4dC5pbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgfHwgW10pLFxuICAgICAgICAgICAgLi4uY3VzdG9tSWRzXG4gICAgICAgIF07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1hcE9wdGlvbnMpKVxuICAgICAgICBpZiAobWFwT3B0aW9uc1trZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkZWxldGUgbWFwT3B0aW9uc1trZXldO1xuICAgIGNvbnN0IHNhdmVkTWFwU3RhdGVSZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgICAvLyBjcmVhdGUgdGhlIG1hcCBpbnN0YW5jZSBhbmQgcmVnaXN0ZXIgaXQgaW4gdGhlIGNvbnRleHRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhYXBpSXNMb2FkZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYWRkTWFwSW5zdGFuY2UsIHJlbW92ZU1hcEluc3RhbmNlIH0gPSBjb250ZXh0O1xuICAgICAgICAvLyBub3RlOiBjb2xvclNjaGVtZSAodXBjb21pbmcgZmVhdHVyZSkgaXNuJ3QgeWV0IGluIHRoZSB0eXBpbmdzLCByZW1vdmUgb25jZSB0aGF0IGlzIGZpeGVkOlxuICAgICAgICBjb25zdCB7IG1hcElkIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHttYXBJZCB8fCAnZGVmYXVsdCd9OiR7cmVuZGVyaW5nVHlwZSB8fCAnZGVmYXVsdCd9OiR7Y29sb3JTY2hlbWUgfHwgJ0xJR0hUJ31gO1xuICAgICAgICBsZXQgbWFwRGl2O1xuICAgICAgICBsZXQgbWFwO1xuICAgICAgICBpZiAocmV1c2VNYXBzICYmIENhY2hlZE1hcFN0YWNrLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgICAgIG1hcCA9IENhY2hlZE1hcFN0YWNrLnBvcChjYWNoZUtleSk7XG4gICAgICAgICAgICBtYXBEaXYgPSBtYXAuZ2V0RGl2KCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobWFwRGl2KTtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKG1hcE9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gZGV0YWNoaW5nIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTSBsZXRzIHRoZSBtYXAgZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0XG4gICAgICAgICAgICAvLyBzaXplLCBzZXR0aW5nIHRoZSBjZW50ZXIgd2lsbCB0cmlnZ2VyIHJlbG9hZGluZyB0aGUgbWFwLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBtYXAuc2V0Q2VudGVyKG1hcC5nZXRDZW50ZXIoKSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFwRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBtYXBEaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcERpdik7XG4gICAgICAgICAgICBtYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKG1hcERpdiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1hcE9wdGlvbnMpLCAocmVuZGVyaW5nVHlwZVxuICAgICAgICAgICAgICAgID8geyByZW5kZXJpbmdUeXBlOiByZW5kZXJpbmdUeXBlIH1cbiAgICAgICAgICAgICAgICA6IHt9KSksIChjb2xvclNjaGVtZVxuICAgICAgICAgICAgICAgID8geyBjb2xvclNjaGVtZTogY29sb3JTY2hlbWUgfVxuICAgICAgICAgICAgICAgIDoge30pKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TWFwKG1hcCk7XG4gICAgICAgIGFkZE1hcEluc3RhbmNlKG1hcCwgaWQpO1xuICAgICAgICBpZiAoZGVmYXVsdEJvdW5kcykge1xuICAgICAgICAgICAgY29uc3QgeyBwYWRkaW5nIH0gPSBkZWZhdWx0Qm91bmRzLCBkZWZCb3VuZHMgPSBfX3Jlc3QoZGVmYXVsdEJvdW5kcywgW1wicGFkZGluZ1wiXSk7XG4gICAgICAgICAgICBtYXAuZml0Qm91bmRzKGRlZkJvdW5kcywgcGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBtYXAgbm90IHJlbmRlcmluZyBkdWUgdG8gbWlzc2luZyBjb25maWd1cmF0aW9uXG4gICAgICAgIGVsc2UgaWYgKCFoYXNab29tIHx8ICFoYXNDZW50ZXIpIHtcbiAgICAgICAgICAgIG1hcC5maXRCb3VuZHMoeyBlYXN0OiAxODAsIHdlc3Q6IC0xODAsIHNvdXRoOiAtOTAsIG5vcnRoOiA5MCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgc2F2ZWRNYXBTdGF0ZSBpcyB1c2VkIHRvIHJlc3RvcmUgdGhlIGNhbWVyYSBwYXJhbWV0ZXJzIHdoZW4gdGhlIG1hcElkIGlzIGNoYW5nZWRcbiAgICAgICAgaWYgKHNhdmVkTWFwU3RhdGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBtYXBJZDogc2F2ZWRNYXBJZCwgY2FtZXJhU3RhdGU6IHNhdmVkQ2FtZXJhU3RhdGUgfSA9IHNhdmVkTWFwU3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChzYXZlZE1hcElkICE9PSBtYXBJZCkge1xuICAgICAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHNhdmVkQ2FtZXJhU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbWFwSWQsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICAgICAgICAgIGNhbWVyYVN0YXRlOiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZGV0YWNoIHRoZSBtYXAtZGl2IGZyb20gdGhlIGRvbVxuICAgICAgICAgICAgbWFwRGl2LnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKHJldXNlTWFwcykge1xuICAgICAgICAgICAgICAgIC8vIHB1c2ggYmFjayBvbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICBDYWNoZWRNYXBTdGFjay5wdXNoKGNhY2hlS2V5LCBtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudC1saXN0ZW5lcnMgdG8gbWluaW1pemUgdGhlIHBvc3NpYmlsaXR5IG9mIG1lbW9yeS1sZWFrc1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFySW5zdGFuY2VMaXN0ZW5lcnMobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1hcChudWxsKTtcbiAgICAgICAgICAgIHJlbW92ZU1hcEluc3RhbmNlKGlkKTtcbiAgICAgICAgfTtcbiAgICB9LCBcbiAgICAvLyBzb21lIGRlcGVuZGVuY2llcyBhcmUgaWdub3JlZCBpbiB0aGUgbGlzdCBiZWxvdzpcbiAgICAvLyAgLSBkZWZhdWx0Qm91bmRzIGFuZCB0aGUgZGVmYXVsdCogY2FtZXJhIHByb3BzIHdpbGwgb25seSBiZSB1c2VkIG9uY2UsIGFuZFxuICAgIC8vICAgIGNoYW5nZXMgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICAvLyAgLSBtYXBPcHRpb25zIGhhcyBzcGVjaWFsIGhvb2tzIHRoYXQgdGFrZSBjYXJlIG9mIHVwZGF0aW5nIHRoZSBvcHRpb25zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhcGlJc0xvYWRlZCxcbiAgICAgICAgaWQsXG4gICAgICAgIC8vIHRoZXNlIHByb3BzIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYW5kIHJlcXVpcmUgYSBuZXdcbiAgICAgICAgLy8gaW5zdGFuY2UgdG8gYmUgY3JlYXRlZFxuICAgICAgICBwcm9wcy5tYXBJZCxcbiAgICAgICAgcHJvcHMucmVuZGVyaW5nVHlwZSxcbiAgICAgICAgcHJvcHMuY29sb3JTY2hlbWVcbiAgICBdKTtcbiAgICByZXR1cm4gW21hcCwgY29udGFpbmVyUmVmLCBjYW1lcmFTdGF0ZVJlZl07XG59XG5cbmNvbnN0IEdvb2dsZU1hcHNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8vIENvbG9yU2NoZW1lIGFuZCBSZW5kZXJpbmdUeXBlIGFyZSByZWRlZmluZWQgaGVyZSB0byBtYWtlIHRoZW0gdXNhYmxlIGJlZm9yZSB0aGVcbi8vIG1hcHMgQVBJIGhhcyBiZWVuIGZ1bGx5IGxvYWRlZC5cbmNvbnN0IENvbG9yU2NoZW1lID0ge1xuICAgIERBUks6ICdEQVJLJyxcbiAgICBMSUdIVDogJ0xJR0hUJyxcbiAgICBGT0xMT1dfU1lTVEVNOiAnRk9MTE9XX1NZU1RFTSdcbn07XG5jb25zdCBSZW5kZXJpbmdUeXBlID0ge1xuICAgIFZFQ1RPUjogJ1ZFQ1RPUicsXG4gICAgUkFTVEVSOiAnUkFTVEVSJyxcbiAgICBVTklOSVRJQUxJWkVEOiAnVU5JTklUSUFMSVpFRCdcbn07XG5jb25zdCBNYXAgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBpZCwgY2xhc3NOYW1lLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgICBjb25zdCBsb2FkaW5nU3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxNYXA+IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIDxBcGlQcm92aWRlcj4gY29tcG9uZW50LicpO1xuICAgIH1cbiAgICBjb25zdCBbbWFwLCBtYXBSZWYsIGNhbWVyYVN0YXRlUmVmXSA9IHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KTtcbiAgICB1c2VNYXBDYW1lcmFQYXJhbXMobWFwLCBjYW1lcmFTdGF0ZVJlZiwgcHJvcHMpO1xuICAgIHVzZU1hcEV2ZW50cyhtYXAsIHByb3BzKTtcbiAgICB1c2VNYXBPcHRpb25zKG1hcCwgcHJvcHMpO1xuICAgIGNvbnN0IGlzRGVja0dsQ29udHJvbGxlZCA9IHVzZURlY2tHTENhbWVyYVVwZGF0ZShtYXAsIHByb3BzKTtcbiAgICBjb25zdCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5ID0gISFwcm9wcy5jb250cm9sbGVkO1xuICAgIC8vIGRpc2FibGUgaW50ZXJhY3Rpb25zIHdpdGggdGhlIG1hcCBmb3IgZXh0ZXJuYWxseSBjb250cm9sbGVkIG1hcHNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gZml4bWU6IHRoaXMgZG9lc24ndCBzZWVtIHRvIGJlbG9uZyBoZXJlIChhbmQgaXQncyBtb3N0bHkgdGhlcmUgZm9yIGNvbnZlbmllbmNlIGFueXdheSkuXG4gICAgICAgIC8vICAgVGhlIHJlYXNvbmluZyBpcyB0aGF0IGEgZGVjay5nbCBjYW52YXMgd2lsbCBiZSBwdXQgb24gdG9wIG9mIHRoZSBtYXAsIHJlbmRlcmluZ1xuICAgICAgICAvLyAgIGFueSBkZWZhdWx0IG1hcCBjb250cm9scyBwcmV0dHkgbXVjaCB1c2VsZXNzXG4gICAgICAgIGlmIChpc0RlY2tHbENvbnRyb2xsZWQpIHtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHsgZGlzYWJsZURlZmF1bHRVSTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXNhYmxlIGFsbCBjb250cm9sLWlucHV0cyB3aGVuIHRoZSBtYXAgaXMgY29udHJvbGxlZCBleHRlcm5hbGx5XG4gICAgICAgIGlmIChpc0RlY2tHbENvbnRyb2xsZWQgfHwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSkge1xuICAgICAgICAgICAgbWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGdlc3R1cmVIYW5kbGluZzogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGtleWJvYXJkU2hvcnRjdXRzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlSGFuZGxpbmc6IHByb3BzLmdlc3R1cmVIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBrZXlib2FyZFNob3J0Y3V0czogcHJvcHMua2V5Ym9hcmRTaG9ydGN1dHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgbWFwLFxuICAgICAgICBpc0RlY2tHbENvbnRyb2xsZWQsXG4gICAgICAgIGlzQ29udHJvbGxlZEV4dGVybmFsbHksXG4gICAgICAgIHByb3BzLmdlc3R1cmVIYW5kbGluZyxcbiAgICAgICAgcHJvcHMua2V5Ym9hcmRTaG9ydGN1dHNcbiAgICBdKTtcbiAgICAvLyBzZXR1cCBhIHN0YWJsZSBjYW1lcmFPcHRpb25zIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGRlcGVuZGVuY3lcbiAgICBjb25zdCBjZW50ZXIgPSBwcm9wcy5jZW50ZXIgPyB0b0xhdExuZ0xpdGVyYWwocHJvcHMuY2VudGVyKSA6IG51bGw7XG4gICAgbGV0IGxhdCA9IG51bGw7XG4gICAgbGV0IGxuZyA9IG51bGw7XG4gICAgaWYgKGNlbnRlciAmJiBOdW1iZXIuaXNGaW5pdGUoY2VudGVyLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sbmcpKSB7XG4gICAgICAgIGxhdCA9IGNlbnRlci5sYXQ7XG4gICAgICAgIGxuZyA9IGNlbnRlci5sbmc7XG4gICAgfVxuICAgIGNvbnN0IGNhbWVyYU9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZW50ZXI6IHsgbGF0OiBsYXQgIT09IG51bGwgJiYgbGF0ICE9PSB2b2lkIDAgPyBsYXQgOiAwLCBsbmc6IGxuZyAhPT0gbnVsbCAmJiBsbmcgIT09IHZvaWQgMCA/IGxuZyA6IDAgfSxcbiAgICAgICAgICAgIHpvb206IChfYSA9IHByb3BzLnpvb20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXG4gICAgICAgICAgICBoZWFkaW5nOiAoX2IgPSBwcm9wcy5oZWFkaW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwLFxuICAgICAgICAgICAgdGlsdDogKF9jID0gcHJvcHMudGlsdCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMFxuICAgICAgICB9O1xuICAgIH0sIFtsYXQsIGxuZywgcHJvcHMuem9vbSwgcHJvcHMuaGVhZGluZywgcHJvcHMudGlsdF0pO1xuICAgIC8vIGV4dGVybmFsbHkgY29udHJvbGxlZCBtb2RlOiByZWplY3QgYWxsIGNhbWVyYSBjaGFuZ2VzIHRoYXQgZG9uJ3QgY29ycmVzcG9uZCB0byBjaGFuZ2VzIGluIHByb3BzXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXAgfHwgIWlzQ29udHJvbGxlZEV4dGVybmFsbHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hcC5tb3ZlQ2FtZXJhKGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IG1hcC5hZGRMaXN0ZW5lcignYm91bmRzX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBtYXAubW92ZUNhbWVyYShjYW1lcmFPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB9LCBbbWFwLCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5LCBjYW1lcmFPcHRpb25zXSk7XG4gICAgY29uc3QgY29tYmluZWRTdHlsZSA9IHVzZU1lbW8oKCkgPT4gKE9iamVjdC5hc3NpZ24oeyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIFxuICAgICAgICAvLyB3aGVuIHVzaW5nIGRlY2tnbCwgdGhlIG1hcCBzaG91bGQgYmUgc2VudCB0byB0aGUgYmFja1xuICAgICAgICB6SW5kZXg6IGlzRGVja0dsQ29udHJvbGxlZCA/IC0xIDogMCB9LCBzdHlsZSkpLCBbc3R5bGUsIGlzRGVja0dsQ29udHJvbGxlZF0pO1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgbWFwIH0pLCBbbWFwXSk7XG4gICAgaWYgKGxvYWRpbmdTdGF0dXMgPT09IEFQSUxvYWRpbmdTdGF0dXMuQVVUSF9GQUlMVVJFKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSwgKGNsYXNzTmFtZSA/IHt9IDogY29tYmluZWRTdHlsZSkpLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBdXRoRmFpbHVyZU1lc3NhZ2UsIG51bGwpKSk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiBtYXBSZWYsIFwiZGF0YS10ZXN0aWRcIjogJ21hcCcsIHN0eWxlOiBjbGFzc05hbWUgPyB1bmRlZmluZWQgOiBjb21iaW5lZFN0eWxlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCAoaWQgPyB7IGlkIH0gOiB7fSkpLCBtYXAgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChHb29nbGVNYXBzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKSkgOiBudWxsKSk7XG59O1xuLy8gVGhlIGRlY2tHTFZpZXdQcm9wcyBmbGFnIGhlcmUgaW5kaWNhdGVzIHRvIGRlY2suZ2wgdGhhdCB0aGUgTWFwIGNvbXBvbmVudCBpc1xuLy8gYWJsZSB0byBoYW5kbGUgdmlld1Byb3BzIGZyb20gZGVjay5nbCB3aGVuIGRlY2suZ2wgaXMgdXNlZCB0byBjb250cm9sIHRoZSBtYXAuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuTWFwLmRlY2tHTFZpZXdQcm9wcyA9IHRydWU7XG5cbmNvbnN0IHNob3duTWVzc2FnZXMgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBsb2dFcnJvck9uY2UoLi4uYXJncykge1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICAgIGlmICghc2hvd25NZXNzYWdlcy5oYXMoa2V5KSkge1xuICAgICAgICBzaG93bk1lc3NhZ2VzLmFkZChrZXkpO1xuICAgICAgICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBtYXAtaW5zdGFuY2UgZnJvbSB0aGUgY29udGV4dC4gVGhpcyBpcyBlaXRoZXIgYW4gaW5zdGFuY2VcbiAqIGlkZW50aWZpZWQgYnkgaWQgb3IgdGhlIHBhcmVudCBtYXAgaW5zdGFuY2UgaWYgbm8gaWQgaXMgc3BlY2lmaWVkLlxuICogUmV0dXJucyBudWxsIGlmIG5laXRoZXIgY2FuIGJlIGZvdW5kLlxuICovXG5jb25zdCB1c2VNYXAgPSAoaWQgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpO1xuICAgIGNvbnN0IHsgbWFwIH0gPSB1c2VDb250ZXh0KEdvb2dsZU1hcHNDb250ZXh0KSB8fCB7fTtcbiAgICBpZiAoY3R4ID09PSBudWxsKSB7XG4gICAgICAgIGxvZ0Vycm9yT25jZSgndXNlTWFwKCk6IGZhaWxlZCB0byByZXRyaWV2ZSBBUElQcm92aWRlckNvbnRleHQuICcgK1xuICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGF0IHRoZSA8QVBJUHJvdmlkZXI+IGNvbXBvbmVudCBleGlzdHMgYW5kIHRoYXQgdGhlICcgK1xuICAgICAgICAgICAgJ2NvbXBvbmVudCB5b3UgYXJlIGNhbGxpbmcgYHVzZU1hcCgpYCBmcm9tIGlzIGEgc2libGluZyBvZiB0aGUgJyArXG4gICAgICAgICAgICAnPEFQSVByb3ZpZGVyPi4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgbWFwSW5zdGFuY2VzIH0gPSBjdHg7XG4gICAgLy8gaWYgYW4gaWQgaXMgc3BlY2lmaWVkLCB0aGUgY29ycmVzcG9uZGluZyBtYXAgb3IgbnVsbCBpcyByZXR1cm5lZFxuICAgIGlmIChpZCAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG1hcEluc3RhbmNlc1tpZF0gfHwgbnVsbDtcbiAgICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgIGlmIChtYXApXG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgLy8gZmluYWxseSwgcmV0dXJuIHRoZSBkZWZhdWx0IG1hcCBpbnN0YW5jZVxuICAgIHJldHVybiBtYXBJbnN0YW5jZXNbJ2RlZmF1bHQnXSB8fCBudWxsO1xufTtcblxuZnVuY3Rpb24gdXNlTWFwc0xpYnJhcnkobmFtZSkge1xuICAgIGNvbnN0IGFwaUlzTG9hZGVkID0gdXNlQXBpSXNMb2FkZWQoKTtcbiAgICBjb25zdCBjdHggPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhcGlJc0xvYWRlZCB8fCAhY3R4KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUcmlnZ2VyIGxvYWRpbmcgdGhlIGxpYnJhcmllcyB2aWEgb3VyIHByb3h5LW1ldGhvZC5cbiAgICAgICAgLy8gVGhlIHJldHVybmVkIHByb21pc2UgaXMgaWdub3JlZCwgc2luY2UgaW1wb3J0TGlicmFyeSB3aWxsIHVwZGF0ZSBsb2FkZWRMaWJyYXJpZXNcbiAgICAgICAgLy8gbGlzdCBpbiB0aGUgY29udGV4dCwgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgICAgdm9pZCBjdHguaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgICB9LCBbYXBpSXNMb2FkZWQsIGN0eCwgbmFtZV0pO1xuICAgIHJldHVybiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmxvYWRlZExpYnJhcmllc1tuYW1lXSkgfHwgbnVsbDtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gYmluZCBldmVudHMgdG8gTWFwcyBKYXZhU2NyaXB0IEFQSSBvYmplY3RzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcHNFdmVudExpc3RlbmVyKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhbmFtZSB8fCAhY2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGFyZ2V0LCBuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB9LCBbdGFyZ2V0LCBuYW1lLCBjYWxsYmFja10pO1xufVxuXG4vKipcbiAqIEludGVybmFsbHkgdXNlZCB0byBjb3B5IHZhbHVlcyBmcm9tIHByb3BzIGludG8gQVBJLU9iamVjdHNcbiAqIHdoZW5ldmVyIHRoZXkgY2hhbmdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VQcm9wQmluZGluZyhvYmplY3QsIHByb3AsIHZhbHVlKSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFvYmplY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9pbW11dGFiaWxpdHlcbiAgICAgICAgb2JqZWN0W3Byb3BdID0gdmFsdWU7XG4gICAgfSwgW29iamVjdCwgcHJvcCwgdmFsdWVdKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gYmluZCBldmVudHMgdG8gRE9NIG5vZGVzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZURvbUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICFuYW1lIHx8ICFjYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICAgIH0sIFt0YXJnZXQsIG5hbWUsIGNhbGxiYWNrXSk7XG59XG5cbi8vIEdsb2JhbCBzdHlsZSBtYW5hZ2VyIHRvIHRyYWNrIHJlbmRlcmVkIHN0eWxlcyBhbmQgYXZvaWQgZHVwbGljYXRlc1xuY2xhc3MgR2xvYmFsU3R5bGVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBnZXRTdHlsZUVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1yZ20tYW5jaG9yLXN0eWxlcycsICcnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlRWxlbWVudDtcbiAgICB9XG4gICAgYWRkQWR2YW5jZWRNYXJrZXJQb2ludGVyRXZlbnRzT3ZlcndyaXRlKCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlZFN0eWxlcy5oYXMoJ21hcmtlci1wb2ludGVyLWV2ZW50cycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gdGhpcy5nZXRTdHlsZUVsZW1lbnQoKTtcbiAgICAgICAgc3R5bGVFbGVtZW50LnRleHRDb250ZW50ICs9IGBcbiAgICAgIGdtcC1hZHZhbmNlZC1tYXJrZXJbZGF0YS1vcmlnaW49J3JnbSddIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICBgO1xuICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzLmFkZCgnbWFya2VyLXBvaW50ZXItZXZlbnRzJyk7XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBnbG9iYWxTdHlsZU1hbmFnZXIgPSBuZXcgR2xvYmFsU3R5bGVNYW5hZ2VyKCk7XG5cbmZ1bmN0aW9uIGlzVmVyc2lvbkdyZWF0ZXJFcXVhbChtYWpvciwgbWlub3IpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEoKF9hID0gZ29vZ2xlID09PSBudWxsIHx8IGdvb2dsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ29vZ2xlLm1hcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52ZXJzaW9uKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCB2ZXJzaW9uID0gZ29vZ2xlLm1hcHMudmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGN1cnJlbnRNYWpvciA9IHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKTtcbiAgICBjb25zdCBjdXJyZW50TWlub3IgPSBwYXJzZUludCh2ZXJzaW9uWzFdLCAxMCk7XG4gICAgcmV0dXJuIChjdXJyZW50TWFqb3IgPiBtYWpvciB8fCAoY3VycmVudE1ham9yID09PSBtYWpvciAmJiBjdXJyZW50TWlub3IgPj0gbWlub3IpKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvaW1tdXRhYmlsaXR5ICovXG4vLyBUaGUgYHJlYWN0LWhvb2tzL2ltbXV0YWJpbGl0eWAgcnVsZSBpcyBkaXNhYmxlZCBpbiB0aGlzIGZpbGUgYmVjYXVzZSB0aGVcbi8vIGdvb2dsZS5tYXBzLm1hcmtlci5BZHZhbmNlZE1hcmtlckVsZW1lbnQgb2JqZWN0IGlzIGRlc2lnbmVkIHRvIGJlIG11dGF0ZWRcbi8vIGRpcmVjdGx5LiBUaGlzIGlzIGEgY29tbW9uIHBhdHRlcm4gd2hlbiB3b3JraW5nIHdpdGggaW1wZXJhdGl2ZSBBUElzIGxpa2Vcbi8vIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSS4gV2hpbGUgdGhpcyBnb2VzIGFnYWluc3QgdGhlIHByaW5jaXBsZXMgb2Zcbi8vIGltbXV0YWJsZSBzdGF0ZSBpbiBSZWFjdCwgaXQgaXMgYSBuZWNlc3NhcnkgZXZpbCB0byBpbnRlZ3JhdGUgd2l0aCB0aGVcbi8vIEdvb2dsZSBNYXBzIEFQSS4gVGhlIG11dGF0aW9ucyBhcmUgY2FyZWZ1bGx5IG1hbmFnZWQgd2l0aGluIHRoZSBgdXNlRWZmZWN0YFxuLy8gaG9va3MgdG8gZW5zdXJlIHRoYXQgdGhleSBvbmx5IGhhcHBlbiB3aGVuIHRoZSBwcm9wcyBjaGFuZ2UuXG4vKipcbiAqIENvcHkgb2YgdGhlIGBnb29nbGUubWFwcy5Db2xsaXNpb25CZWhhdmlvcmAgY29uc3RhbnRzLlxuICogVGhleSBoYXZlIHRvIGJlIGR1cGxpY2F0ZWQgaGVyZSBzaW5jZSB3ZSBjYW4ndCB3YWl0IGZvciB0aGUgbWFwcyBBUEkgdG8gbG9hZCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtLlxuICovXG5jb25zdCBDb2xsaXNpb25CZWhhdmlvciA9IHtcbiAgICBSRVFVSVJFRDogJ1JFUVVJUkVEJyxcbiAgICBSRVFVSVJFRF9BTkRfSElERVNfT1BUSU9OQUw6ICdSRVFVSVJFRF9BTkRfSElERVNfT1BUSU9OQUwnLFxuICAgIE9QVElPTkFMX0FORF9ISURFU19MT1dFUl9QUklPUklUWTogJ09QVElPTkFMX0FORF9ISURFU19MT1dFUl9QUklPUklUWSdcbn07XG5jb25zdCBBZHZhbmNlZE1hcmtlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuLy8gW3hQb3NpdGlvbiwgeVBvc2l0aW9uXSB3aGVuIHRoZSB0b3AgbGVmdCBjb3JuZXIgaXMgWzAsIDBdXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzaW5nIGBhbmNob3JQb3NpdGlvbmAgaXMgZGVwcmVjYXRlZC5cbiAqICAgVXNlIGBhbmNob3JMZWZ0YCBhbmQgYGFuY2hvclRvcGAgaW5zdGVhZC5cbiAqL1xuY29uc3QgQWR2YW5jZWRNYXJrZXJBbmNob3JQb2ludCA9IHtcbiAgICBUT1BfTEVGVDogWycwJScsICcwJSddLFxuICAgIFRPUF9DRU5URVI6IFsnNTAlJywgJzAlJ10sXG4gICAgVE9QOiBbJzUwJScsICcwJSddLFxuICAgIFRPUF9SSUdIVDogWycxMDAlJywgJzAlJ10sXG4gICAgTEVGVF9DRU5URVI6IFsnMCUnLCAnNTAlJ10sXG4gICAgTEVGVF9UT1A6IFsnMCUnLCAnMCUnXSxcbiAgICBMRUZUOiBbJzAlJywgJzUwJSddLFxuICAgIExFRlRfQk9UVE9NOiBbJzAlJywgJzEwMCUnXSxcbiAgICBSSUdIVF9UT1A6IFsnMTAwJScsICcwJSddLFxuICAgIFJJR0hUOiBbJzEwMCUnLCAnNTAlJ10sXG4gICAgUklHSFRfQ0VOVEVSOiBbJzEwMCUnLCAnNTAlJ10sXG4gICAgUklHSFRfQk9UVE9NOiBbJzEwMCUnLCAnMTAwJSddLFxuICAgIEJPVFRPTV9MRUZUOiBbJzAlJywgJzEwMCUnXSxcbiAgICBCT1RUT01fQ0VOVEVSOiBbJzUwJScsICcxMDAlJ10sXG4gICAgQk9UVE9NOiBbJzUwJScsICcxMDAlJ10sXG4gICAgQk9UVE9NX1JJR0hUOiBbJzEwMCUnLCAnMTAwJSddLFxuICAgIENFTlRFUjogWyc1MCUnLCAnNTAlJ11cbn07XG5jb25zdCBBZHZhbmNlZE1hcmtlciA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBzdHlsZSwgY2xhc3NOYW1lLCBhbmNob3JQb2ludCB9ID0gcHJvcHM7XG4gICAgY29uc3QgW21hcmtlciwgY29udGVudENvbnRhaW5lcl0gPSB1c2VBZHZhbmNlZE1hcmtlcihwcm9wcyk7XG4gICAgY29uc3QgYWR2YW5jZWRNYXJrZXJDb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IChtYXJrZXIgPyB7IG1hcmtlciB9IDogbnVsbCksIFttYXJrZXJdKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbbWFya2VyXSk7XG4gICAgaWYgKCFjb250ZW50Q29udGFpbmVyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWR2YW5jZWRNYXJrZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBhZHZhbmNlZE1hcmtlckNvbnRleHRWYWx1ZSB9LCBjcmVhdGVQb3J0YWwoUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrZXJDb250ZW50LCB7IGFuY2hvclBvaW50OiBhbmNob3JQb2ludCwgc3R5bGVzOiBzdHlsZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pLCBjb250ZW50Q29udGFpbmVyKSkpO1xufSk7XG5BZHZhbmNlZE1hcmtlci5kaXNwbGF5TmFtZSA9ICdBZHZhbmNlZE1hcmtlcic7XG5mdW5jdGlvbiB1c2VBZHZhbmNlZE1hcmtlclJlZigpIHtcbiAgICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgcmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygobSkgPT4ge1xuICAgICAgICBzZXRNYXJrZXIobSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5mdW5jdGlvbiBpc0FkdmFuY2VkTWFya2VyKG1hcmtlcikge1xuICAgIHJldHVybiAobWFya2VyLmNvbnRlbnQgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG5jb25zdCBNYXJrZXJDb250ZW50ID0gKHsgY2hpbGRyZW4sIHN0eWxlcywgY2xhc3NOYW1lIH0pID0+IHtcbiAgICAvKiBBZHZhbmNlZE1hcmtlciBkaXYgdGhhdCB1c2VyIGNhbiBnaXZlIHN0eWxlcyBhbmQgY2xhc3NlcyAqL1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogc3R5bGVzIH0sIGNoaWxkcmVuKSk7XG59O1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpIHtcbiAgICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2NvbnRlbnRDb250YWluZXIsIHNldENvbnRlbnRDb250YWluZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gICAgY29uc3QgbWFya2VyTGlicmFyeSA9IHVzZU1hcHNMaWJyYXJ5KCdtYXJrZXInKTtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBvbkNsaWNrLCBjbGFzc05hbWUsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBvbkRyYWcsIG9uRHJhZ1N0YXJ0LCBvbkRyYWdFbmQsIGNvbGxpc2lvbkJlaGF2aW9yLCBjbGlja2FibGUsIGRyYWdnYWJsZSwgcG9zaXRpb24sIHRpdGxlLCB6SW5kZXgsIGFuY2hvclBvaW50LCBhbmNob3JMZWZ0LCBhbmNob3JUb3AgfSA9IHByb3BzO1xuICAgIGNvbnN0IG51bUNoaWxkcmVuID0gQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pO1xuICAgIC8vIGNyZWF0ZSBhbiBBZHZhbmNlZE1hcmtlckVsZW1lbnQgaW5zdGFuY2UgYW5kIGFkZCBpdCB0byB0aGUgbWFwIG9uY2UgYXZhaWxhYmxlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXAgfHwgIW1hcmtlckxpYnJhcnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5ld01hcmtlciA9IG5ldyBtYXJrZXJMaWJyYXJ5LkFkdmFuY2VkTWFya2VyRWxlbWVudCgpO1xuICAgICAgICBuZXdNYXJrZXIubWFwID0gbWFwO1xuICAgICAgICBzZXRNYXJrZXIobmV3TWFya2VyKTtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBjb250YWluZXIgZm9yIG1hcmtlciBjb250ZW50IGlmIHRoZXJlIGFyZSBjaGlsZHJlblxuICAgICAgICBsZXQgY29udGVudEVsZW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAobnVtQ2hpbGRyZW4gPiAwKSB7XG4gICAgICAgICAgICBjb250ZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbmV3TWFya2VyLmNvbnRlbnQgPSBjb250ZW50RWxlbWVudDtcbiAgICAgICAgICAgIHNldENvbnRlbnRDb250YWluZXIoY29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBuZXdNYXJrZXIubWFwID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50ID09PSBudWxsIHx8IGNvbnRlbnRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICAgICAgICAgIHNldENvbnRlbnRDb250YWluZXIobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW21hcCwgbWFya2VyTGlicmFyeSwgbnVtQ2hpbGRyZW5dKTtcbiAgICAvLyBXaGVuIG5vIGNoaWxkcmVuIGFyZSBwcmVzZW50IHdlIGRvbid0IGhhdmUgb3VyIG93biB3cmFwcGVyIGRpdlxuICAgIC8vIHdoaWNoIHVzdWFsbHkgZ2V0cyB0aGUgdXNlciBwcm92aWRlZCBjbGFzc05hbWUuIEluIHRoaXMgY2FzZVxuICAgIC8vIHdlIHNldCB0aGUgY2xhc3NOYW1lIGRpcmVjdGx5IG9uIHRoZSBtYXJrZXIuY29udGVudCBlbGVtZW50IHRoYXQgY29tZXNcbiAgICAvLyB3aXRoIHRoZSBBZHZhbmNlZE1hcmtlci5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIShtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuY29udGVudCkgfHwgIWlzRWxlbWVudE5vZGUobWFya2VyLmNvbnRlbnQpIHx8IG51bUNoaWxkcmVuID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFya2VyLmNvbnRlbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lICE9PSBudWxsICYmIGNsYXNzTmFtZSAhPT0gdm9pZCAwID8gY2xhc3NOYW1lIDogJyc7XG4gICAgfSwgW21hcmtlciwgY2xhc3NOYW1lLCBudW1DaGlsZHJlbl0pO1xuICAgIHVzZUFkdmFuY2VkTWFya2VyQW5jaG9yaW5nKG1hcmtlciwgYW5jaG9yUG9pbnQsIGFuY2hvckxlZnQsIGFuY2hvclRvcCwgbnVtQ2hpbGRyZW4gPiAwKTtcbiAgICAvLyBjb3B5IG90aGVyIHByb3BzXG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAncG9zaXRpb24nLCBwb3NpdGlvbik7XG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAndGl0bGUnLCB0aXRsZSAhPT0gbnVsbCAmJiB0aXRsZSAhPT0gdm9pZCAwID8gdGl0bGUgOiAnJyk7XG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAnekluZGV4JywgekluZGV4KTtcbiAgICB1c2VQcm9wQmluZGluZyhtYXJrZXIsICdjb2xsaXNpb25CZWhhdmlvcicsIGNvbGxpc2lvbkJlaGF2aW9yKTtcbiAgICAvLyBzZXQgZ21wRHJhZ2dhYmxlIGZyb20gcHJvcHMgKHdoZW4gdW5zcGVjaWZpZWQsIGl0J3MgdHJ1ZSBpZiBhbnkgZHJhZy1ldmVudFxuICAgIC8vIGNhbGxiYWNrcyBhcmUgc3BlY2lmaWVkKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZHJhZ2dhYmxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBtYXJrZXIuZ21wRHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgICAgICBlbHNlIGlmIChvbkRyYWcgfHwgb25EcmFnU3RhcnQgfHwgb25EcmFnRW5kKVxuICAgICAgICAgICAgbWFya2VyLmdtcERyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hcmtlci5nbXBEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB9LCBbbWFya2VyLCBkcmFnZ2FibGUsIG9uRHJhZywgb25EcmFnRW5kLCBvbkRyYWdTdGFydF0pO1xuICAgIC8vIHNldCBnbXBDbGlja2FibGUgZnJvbSBwcm9wcyAod2hlbiB1bnNwZWNpZmllZCwgaXQncyB0cnVlIGlmIHRoZSBvbkNsaWNrIG9yIG9uZSBvZlxuICAgIC8vIHRoZSBob3ZlciBldmVudHMgY2FsbGJhY2tzIGFyZSBzcGVjaWZpZWQpXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGdtcENsaWNrYWJsZSA9IGNsaWNrYWJsZSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBCb29sZWFuKG9uQ2xpY2spIHx8XG4gICAgICAgICAgICBCb29sZWFuKG9uTW91c2VFbnRlcikgfHxcbiAgICAgICAgICAgIEJvb2xlYW4ob25Nb3VzZUxlYXZlKTtcbiAgICAgICAgLy8gZ21wQ2xpY2thYmxlIGlzIG9ubHkgYXZhaWxhYmxlIGluIGJldGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgICAgLy8gbWFwcyBhcGkgKGFzIG9mIDIwMjQtMTAtMTApXG4gICAgICAgIG1hcmtlci5nbXBDbGlja2FibGUgPSBnbXBDbGlja2FibGU7XG4gICAgICAgIC8vIGVuYWJsZSBwb2ludGVyIGV2ZW50cyBmb3IgdGhlIG1hcmtlcnMgd2l0aCBjdXN0b20gY29udGVudFxuICAgICAgICBpZiAoZ21wQ2xpY2thYmxlICYmIChtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuY29udGVudCkgJiYgaXNFbGVtZW50Tm9kZShtYXJrZXIuY29udGVudCkpIHtcbiAgICAgICAgICAgIG1hcmtlci5jb250ZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYWxsJztcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLmNvbnRlbnQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW21hcmtlciwgY2xpY2thYmxlLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZV0pO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2NsaWNrJywgb25DbGljayk7XG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIobWFya2VyLCAnZHJhZycsIG9uRHJhZyk7XG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIobWFya2VyLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpO1xuICAgIHVzZURvbUV2ZW50TGlzdGVuZXIobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmVsZW1lbnQsICdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICB1c2VEb21FdmVudExpc3RlbmVyKG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5lbGVtZW50LCAnbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgcmV0dXJuIFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdO1xufVxuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXJBbmNob3JpbmcobWFya2VyLCBhbmNob3JQb2ludCwgYW5jaG9yTGVmdCwgYW5jaG9yVG9wLCBoYXNDaGlsZHJlbikge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyIHx8ICFoYXNDaGlsZHJlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVGhlIGFuY2hvckxlZnQgYW5kIGFuY2hvclRvcCBvcHRpb25zIGFyZSBhdmFpbGFibGUgc2luY2UgdmVyc2lvbiAzLjYyLjljXG4gICAgICAgIC8vIFdpdGggdGhlIHJlbGVhc2Ugb2YgMy42NSAofk1heSAyMDI2KSB0aGVyZSB3aWxsIG5vIGxvbmdlciBiZSBhIHZlcnNpb25cbiAgICAgICAgLy8gdGhhdCBkb2Vzbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGNvbnN0IGFuY2hvck9wdGlvbnNTdXBwb3J0ZWQgPSBpc1ZlcnNpb25HcmVhdGVyRXF1YWwoMywgNjIpO1xuICAgICAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IG1hcmtlci5jb250ZW50O1xuICAgICAgICBpZiAoIWNvbnRlbnRFbGVtZW50IHx8ICFpc0VsZW1lbnROb2RlKGNvbnRlbnRFbGVtZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGFuY2hvckxlZnQgIT09IHVuZGVmaW5lZCB8fCBhbmNob3JUb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFhbmNob3JPcHRpb25zU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBZHZhbmNlZE1hcmtlcjogVGhlIGFuY2hvckxlZnQgYW5kIGFuY2hvclRvcCBwcm9wcyBhcmUgb25seSBzdXBwb3J0ZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICdpbiBHb29nbGUgTWFwcyBBUEkgdmVyc2lvbiAzLjYyIGFuZCBhYm92ZS4gJyArXG4gICAgICAgICAgICAgICAgICAgIGBUaGUgY3VycmVudCB2ZXJzaW9uIGlzICR7Z29vZ2xlLm1hcHMudmVyc2lvbn0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrZXIuYW5jaG9yTGVmdCA9IGFuY2hvckxlZnQ7XG4gICAgICAgICAgICBtYXJrZXIuYW5jaG9yVG9wID0gYW5jaG9yVG9wO1xuICAgICAgICAgICAgLy8gd2hlbiBhbmNob3JMZWZ0IGFuZC9vciBhbmNob3JUb3AgYXJlIHNldCwgd2UnbGwgaWdub3JlIHRoZSBhbmNob3JQb2ludFxuICAgICAgICAgICAgaWYgKGFuY2hvclBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FkdmFuY2VkTWFya2VyOiB0aGUgYW5jaG9yUG9pbnQgcHJvcCBpcyBpZ25vcmVkIHdoZW4gYW5jaG9yTGVmdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuZC9vciBhbmNob3JUb3AgYXJlIHNldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yUG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogYWRkIGNvbnNvbGUud2FybiBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHRvIGluZm9ybSBhYm91dCBkZXByZWNhdGlvblxuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gYW5jaG9yUG9pbnQgIT09IG51bGwgJiYgYW5jaG9yUG9pbnQgIT09IHZvaWQgMCA/IGFuY2hvclBvaW50IDogQWR2YW5jZWRNYXJrZXJBbmNob3JQb2ludFsnQk9UVE9NJ107XG4gICAgICAgICAgICAvLyBOT1RFOiBzaW5jZSB4IGFuZCB5IGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGxlbmd0aC1wZXJjZW50YWdlXG4gICAgICAgICAgICAvLyAgIHZhbHVlLCB3ZSBuZWVkIHRvIHVzZSBjYWxjKCkgdG8gbmVnYXRlIHRoZW0uXG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVYID0gYGNhbGMoLTEgKiAke3h9KWA7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVZID0gYGNhbGMoLTEgKiAke3l9KWA7XG4gICAgICAgICAgICBpZiAoYW5jaG9yT3B0aW9uc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGltcGxlbWVudCBhbmNob3JQb2ludCB1c2luZyB0aGUgbmV3IGFuY2hvckxlZnQgYW5kIGFuY2hvclRvcCBvcHRpb25zXG4gICAgICAgICAgICAgICAgbWFya2VyLmFuY2hvckxlZnQgPSB0cmFuc2xhdGVYO1xuICAgICAgICAgICAgICAgIG1hcmtlci5hbmNob3JUb3AgPSB0cmFuc2xhdGVZO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRyYW5zZm9ybSBmcm9tIGxlZ2FjeSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIFwidHJhbnNsYXRlKDUwJSwgMTAwJSlcIiBjb3VudGVycyBhbmQgcmVzZXRzIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yaW5nIG9mIHRoZSBhZHZhbmNlZCBtYXJrZXIgZWxlbWVudCBmcm9tIHRoZSBhcGlcbiAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKDUwJSwgMTAwJSkgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH0sICR7dHJhbnNsYXRlWX0pYDtcbiAgICAgICAgICAgICAgICAvLyBkYXRhLW9yaWdpbiBpcyBuZWVkZWQgdG8gaWRlbnRpZnkgdGhlIGN1c3RvbSBtYXJrZXIgY29udGVudCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBJbmZvV2luZG93IGNvbXBvbmVudCBhcyB3ZWxsIGFzIGluIHRoZSBnbG9iYWwgQ1NTIHVzZWQgdG8gZGlzYWJsZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBwb2ludGVyIGV2ZW50IHdoZW4gYW5jaG9yIHBvaW50cyBhcmUgdXNlZCBpbiBvbGRlciBHb29nbGUgTWFwc1xuICAgICAgICAgICAgICAgIC8vIHZlcnNpb25zLlxuICAgICAgICAgICAgICAgIG1hcmtlci5kYXRhc2V0Lm9yaWdpbiA9ICdyZ20nO1xuICAgICAgICAgICAgICAgIGdsb2JhbFN0eWxlTWFuYWdlci5hZGRBZHZhbmNlZE1hcmtlclBvaW50ZXJFdmVudHNPdmVyd3JpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFttYXJrZXIsIGFuY2hvclBvaW50LCBhbmNob3JMZWZ0LCBhbmNob3JUb3AsIGhhc0NoaWxkcmVuXSk7XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKGVsZW1lbnQsIHN0eWxlcywgcHJldlN0eWxlcykge1xuICAgIGlmIChzdHlsZXMgIT0gbnVsbCAmJiB0eXBlb2Ygc3R5bGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArXG4gICAgICAgICAgICBcIm5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiBcIiArXG4gICAgICAgICAgICAndXNpbmcgSlNYLicpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50U3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIC8vIHdpdGhvdXQgYHByZXZTdHlsZXNgLCBqdXN0IHNldCBhbGwgdmFsdWVzXG4gICAgaWYgKHByZXZTdHlsZXMgPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3R5bGVzID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHNldFZhbHVlRm9yU3R5bGUoZWxlbWVudFN0eWxlLCBzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHVuc2V0IGFsbCBzdHlsZXMgaW4gYHByZXZTdHlsZXNgIHRoYXQgYXJlbid0IGluIGBzdHlsZXNgXG4gICAgZm9yIChjb25zdCBzdHlsZU5hbWUgaW4gcHJldlN0eWxlcykge1xuICAgICAgICBpZiAocHJldlN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICAoc3R5bGVzID09IG51bGwgfHwgIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgc3R5bGVcbiAgICAgICAgICAgIGNvbnN0IGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgYXNzaWduIHZhbHVlcyBmcm9tIGBzdHlsZXNgIHRoYXQgYXJlIGRpZmZlcmVudCBmcm9tIGBwcmV2U3R5bGVzYFxuICAgIGlmIChzdHlsZXMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgIHByZXZTdHlsZXNbc3R5bGVOYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNldFZhbHVlRm9yU3R5bGUoZWxlbWVudFN0eWxlLCBzdHlsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGUoZWxlbWVudFN0eWxlLCBzdHlsZU5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIC8vIGZhbHN5IHZhbHVlcyB3aWxsIHVuc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eVxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbid0IGJlIGRpcmVjdGx5IGFzc2lnbmVkXG4gICAgZWxzZSBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICBlbGVtZW50U3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIG51bWVyaWMgdmFsdWVzIGFyZSB0cmVhdGVkIGFzICdweCcgdW5sZXNzIHRoZSBzdHlsZSBwcm9wZXJ0eSBleHBlY3RzIHVuaXRsZXNzIG51bWJlcnNcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlICE9PSAwICYmXG4gICAgICAgICFpc1VuaXRsZXNzTnVtYmVyKHN0eWxlTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudFN0eWxlW3N0eWxlTmFtZV0gPSB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gICAgfVxuICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZSBjYW4ganVzdCBiZSBhc3NpZ25lZFxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGUuY3NzRmxvYXQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZVtzdHlsZU5hbWVdID0gKCcnICsgdmFsdWUpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbmNvbnN0IHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoW1xuICAgICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsXG4gICAgJ2FzcGVjdFJhdGlvJyxcbiAgICAnYm9yZGVySW1hZ2VPdXRzZXQnLFxuICAgICdib3JkZXJJbWFnZVNsaWNlJyxcbiAgICAnYm9yZGVySW1hZ2VXaWR0aCcsXG4gICAgJ2JveEZsZXgnLFxuICAgICdib3hGbGV4R3JvdXAnLFxuICAgICdib3hPcmRpbmFsR3JvdXAnLFxuICAgICdjb2x1bW5Db3VudCcsXG4gICAgJ2NvbHVtbnMnLFxuICAgICdmbGV4JyxcbiAgICAnZmxleEdyb3cnLFxuICAgICdmbGV4UG9zaXRpdmUnLFxuICAgICdmbGV4U2hyaW5rJyxcbiAgICAnZmxleE5lZ2F0aXZlJyxcbiAgICAnZmxleE9yZGVyJyxcbiAgICAnZ3JpZEFyZWEnLFxuICAgICdncmlkUm93JyxcbiAgICAnZ3JpZFJvd0VuZCcsXG4gICAgJ2dyaWRSb3dTcGFuJyxcbiAgICAnZ3JpZFJvd1N0YXJ0JyxcbiAgICAnZ3JpZENvbHVtbicsXG4gICAgJ2dyaWRDb2x1bW5FbmQnLFxuICAgICdncmlkQ29sdW1uU3BhbicsXG4gICAgJ2dyaWRDb2x1bW5TdGFydCcsXG4gICAgJ2ZvbnRXZWlnaHQnLFxuICAgICdsaW5lQ2xhbXAnLFxuICAgICdsaW5lSGVpZ2h0JyxcbiAgICAnb3BhY2l0eScsXG4gICAgJ29yZGVyJyxcbiAgICAnb3JwaGFucycsXG4gICAgJ3NjYWxlJyxcbiAgICAndGFiU2l6ZScsXG4gICAgJ3dpZG93cycsXG4gICAgJ3pJbmRleCcsXG4gICAgJ3pvb20nLFxuICAgICdmaWxsT3BhY2l0eScsIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgICAnZmxvb2RPcGFjaXR5JyxcbiAgICAnc3RvcE9wYWNpdHknLFxuICAgICdzdHJva2VEYXNoYXJyYXknLFxuICAgICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgICAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICAgJ3N0cm9rZU9wYWNpdHknLFxuICAgICdzdHJva2VXaWR0aCdcbl0pO1xuZnVuY3Rpb24gaXNVbml0bGVzc051bWJlcihuYW1lKSB7XG4gICAgcmV0dXJuIHVuaXRsZXNzTnVtYmVycy5oYXMobmFtZSk7XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhbiBJbmZvIFdpbmRvdyB3aXRoIHRoZSBNYXBzIEphdmFTY3JpcHQgQVBJXG4gKi9cbmNvbnN0IEluZm9XaW5kb3cgPSBwcm9wcyA9PiB7XG4gICAgY29uc3QgeyBcbiAgICAvLyBjb250ZW50IG9wdGlvbnNcbiAgICBjaGlsZHJlbiwgaGVhZGVyQ29udGVudCwgc3R5bGUsIGNsYXNzTmFtZSwgcGl4ZWxPZmZzZXQsIFxuICAgIC8vIG9wZW4gb3B0aW9uc1xuICAgIGFuY2hvciwgc2hvdWxkRm9jdXMsIFxuICAgIC8vIGV2ZW50c1xuICAgIG9uQ2xvc2UsIG9uQ2xvc2VDbGljayB9ID0gcHJvcHMsIFxuICAgIC8vIG90aGVyIG9wdGlvbnNcbiAgICB2b2xhdGlsZUluZm9XaW5kb3dPcHRpb25zID0gX19yZXN0KHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImhlYWRlckNvbnRlbnRcIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiLCBcInBpeGVsT2Zmc2V0XCIsIFwiYW5jaG9yXCIsIFwic2hvdWxkRm9jdXNcIiwgXCJvbkNsb3NlXCIsIFwib25DbG9zZUNsaWNrXCJdKTtcbiAgICAvLyAjIyBjcmVhdGUgaW5mb3dpbmRvdyBpbnN0YW5jZSBvbmNlIHRoZSBtYXBzTGlicmFyeSBpcyBhdmFpbGFibGUuXG4gICAgY29uc3QgbWFwc0xpYnJhcnkgPSB1c2VNYXBzTGlicmFyeSgnbWFwcycpO1xuICAgIGNvbnN0IFtpbmZvV2luZG93LCBzZXRJbmZvV2luZG93XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaGVhZGVyQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGluZm9XaW5kb3dPcHRpb25zID0gdXNlTWVtb2l6ZWQodm9sYXRpbGVJbmZvV2luZG93T3B0aW9ucywgaXNEZWVwRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwc0xpYnJhcnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgICAgIGlmIChwaXhlbE9mZnNldCkge1xuICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG5ldyBnb29nbGUubWFwcy5TaXplKHBpeGVsT2Zmc2V0WzBdLCBwaXhlbE9mZnNldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlckNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIGlmIGhlYWRlckNvbnRlbnQgaXMgc3BlY2lmaWVkIGFzIHN0cmluZyB3ZSBjYW4gZGlyZWN0bHkgZm9yd2FyZCBpdCxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSdsbCBwYXNzIHRoZSBlbGVtZW50IHRoZSBwb3J0YWwgd2lsbCByZW5kZXIgaW50b1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJDb250ZW50ID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaGVhZGVyQ29udGVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBoZWFkZXJDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDogaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBzaGFkb3dpbmcgdGhlIHN0YXRlIHZhcmlhYmxlcyBoZXJlXG4gICAgICAgIGNvbnN0IGluZm9XaW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyhpbmZvV2luZG93T3B0aW9ucyk7XG4gICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpO1xuICAgICAgICBzZXRJbmZvV2luZG93KGluZm9XaW5kb3cpO1xuICAgICAgICAvLyB1bm1vdW50OiByZW1vdmUgaW5mb1dpbmRvdyBhbmQgY29udGVudCBlbGVtZW50cyAobm90ZTogY2xvc2UgaXMgY2FsbGVkIGluIGEgZGlmZmVyZW50IGVmZmVjdC1jbGVhbnVwKVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChudWxsKTtcbiAgICAgICAgICAgIChfYSA9IGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgKF9iID0gaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmUoKTtcbiAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBzZXRJbmZvV2luZG93KG51bGwpO1xuICAgICAgICB9O1xuICAgIH0sIFxuICAgIC8vIGBpbmZvV2luZG93T3B0aW9uc2AgYW5kIG90aGVyIHByb3BzIGFyZSBtaXNzaW5nIGZyb20gZGVwZW5kZW5jaWVzOlxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZS1jcmVhdGUgdGhlIGluZm93aW5kb3cgaW5zdGFuY2VcbiAgICAvLyB3aGVuIHRoZSBvcHRpb25zIGNoYW5nZS5cbiAgICAvLyBVcGRhdGluZyB0aGUgb3B0aW9ucyBpcyBoYW5kbGVkIGluIHRoZSB1c2VFZmZlY3QgYmVsb3cuXG4gICAgLy9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW21hcHNMaWJyYXJ5XSk7XG4gICAgLy8gLS0tLSB1cGRhdGUgY2xhc3NOYW1lIGFuZCBzdHlsZXMgZm9yIGBjb250ZW50Q29udGFpbmVyYFxuICAgIC8vIHByZXZTdHlsZVJlZiBzdG9yZXMgcHJldmlvdXNseSBhcHBsaWVkIHN0eWxlIHByb3BlcnRpZXMsIHNvIHRoZXkgY2FuIGJlXG4gICAgLy8gcmVtb3ZlZCB3aGVuIHVuc2V0XG4gICAgY29uc3QgcHJldlN0eWxlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaW5mb1dpbmRvdyB8fCAhY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXRWYWx1ZUZvclN0eWxlcyhjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQsIHN0eWxlIHx8IG51bGwsIHByZXZTdHlsZVJlZi5jdXJyZW50KTtcbiAgICAgICAgcHJldlN0eWxlUmVmLmN1cnJlbnQgPSBzdHlsZSB8fCBudWxsO1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9PSBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xhc3NOYW1lKVxuICAgICAgICAgICAgY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcbiAgICB9LCBbaW5mb1dpbmRvdywgY2xhc3NOYW1lLCBzdHlsZV0pO1xuICAgIC8vIC0tLS0gdXBkYXRlIG9wdGlvbnNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWluZm9XaW5kb3cpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9wdHMgPSBpbmZvV2luZG93T3B0aW9ucztcbiAgICAgICAgaWYgKCFwaXhlbE9mZnNldCkge1xuICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLnBpeGVsT2Zmc2V0ID0gbmV3IGdvb2dsZS5tYXBzLlNpemUocGl4ZWxPZmZzZXRbMF0sIHBpeGVsT2Zmc2V0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlYWRlckNvbnRlbnQpIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVyQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlckNvbnRlbnQgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBoZWFkZXJDb250ZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IGhlYWRlckNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgOiBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBpbmZvV2luZG93LnNldE9wdGlvbnMoaW5mb1dpbmRvd09wdGlvbnMpO1xuICAgIH0sIFxuICAgIC8vIGRlcGVuZGVuY3kgYGluZm9XaW5kb3dgIGlzbid0IG5lZWRlZCBzaW5jZSBvcHRpb25zIGFyZSBhbHNvIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciB3aGVuIGEgbmV3IGluZm9XaW5kb3cgaXMgY3JlYXRlZC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2luZm9XaW5kb3dPcHRpb25zLCBwaXhlbE9mZnNldCwgaGVhZGVyQ29udGVudF0pO1xuICAgIC8vICMjIGJpbmQgZXZlbnQgaGFuZGxlcnNcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihpbmZvV2luZG93LCAnY2xvc2UnLCBvbkNsb3NlKTtcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihpbmZvV2luZG93LCAnY2xvc2VjbGljaycsIG9uQ2xvc2VDbGljayk7XG4gICAgLy8gLS0tLSBvcGVuIGluZm8gd2luZG93IHdoZW4gY29udGVudCBhbmQgbWFwIGFyZSBhdmFpbGFibGVcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGBhbmNob3IgPT09IG51bGxgIG1lYW5zIGFuIGFuY2hvciBpcyBkZWZpbmVkIGJ1dCBub3QgcmVhZHkgeWV0LlxuICAgICAgICBpZiAoIW1hcCB8fCAhaW5mb1dpbmRvdyB8fCBhbmNob3IgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzT3BlbmVkV2l0aEFuY2hvciA9ICEhYW5jaG9yO1xuICAgICAgICBjb25zdCBvcGVuT3B0aW9ucyA9IHsgbWFwIH07XG4gICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgIG9wZW5PcHRpb25zLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgICAgIC8vIE9ubHkgZG8gdGhlIGluZm93aW5kb3cgYWRqdXN0aW5nIHdoZW4gZGVhbGluZyB3aXRoIGFuIEFkdmFuY2VkTWFya2VyXG4gICAgICAgICAgICBpZiAoaXNBZHZhbmNlZE1hcmtlcihhbmNob3IpICYmIGFuY2hvci5jb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvckJjciA9IGFuY2hvciA9PT0gbnVsbCB8fCBhbmNob3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGUgYW5jaG9yIGhhcyBjdXN0b20gY29udGVudCB3aXRoIG91ciBvd25cbiAgICAgICAgICAgICAgICAvLyBkaXYgd3JhcHBlci4gSWYgbm90LCB0aGF0IG1lYW5zIHdlIGhhdmUgYSByZWd1bGFyIEFkdmFuY2VkTWFya2VyIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiwgb3IgYW4gQWR2YW5jZWRNYXJrZXIgdGhhdCB1c2VzIHRoZSBhbmNob3JMZWZ0L2FuY2hvclRvcCBwcm9wcy5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gYWRqdXN0IHRoZSBpbmZvd2luZG93IHNpbmNlIGl0IGlzIGFsbCBoYW5kbGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSBHb29nbGUgTWFwcyBBUEkuXG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvckJjciAmJiBhbmNob3IuZGF0YXNldC5vcmlnaW4gPT09ICdyZ20nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBzYWZlbHkgdHlwZWNhc3QgaGVyZSBzaW5jZSB3ZSBjb250cm9sIHRoYXQgZWxlbWVudCBhbmQgd2Uga25vdyB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIGEgZGl2XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvckRvbUNvbnRlbnQgPSAoX2EgPSBhbmNob3IuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50QmNyID0gYW5jaG9yRG9tQ29udGVudCA9PT0gbnVsbCB8fCBhbmNob3JEb21Db250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmNob3JEb21Db250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjZW50ZXIgaW5mb3dpbmRvdyBhYm92ZSBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0WCA9IGNvbnRlbnRCY3IueCAtXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JCY3IueCArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29udGVudEJjci53aWR0aCAtIGFuY2hvckJjci53aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JPZmZzZXRZID0gY29udGVudEJjci55IC0gYW5jaG9yQmNyLnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBpbmZvV2luZG93T3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG5ldyBnb29nbGUubWFwcy5TaXplKHBpeGVsT2Zmc2V0ID8gcGl4ZWxPZmZzZXRbMF0gKyBhbmNob3JPZmZzZXRYIDogYW5jaG9yT2Zmc2V0WCwgcGl4ZWxPZmZzZXQgPyBwaXhlbE9mZnNldFsxXSArIGFuY2hvck9mZnNldFkgOiBhbmNob3JPZmZzZXRZKTtcbiAgICAgICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5zZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRm9jdXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3Blbk9wdGlvbnMuc2hvdWxkRm9jdXMgPSBzaG91bGRGb2N1cztcbiAgICAgICAgfVxuICAgICAgICBpbmZvV2luZG93Lm9wZW4ob3Blbk9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gTm90ZTogd2hlbiB0aGUgaW5mb3dpbmRvdyBoYXMgYW4gYW5jaG9yLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc2hvdyB1cCBhZ2FpbiB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gYW5jaG9yIHdhcyByZW1vdmVkIGZyb20gdGhlIG1hcCBiZWZvcmUgaW5mb1dpbmRvdy5jbG9zZSgpIGlzIGNhbGxlZCBidXQgdGhlIGl0IGdldHNcbiAgICAgICAgICAgIC8vIGFkZGVkIGJhY2sgdG8gdGhlIG1hcCBhZnRlciB0aGF0LlxuICAgICAgICAgICAgLy8gTW9yZSBpbmZvcm1hdGlvbiBoZXJlOiBodHRwczovL2lzc3VldHJhY2tlci5nb29nbGUuY29tL2lzc3Vlcy8zNDM3NTA4NDlcbiAgICAgICAgICAgIGlmIChpc09wZW5lZFdpdGhBbmNob3IpXG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5zZXQoJ2FuY2hvcicsIG51bGwpO1xuICAgICAgICAgICAgaW5mb1dpbmRvdy5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtpbmZvV2luZG93LCBhbmNob3IsIG1hcCwgc2hvdWxkRm9jdXMsIGluZm9XaW5kb3dPcHRpb25zLCBwaXhlbE9mZnNldF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCksXG4gICAgICAgIGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50ICE9PSBudWxsICYmXG4gICAgICAgICAgICBjcmVhdGVQb3J0YWwoaGVhZGVyQ29udGVudCwgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQpKSk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBsb2NhdGlvbiBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHN1aXRhYmxlIGZvciBHb29nbGUgU3RhdGljIE1hcHMgQVBJLlxuICpcbiAqIEBwYXJhbSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byBmb3JtYXQsIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGggbGF0L2xuZyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbG9jYXRpb24gaW4gdGhlIGZvcm1hdCBcImxhdCxsbmdcIiBvciB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJldHVybnMgXCI0MC43MTQ3MjgsLTczLjk5ODY3MlwiXG4gKiBmb3JtYXRMb2NhdGlvbih7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmV0dXJucyBcIk5ldyBZb3JrLCBOWVwiXG4gKiBmb3JtYXRMb2NhdGlvbihcIk5ldyBZb3JrLCBOWVwiKVxuICovXG5mdW5jdGlvbiBmb3JtYXRMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgID8gbG9jYXRpb25cbiAgICAgICAgOiBgJHtsb2NhdGlvbi5sYXR9LCR7bG9jYXRpb24ubG5nfWA7XG59XG4vLyBVc2VkIGZvciByZW1vdmluZyB0aGUgbGVhZGluZyBwaXBlIGZyb20gdGhlIHBhcmFtIHN0cmluZ1xuZnVuY3Rpb24gZm9ybWF0UGFyYW0oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBBc3NlbWJsZXMgbWFya2VyIHBhcmFtZXRlcnMgZm9yIHN0YXRpYyBtYXBzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gYXJyYXkgb2YgbWFya2VycyBhbmQgZ3JvdXBzIHRoZW0gYnkgdGhlaXIgc3R5bGUgcHJvcGVydGllcy5cbiAqIEl0IHRoZW4gY3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVzZSBtYXJrZXJzLCBpbmNsdWRpbmcgdGhlaXIgc3R5bGVzIGFuZCBsb2NhdGlvbnMsXG4gKiB3aGljaCBjYW4gYmUgdXNlZCBhcyBwYXJhbWV0ZXJzIGZvciBzdGF0aWMgbWFwIEFQSXMuXG4gKlxuICogQHBhcmFtIHtTdGF0aWNNYXBzTWFya2VyW119IFttYXJrZXJzPVtdXSAtIEFuIGFycmF5IG9mIG1hcmtlcnMgdG8gYmUgcHJvY2Vzc2VkLiBFYWNoIG1hcmtlciBjYW4gaGF2ZSBwcm9wZXJ0aWVzIHN1Y2ggYXMgY29sb3IsIGxhYmVsLCBzaXplLCBzY2FsZSwgaWNvbiwgYW5jaG9yLCBhbmQgbG9jYXRpb24uXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIHN0cmluZ3MsIGVhY2ggcmVwcmVzZW50aW5nIGEgZ3JvdXAgb2YgbWFya2VycyB3aXRoIHRoZWlyIHN0eWxlcyBhbmQgbG9jYXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtYXJrZXJzID0gW1xuICogICB7IGNvbG9yOiAnYmx1ZScsIGxhYmVsOiAnQScsIHNpemU6ICdtaWQnLCBsb2NhdGlvbjogJzQwLjcxNDcyOCwtNzMuOTk4NjcyJyB9LFxuICogICB7IGNvbG9yOiAnYmx1ZScsIGxhYmVsOiAnQicsIHNpemU6ICdtaWQnLCBsb2NhdGlvbjogJzQwLjcxNDcyOCwtNzMuOTk4NjcyJyB9LFxuICogICB7IGljb246ICdodHRwOi8vZXhhbXBsZS5jb20vaWNvbi5wbmcnLCBsb2NhdGlvbjogeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0gfVxuICogXTtcbiAqIGNvbnN0IHBhcmFtcyA9IGFzc2VtYmxlTWFya2VyUGFyYW1zKG1hcmtlcnMpO1xuICogLy8gUGFyYW1zIHdpbGwgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIG1hcmtlciBwYXJhbWV0ZXJzXG4gKiBFeGFtcGxlIG91dHB1dDogW1xuICogICBcImNvbG9yOmJsdWV8bGFiZWw6QXxzaXplOm1pZHw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTQ3MjgsLTczLjk5ODY3MlwiLFxuICogICBcImNvbG9yOmJsdWV8bGFiZWw6QnxzaXplOm1pZHw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTQ3MjgsLTczLjk5ODY3MlwiLFxuICogICBcImljb246aHR0cDovL2V4YW1wbGUuY29tL2ljb24ucG5nfDQwLjcxNDcyOCwtNzMuOTk4NjcyXCJcbiAqIF1cbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVNYXJrZXJQYXJhbXMobWFya2VycyA9IFtdKSB7XG4gICAgY29uc3QgbWFya2VyUGFyYW1zID0gW107XG4gICAgLy8gR3JvdXAgbWFya2VycyBieSBzdHlsZVxuICAgIGNvbnN0IG1hcmtlcnNCeVN0eWxlID0gbWFya2VycyA9PT0gbnVsbCB8fCBtYXJrZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJzLnJlZHVjZSgoc3R5bGVzLCBtYXJrZXIpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2xvciA9ICdyZWQnLCBsYWJlbCwgc2l6ZSwgc2NhbGUsIGljb24sIGFuY2hvciB9ID0gbWFya2VyO1xuICAgICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgc3R5bGUga2V5IGJhc2VkIG9uIGVpdGhlciBpY29uIHByb3BlcnRpZXMgb3Igc3RhbmRhcmQgbWFya2VyIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgcmVsZXZhbnRQcm9wcyA9IGljb24gPyBbaWNvbiwgYW5jaG9yLCBzY2FsZV0gOiBbY29sb3IsIGxhYmVsLCBzaXplXTtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVsZXZhbnRQcm9wcy5maWx0ZXIoQm9vbGVhbikuam9pbignLScpO1xuICAgICAgICBzdHlsZXNba2V5XSA9IHN0eWxlc1trZXldIHx8IFtdO1xuICAgICAgICBzdHlsZXNba2V5XS5wdXNoKG1hcmtlcik7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSwge30pO1xuICAgIE9iamVjdC52YWx1ZXMobWFya2Vyc0J5U3R5bGUgIT09IG51bGwgJiYgbWFya2Vyc0J5U3R5bGUgIT09IHZvaWQgMCA/IG1hcmtlcnNCeVN0eWxlIDoge30pLmZvckVhY2gobWFya2VycyA9PiB7XG4gICAgICAgIGxldCBtYXJrZXJQYXJhbSA9ICcnO1xuICAgICAgICBjb25zdCB7IGljb24gfSA9IG1hcmtlcnNbMF07XG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZXIgc3R5bGUgZnJvbSBmaXJzdCBtYXJrZXIgaW4gZ3JvdXAgc2luY2UgYWxsIG1hcmtlcnMgc2hhcmUgdGhlIHNhbWUgc3R5bGUuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1hcmtlcnNbMF0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHByb3BlcnRpZXMgdG8gaW5jbHVkZSBiYXNlZCBvbiB3aGV0aGVyIG1hcmtlciB1c2VzIGN1c3RvbSBpY29uXG4gICAgICAgICAgICBjb25zdCByZWxldmFudEtleXMgPSBpY29uXG4gICAgICAgICAgICAgICAgPyBbJ2ljb24nLCAnYW5jaG9yJywgJ3NjYWxlJ11cbiAgICAgICAgICAgICAgICA6IFsnY29sb3InLCAnbGFiZWwnLCAnc2l6ZSddO1xuICAgICAgICAgICAgaWYgKHJlbGV2YW50S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyUGFyYW0gKz0gYHwke2tleX06JHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIGxvY2F0aW9uIGNvb3JkaW5hdGVzIGZvciBlYWNoIG1hcmtlciBpbiB0aGUgc3R5bGUgZ3JvdXBcbiAgICAgICAgLy8gSGFuZGxlcyBib3RoIHN0cmluZyBsb2NhdGlvbnMgYW5kIGxhdC9sbmcgb2JqZWN0IGZvcm1hdHMuXG4gICAgICAgIGZvciAoY29uc3QgbWFya2VyIG9mIG1hcmtlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdHlwZW9mIG1hcmtlci5sb2NhdGlvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IG1hcmtlci5sb2NhdGlvblxuICAgICAgICAgICAgICAgIDogYCR7bWFya2VyLmxvY2F0aW9uLmxhdH0sJHttYXJrZXIubG9jYXRpb24ubG5nfWA7XG4gICAgICAgICAgICBtYXJrZXJQYXJhbSArPSBgfCR7bG9jYXRpb259YDtcbiAgICAgICAgfVxuICAgICAgICBtYXJrZXJQYXJhbXMucHVzaChtYXJrZXJQYXJhbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmtlclBhcmFtcy5tYXAoZm9ybWF0UGFyYW0pO1xufVxuXG4vLyBTdHlsZSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gcGF0aHMgaW4gdGhlIFN0YXRpYyBNYXBzIEFQSVxuY29uc3QgUEFUSF9TVFlMRV9LRVlTID0gWydjb2xvcicsICd3ZWlnaHQnLCAnZmlsbGNvbG9yJywgJ2dlb2Rlc2ljJ107XG4vKipcbiAqIEJ1aWxkcyB0aGUgc3R5bGUgcG9ydGlvbiBvZiBhIHBhdGggcGFyYW1ldGVyIHN0cmluZy5cbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggb2JqZWN0IGNvbnRhaW5pbmcgc3R5bGUgcHJvcGVydGllc1xuICogQHJldHVybnMgQSBzdHJpbmcgd2l0aCBzdHlsZSBwYXJhbWV0ZXJzIGluIHRoZSBmb3JtYXQgXCJ8a2V5OnZhbHVlXCJcbiAqL1xuZnVuY3Rpb24gYnVpbGRTdHlsZVBhcmFtcyhwYXRoKSB7XG4gICAgbGV0IHN0eWxlUGFyYW1zID0gJyc7XG4gICAgUEFUSF9TVFlMRV9LRVlTLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKHBhdGhba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHlsZVBhcmFtcyArPSBgfCR7a2V5fToke3BhdGhba2V5XX1gO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlUGFyYW1zO1xufVxuLyoqXG4gKiBCdWlsZHMgdGhlIGNvb3JkaW5hdGVzIHBvcnRpb24gb2YgYSBwYXRoIHBhcmFtZXRlciBzdHJpbmcuXG4gKiBAcGFyYW0gY29vcmRpbmF0ZXMgLSBFaXRoZXIgYSBzdHJpbmcgb3IgYXJyYXkgb2YgbG9jYXRpb24gb2JqZWN0c1xuICogQHJldHVybnMgQSBzdHJpbmcgd2l0aCBjb29yZGluYXRlcyBpbiB0aGUgZm9ybWF0IFwifGxhdCxsbmd8bGF0LGxuZ1wiXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ29vcmRpbmF0ZVBhcmFtcyhjb29yZGluYXRlcykge1xuICAgIGlmICh0eXBlb2YgY29vcmRpbmF0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgfCR7ZGVjb2RlVVJJQ29tcG9uZW50KGNvb3JkaW5hdGVzKX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZXMubWFwKGxvY2F0aW9uID0+IGB8JHtmb3JtYXRMb2NhdGlvbihsb2NhdGlvbil9YCkuam9pbignJyk7XG59XG4vKipcbiAqIEFzc2VtYmxlcyBwYXRoIHBhcmFtZXRlcnMgZm9yIHRoZSBTdGF0aWMgTWFwcyBBUEkgZnJvbSBhbiBhcnJheSBvZiBwYXRocy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbnN0cnVjdHMgYSBzdHJpbmcgb2YgcGF0aCBwYXJhbWV0ZXJzIGZvciBlYWNoIHBhdGguIEVhY2ggcGF0aCBwYXJhbWV0ZXIgc3RyaW5nXG4gKiBpbmNsdWRlcyB0aGUgc3R5bGUgcHJvcGVydGllcyBhbmQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXRocy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFN0YXRpY01hcHNQYXRoPn0gW3BhdGhzPVtdXSAtIEFuIGFycmF5IG9mIHBhdGhzIHRvIGJlIGFzc2VtYmxlZCBpbnRvIHBhdGggcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBBbiBhcnJheSBvZiBwYXRoIHBhcmFtZXRlciBzdHJpbmdzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwYXRocyA9IFtcbiAqICAge1xuICogICAgIGNvbG9yOiAncmVkJyxcbiAqICAgICB3ZWlnaHQ6IDUsXG4gKiAgICAgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgIHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9LFxuICogICAgICAgeyBsYXQ6IDQwLjcxODIxNywgbG5nOiAtNzMuOTk4Mjg0IH1cbiAqICAgICBdXG4gKiAgIH1cbiAqIF07XG4gKlxuICogY29uc3QgcGF0aFBhcmFtcyA9IGFzc2VtYmxlUGF0aFBhcmFtcyhwYXRocyk7XG4gKiAvLyBPdXRwdXQ6IFsnY29sb3I6cmVkfHdlaWdodDo1fDQwLjcxNDcyOCwtNzMuOTk4NjcyfDQwLjcxODIxNywtNzMuOTk4Mjg0J11cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhc3NlbWJsZVBhdGhQYXJhbXMocGF0aHMgPSBbXSkge1xuICAgIHJldHVybiBwYXRocy5tYXAocGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IHN0eWxlUGFyYW1zID0gYnVpbGRTdHlsZVBhcmFtcyhwYXRoKTtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZVBhcmFtcyA9IGJ1aWxkQ29vcmRpbmF0ZVBhcmFtcyhwYXRoLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgY29uc3QgcGF0aFBhcmFtID0gc3R5bGVQYXJhbXMgKyBjb29yZGluYXRlUGFyYW1zO1xuICAgICAgICByZXR1cm4gZm9ybWF0UGFyYW0ocGF0aFBhcmFtKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBHb29nbGUgTWFwcyBzdHlsZSBvYmplY3RzIGludG8gYW4gYXJyYXkgb2Ygc3R5bGUgc3RyaW5nc1xuICogY29tcGF0aWJsZSB3aXRoIHRoZSBHb29nbGUgU3RhdGljIE1hcHMgQVBJLlxuICpcbiAqIEBwYXJhbSBzdHlsZXMgLSBBbiBhcnJheSBvZiBHb29nbGUgTWFwcyBNYXBUeXBlU3R5bGUgb2JqZWN0cyB0aGF0IGRlZmluZSB0aGUgc3R5bGluZyBydWxlc1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgZm9ybWF0dGVkIHN0eWxlIHN0cmluZ3MgcmVhZHkgdG8gYmUgdXNlZCB3aXRoIHRoZSBTdGF0aWMgTWFwcyBBUElcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc3R5bGVzID0gW3tcbiAqICAgZmVhdHVyZVR5cGU6IFwicm9hZFwiLFxuICogICBlbGVtZW50VHlwZTogXCJnZW9tZXRyeVwiLFxuICogICBzdHlsZXJzOiBbe2NvbG9yOiBcIiNmZjAwMDBcIn0sIHt3ZWlnaHQ6IDF9XVxuICogfV07XG4gKlxuICogY29uc3Qgc3R5bGVTdHJpbmdzID0gYXNzZW1ibGVNYXBUeXBlU3R5bGVzKHN0eWxlcyk7XG4gKiAvLyBSZXR1cm5zOiBbXCJ8ZmVhdHVyZTpyb2FkfGVsZW1lbnQ6Z2VvbWV0cnl8Y29sb3I6MHhmZjAwMDB8d2VpZ2h0OjFcIl1cbiAqXG4gKiBFYWNoIHN0eWxlIHN0cmluZyBmb2xsb3dzIHRoZSBmb3JtYXQ6XG4gKiBcImZlYXR1cmU6e2ZlYXR1cmVUeXBlfXxlbGVtZW50OntlbGVtZW50VHlwZX18e3N0eWxlck5hbWV9OntzdHlsZXJWYWx1ZX1cIlxuICpcbiAqIE5vdGU6IENvbG9yIHZhbHVlcyB3aXRoIGhleGFkZWNpbWFsIG5vdGF0aW9uICgjKSBhcmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWRcbiAqIHRvIHRoZSByZXF1aXJlZCAweCBmb3JtYXQgZm9yIHRoZSBTdGF0aWMgTWFwcyBBUEkuXG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZXMpIHtcbiAgICByZXR1cm4gc3R5bGVzXG4gICAgICAgIC5tYXAoKG1hcFR5cGVTdHlsZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGZlYXR1cmVUeXBlLCBlbGVtZW50VHlwZSwgc3R5bGVycyA9IFtdIH0gPSBtYXBUeXBlU3R5bGU7XG4gICAgICAgIGxldCBzdHlsZVN0cmluZyA9ICcnO1xuICAgICAgICBpZiAoZmVhdHVyZVR5cGUpIHtcbiAgICAgICAgICAgIHN0eWxlU3RyaW5nICs9IGB8ZmVhdHVyZToke2ZlYXR1cmVUeXBlfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICBzdHlsZVN0cmluZyArPSBgfGVsZW1lbnQ6JHtlbGVtZW50VHlwZX1gO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGVyIG9mIHN0eWxlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHN0eWxlcikuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHN0eWxlU3RyaW5nICs9IGB8JHtuYW1lfToke1N0cmluZyh2YWx1ZSkucmVwbGFjZSgnIycsICcweCcpfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVTdHJpbmc7XG4gICAgfSlcbiAgICAgICAgLm1hcChmb3JtYXRQYXJhbSk7XG59XG5cbmNvbnN0IFNUQVRJQ19NQVBTX0JBU0UgPSAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL3N0YXRpY21hcCc7XG4vKipcbiAqIENyZWF0ZXMgYSBVUkwgZm9yIHRoZSBHb29nbGUgU3RhdGljIE1hcHMgQVBJIHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHN0YXRpYyBtYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmFwaUtleSAtIFlvdXIgR29vZ2xlIE1hcHMgQVBJIGtleSAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgbWFwIGltYWdlIGluIHBpeGVscyAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5oZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBtYXAgaW1hZ2UgaW4gcGl4ZWxzIChyZXF1aXJlZClcbiAqIEBwYXJhbSB7U3RhdGljTWFwc0xvY2F0aW9ufSBbb3B0aW9ucy5jZW50ZXJdIC0gVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgbWFwIChsYXQvbG5nIG9yIGFkZHJlc3MpLlxuICogIFJlcXVpcmVkIGlmIG5vIG1hcmtlcnMgb3IgcGF0aHMgb3IgXCJ2aXNpYmxlIGxvY2F0aW9uc1wiIGFyZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy56b29tXSAtIFRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIFJlcXVpcmVkIGlmIG5vIG1hcmtlcnMgb3IgcGF0aHMgb3IgXCJ2aXNpYmxlIGxvY2F0aW9uc1wiIGFyZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7MXwyfDR9IFtvcHRpb25zLnNjYWxlXSAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBtYXAgKDEsIDIsIG9yIDQpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9ybWF0XSAtIFRoZSBpbWFnZSBmb3JtYXQgKHBuZywgcG5nOCwgcG5nMzIsIGdpZiwganBnLCBqcGctYmFzZWxpbmUpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFwVHlwZV0gLSBUaGUgdHlwZSBvZiBtYXAgKHJvYWRtYXAsIHNhdGVsbGl0ZSwgdGVycmFpbiwgaHlicmlkKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXSAtIFRoZSBsYW5ndWFnZSBvZiB0aGUgbWFwIGxhYmVsc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlZ2lvbl0gLSBUaGUgcmVnaW9uIGNvZGUgZm9yIHRoZSBtYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXBfaWRdIC0gVGhlIENsb3VkLWJhc2VkIG1hcCBzdHlsZSBJRFxuICogQHBhcmFtIHtTdGF0aWNNYXBzTWFya2VyW119IFtvcHRpb25zLm1hcmtlcnM9W11dIC0gQXJyYXkgb2YgbWFya2VycyB0byBkaXNwbGF5IG9uIHRoZSBtYXBcbiAqIEBwYXJhbSB7U3RhdGljTWFwc1BhdGhbXX0gW29wdGlvbnMucGF0aHM9W11dIC0gQXJyYXkgb2YgcGF0aHMgdG8gZGlzcGxheSBvbiB0aGUgbWFwXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNMb2NhdGlvbltdfSBbb3B0aW9ucy52aXNpYmxlPVtdXSAtIEFycmF5IG9mIGxvY2F0aW9ucyB0aGF0IHNob3VsZCBiZSB2aXNpYmxlIG9uIHRoZSBtYXBcbiAqIEBwYXJhbSB7TWFwVHlwZVN0eWxlW119IFtvcHRpb25zLnN0eWxlPVtdXSAtIEFycmF5IG9mIHN0eWxlIG9iamVjdHMgdG8gY3VzdG9taXplIHRoZSBtYXAgYXBwZWFyYW5jZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21wbGV0ZSBHb29nbGUgU3RhdGljIE1hcHMgQVBJIFVSTFxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBBUEkga2V5IGlzIG5vdCBwcm92aWRlZFxuICogQHRocm93cyB7RXJyb3J9IElmIHdpZHRoIG9yIGhlaWdodCBpcyBub3QgcHJvdmlkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdXJsID0gY3JlYXRlU3RhdGljTWFwc1VybCh7XG4gKiAgIGFwaUtleTogJ1lPVVJfQVBJX0tFWScsXG4gKiAgIHdpZHRoOiA2MDAsXG4gKiAgIGhlaWdodDogNDAwLFxuICogICBjZW50ZXI6IHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9LFxuICogICB6b29tOiAxMixcbiAqICAgbWFya2VyczogW1xuICogICAgIHtcbiAqICAgICAgIGxvY2F0aW9uOiB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgICAgIGNvbG9yOiAncmVkJyxcbiAqICAgICAgIGxhYmVsOiAnQSdcbiAqICAgICB9XG4gKiAgIF0sXG4gKiAgIHBhdGhzOiBbXG4gKiAgICAge1xuICogICAgICAgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgICAgeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0sXG4gKiAgICAgICAgIHsgbGF0OiA0MC43MTk3MjgsIGxuZzogLTczLjk5MTY3MiB9XG4gKiAgICAgICBdLFxuICogICAgICAgY29sb3I6ICcweDAwMDBmZicsXG4gKiAgICAgICB3ZWlnaHQ6IDVcbiAqICAgICB9XG4gKiAgIF0sXG4gKiAgIHN0eWxlOiBbXG4gKiAgICAge1xuICogICAgICAgZmVhdHVyZVR5cGU6ICdyb2FkJyxcbiAqICAgICAgIGVsZW1lbnRUeXBlOiAnZ2VvbWV0cnknLFxuICogICAgICAgc3R5bGVyczogW3tjb2xvcjogJyMwMGZmMDAnfV1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH0pO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gVVJMIHNpbWlsYXIgdG86XG4gKiAvLyBodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvc3RhdGljbWFwP2tleT1ZT1VSX0FQSV9LRVlcbiAqIC8vICZzaXplPTYwMHg0MDBcbiAqIC8vICZjZW50ZXI9NDAuNzE0NzI4LC03My45OTg2NzImem9vbT0xMlxuICogLy8gJm1hcmtlcnM9Y29sb3I6cmVkfGxhYmVsOkF8NDAuNzE0NzI4LC03My45OTg2NzJcbiAqIC8vICZwYXRoPWNvbG9yOjB4MDAwMGZmfHdlaWdodDo1fDQwLjcxNDcyOCwtNzMuOTk4NjcyfDQwLjcxOTcyOCwtNzMuOTkxNjcyXG4gKiAvLyAmc3R5bGU9ZmVhdHVyZTpyb2FkfGVsZW1lbnQ6Z2VvbWV0cnl8Y29sb3I6MHgwMGZmMDBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljTWFwc1VybCh7IGFwaUtleSwgd2lkdGgsIGhlaWdodCwgY2VudGVyLCB6b29tLCBzY2FsZSwgZm9ybWF0LCBtYXBUeXBlLCBsYW5ndWFnZSwgcmVnaW9uLCBtYXBJZCwgbWFya2VycyA9IFtdLCBwYXRocyA9IFtdLCB2aXNpYmxlID0gW10sIHN0eWxlID0gW10gfSkge1xuICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQVBJIGtleSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXaWR0aCBhbmQgaGVpZ2h0IGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBrZXk6IGFwaUtleSwgc2l6ZTogYCR7d2lkdGh9eCR7aGVpZ2h0fWAgfSwgKGNlbnRlciAmJiB7IGNlbnRlcjogZm9ybWF0TG9jYXRpb24oY2VudGVyKSB9KSksICh6b29tICYmIHsgem9vbSB9KSksIChzY2FsZSAmJiB7IHNjYWxlIH0pKSwgKGZvcm1hdCAmJiB7IGZvcm1hdCB9KSksIChtYXBUeXBlICYmIHsgbWFwdHlwZTogbWFwVHlwZSB9KSksIChsYW5ndWFnZSAmJiB7IGxhbmd1YWdlIH0pKSwgKHJlZ2lvbiAmJiB7IHJlZ2lvbiB9KSksIChtYXBJZCAmJiB7IG1hcF9pZDogbWFwSWQgfSkpO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoU1RBVElDX01BUFNfQkFTRSk7XG4gICAgLy8gUGFyYW1zIHRoYXQgZG9uJ3QgbmVlZCBzcGVjaWFsIGhhbmRsaW5nXG4gICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICB9KTtcbiAgICAvLyBBc3NlbWJsZSBNYXJrZXJzXG4gICAgZm9yIChjb25zdCBtYXJrZXJQYXJhbSBvZiBhc3NlbWJsZU1hcmtlclBhcmFtcyhtYXJrZXJzKSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnbWFya2VycycsIG1hcmtlclBhcmFtKTtcbiAgICB9XG4gICAgLy8gQXNzZW1ibGUgUGF0aHNcbiAgICBmb3IgKGNvbnN0IHBhdGhQYXJhbSBvZiBhc3NlbWJsZVBhdGhQYXJhbXMocGF0aHMpKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdwYXRoJywgcGF0aFBhcmFtKTtcbiAgICB9XG4gICAgLy8gQXNzZW1ibGUgdmlzaWJsZSBsb2NhdGlvbnNcbiAgICBpZiAodmlzaWJsZS5sZW5ndGgpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3Zpc2libGUnLCB2aXNpYmxlLm1hcChsb2NhdGlvbiA9PiBmb3JtYXRMb2NhdGlvbihsb2NhdGlvbikpLmpvaW4oJ3wnKSk7XG4gICAgfVxuICAgIC8vIEFzc2VtYmxlIE1hcCBUeXBlIFN0eWxlc1xuICAgIGZvciAoY29uc3Qgc3R5bGVTdHJpbmcgb2YgYXNzZW1ibGVNYXBUeXBlU3R5bGVzKHN0eWxlKSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3R5bGUnLCBzdHlsZVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuY29uc3QgU3RhdGljTWFwID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB1cmwsIGNsYXNzTmFtZSB9ID0gcHJvcHM7XG4gICAgaWYgKCF1cmwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVVJMIGlzIHJlcXVpcmVkJyk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3JjOiB1cmwsIHdpZHRoOiBcIjEwMCVcIiB9KTtcbn07XG5cbi8qKlxuICogQ29weSBvZiB0aGUgYGdvb2dsZS5tYXBzLkNvbnRyb2xQb3NpdGlvbmAgY29uc3RhbnRzLlxuICogVGhleSBoYXZlIHRvIGJlIGR1cGxpY2F0ZWQgaGVyZSBzaW5jZSB3ZSBjYW4ndCB3YWl0IGZvciB0aGUgbWFwcyBBUEkgdG8gbG9hZCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtLlxuICovXG5jb25zdCBDb250cm9sUG9zaXRpb24gPSB7XG4gICAgVE9QX0xFRlQ6IDEsXG4gICAgVE9QX0NFTlRFUjogMixcbiAgICBUT1A6IDIsXG4gICAgVE9QX1JJR0hUOiAzLFxuICAgIExFRlRfQ0VOVEVSOiA0LFxuICAgIExFRlRfVE9QOiA1LFxuICAgIExFRlQ6IDUsXG4gICAgTEVGVF9CT1RUT006IDYsXG4gICAgUklHSFRfVE9QOiA3LFxuICAgIFJJR0hUOiA3LFxuICAgIFJJR0hUX0NFTlRFUjogOCxcbiAgICBSSUdIVF9CT1RUT006IDksXG4gICAgQk9UVE9NX0xFRlQ6IDEwLFxuICAgIEJPVFRPTV9DRU5URVI6IDExLFxuICAgIEJPVFRPTTogMTEsXG4gICAgQk9UVE9NX1JJR0hUOiAxMixcbiAgICBDRU5URVI6IDEzLFxuICAgIEJMT0NLX1NUQVJUX0lOTElORV9TVEFSVDogMTQsXG4gICAgQkxPQ0tfU1RBUlRfSU5MSU5FX0NFTlRFUjogMTUsXG4gICAgQkxPQ0tfU1RBUlRfSU5MSU5FX0VORDogMTYsXG4gICAgSU5MSU5FX1NUQVJUX0JMT0NLX0NFTlRFUjogMTcsXG4gICAgSU5MSU5FX1NUQVJUX0JMT0NLX1NUQVJUOiAxOCxcbiAgICBJTkxJTkVfU1RBUlRfQkxPQ0tfRU5EOiAxOSxcbiAgICBJTkxJTkVfRU5EX0JMT0NLX1NUQVJUOiAyMCxcbiAgICBJTkxJTkVfRU5EX0JMT0NLX0NFTlRFUjogMjEsXG4gICAgSU5MSU5FX0VORF9CTE9DS19FTkQ6IDIyLFxuICAgIEJMT0NLX0VORF9JTkxJTkVfU1RBUlQ6IDIzLFxuICAgIEJMT0NLX0VORF9JTkxJTkVfQ0VOVEVSOiAyNCxcbiAgICBCTE9DS19FTkRfSU5MSU5FX0VORDogMjVcbn07XG5jb25zdCBNYXBDb250cm9sID0gKHsgY2hpbGRyZW4sIHBvc2l0aW9uIH0pID0+IHtcbiAgICBjb25zdCBjb250cm9sQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICAgIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb250cm9scyA9IG1hcC5jb250cm9sc1twb3NpdGlvbl07XG4gICAgICAgIGNvbnRyb2xzLnB1c2goY29udHJvbENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sc0FycmF5ID0gY29udHJvbHMuZ2V0QXJyYXkoKTtcbiAgICAgICAgICAgIC8vIGNvbnRyb2xzQXJyYXkgY291bGQgYmUgdW5kZWZpbmVkIGlmIHRoZSBtYXAgaXMgaW4gYW4gdW5kZWZpbmVkIHN0YXRlIChlLmcuIGludmFsaWQgQVBJLWtleSwgc2VlICMyNzZcbiAgICAgICAgICAgIGlmICghY29udHJvbHNBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRyb2xzQXJyYXkuaW5kZXhPZihjb250cm9sQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnRyb2xzLnJlbW92ZUF0KGluZGV4KTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29udHJvbENvbnRhaW5lciwgbWFwLCBwb3NpdGlvbl0pO1xuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRyb2xDb250YWluZXIpO1xufTtcblxuZnVuY3Rpb24gdXNlTWFya2VyKHByb3BzKSB7XG4gICAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICAgIGNvbnN0IHsgb25DbGljaywgb25EcmFnLCBvbkRyYWdTdGFydCwgb25EcmFnRW5kLCBvbk1vdXNlT3Zlciwgb25Nb3VzZU91dCB9ID0gcHJvcHMsIG1hcmtlck9wdGlvbnMgPSBfX3Jlc3QocHJvcHMsIFtcIm9uQ2xpY2tcIiwgXCJvbkRyYWdcIiwgXCJvbkRyYWdTdGFydFwiLCBcIm9uRHJhZ0VuZFwiLCBcIm9uTW91c2VPdmVyXCIsIFwib25Nb3VzZU91dFwiXSk7XG4gICAgY29uc3QgeyBwb3NpdGlvbiwgZHJhZ2dhYmxlIH0gPSBtYXJrZXJPcHRpb25zO1xuICAgIC8vIGNyZWF0ZSBtYXJrZXIgaW5zdGFuY2UgYW5kIGFkZCB0byB0aGUgbWFwIG9uY2UgdGhlIG1hcCBpcyBhdmFpbGFibGVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgaWYgKG1hcCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJzxNYXJrZXI+IGhhcyB0byBiZSBpbnNpZGUgYSBNYXAgY29tcG9uZW50LicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld01hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIobWFya2VyT3B0aW9ucyk7XG4gICAgICAgIG5ld01hcmtlci5zZXRNYXAobWFwKTtcbiAgICAgICAgc2V0TWFya2VyKG5ld01hcmtlcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBuZXdNYXJrZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgc2V0TWFya2VyKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byByZS1yZW5kZXIgdGhlIHdob2xlIG1hcmtlciB3aGVuIHRoZSBvcHRpb25zIGNoYW5nZS5cbiAgICAgICAgLy8gTWFya2VyIG9wdGlvbnMgdXBkYXRlIGlzIGhhbmRsZWQgaW4gYSB1c2VFZmZlY3QgYmVsb3cuXG4gICAgICAgIC8vIEV4Y2x1ZGluZyBtYXJrZXJPcHRpb25zIGZyb20gZGVwZW5kZW5jeSBhcnJheSBvbiBwdXJwb3NlIGhlcmUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbbWFwXSk7XG4gICAgLy8gYXR0YWNoIGFuZCByZS1hdHRhY2ggZXZlbnQtaGFuZGxlcnMgd2hlbiBhbnkgb2YgdGhlIHByb3BlcnRpZXMgY2hhbmdlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG0gPSBtYXJrZXI7XG4gICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgY29uc3QgZ21lID0gZ29vZ2xlLm1hcHMuZXZlbnQ7XG4gICAgICAgIGlmIChvbkNsaWNrKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdjbGljaycsIG9uQ2xpY2spO1xuICAgICAgICBpZiAob25EcmFnKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnJywgb25EcmFnKTtcbiAgICAgICAgaWYgKG9uRHJhZ1N0YXJ0KVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCk7XG4gICAgICAgIGlmIChvbkRyYWdFbmQpXG4gICAgICAgICAgICBnbWUuYWRkTGlzdGVuZXIobSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpO1xuICAgICAgICBpZiAob25Nb3VzZU92ZXIpXG4gICAgICAgICAgICBnbWUuYWRkTGlzdGVuZXIobSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKTtcbiAgICAgICAgaWYgKG9uTW91c2VPdXQpXG4gICAgICAgICAgICBnbWUuYWRkTGlzdGVuZXIobSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCk7XG4gICAgICAgIG1hcmtlci5zZXREcmFnZ2FibGUoQm9vbGVhbihkcmFnZ2FibGUpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGdtZS5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG0pO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgbWFya2VyLFxuICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIG9uQ2xpY2ssXG4gICAgICAgIG9uRHJhZyxcbiAgICAgICAgb25EcmFnU3RhcnQsXG4gICAgICAgIG9uRHJhZ0VuZCxcbiAgICAgICAgb25Nb3VzZU92ZXIsXG4gICAgICAgIG9uTW91c2VPdXRcbiAgICBdKTtcbiAgICAvLyB1cGRhdGUgbWFya2VyT3B0aW9ucyAobm90ZSB0aGUgZGVwZW5kZW5jaWVzIGFyZW4ndCBwcm9wZXJseSBjaGVja2VkXG4gICAgLy8gaGVyZSwgd2UganVzdCBhc3N1bWUgdGhhdCBzZXRPcHRpb25zIGlzIHNtYXJ0IGVub3VnaCB0byBub3Qgd2FzdGUgYVxuICAgIC8vIGxvdCBvZiB0aW1lIHVwZGF0aW5nIHZhbHVlcyB0aGF0IGRpZG4ndCBjaGFuZ2UpXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zKVxuICAgICAgICAgICAgbWFya2VyLnNldE9wdGlvbnMobWFya2VyT3B0aW9ucyk7XG4gICAgfSwgW21hcmtlciwgbWFya2VyT3B0aW9uc10pO1xuICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiB3aGVuIGNoYW5nZWRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBTaG91bGQgbm90IHVwZGF0ZSBwb3NpdGlvbiB3aGVuIGRyYWdnYWJsZVxuICAgICAgICBpZiAoZHJhZ2dhYmxlIHx8ICFwb3NpdGlvbiB8fCAhbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYXJrZXIuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH0sIFtkcmFnZ2FibGUsIHBvc2l0aW9uLCBtYXJrZXJdKTtcbiAgICByZXR1cm4gbWFya2VyO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gcmVuZGVyIGEgbWFya2VyIG9uIGEgbWFwXG4gKi9cbmNvbnN0IE1hcmtlciA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCBtYXJrZXIgPSB1c2VNYXJrZXIocHJvcHMpO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBtYXJrZXIsIFttYXJrZXJdKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCk7XG59KTtcbk1hcmtlci5kaXNwbGF5TmFtZSA9ICdNYXJrZXInO1xuZnVuY3Rpb24gdXNlTWFya2VyUmVmKCkge1xuICAgIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCByZWZDYWxsYmFjayA9IHVzZUNhbGxiYWNrKChtKSA9PiB7XG4gICAgICAgIHNldE1hcmtlcihtKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtyZWZDYWxsYmFjaywgbWFya2VyXTtcbn1cblxuLyoqXG4gKiBDb21wb25lbnQgdG8gY29uZmlndXJlIHRoZSBhcHBlYXJhbmNlIG9mIGFuIEFkdmFuY2VkTWFya2VyXG4gKi9cbmNvbnN0IFBpbiA9IHByb3BzID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWR2YW5jZWRNYXJrZXIgPSAoX2EgPSB1c2VDb250ZXh0KEFkdmFuY2VkTWFya2VyQ29udGV4dCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrZXI7XG4gICAgY29uc3QgZ2x5cGhDb250YWluZXIgPSB1c2VNZW1vKCgpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBbXSk7XG4gICAgLy8gQ3JlYXRlIFBpbiBWaWV3IGluc3RhbmNlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWFkdmFuY2VkTWFya2VyKSB7XG4gICAgICAgICAgICBpZiAoYWR2YW5jZWRNYXJrZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSA8UGluPiBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgPEFkdmFuY2VkTWFya2VyPi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuZ2x5cGggJiYgcHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yT25jZSgnVGhlIDxQaW4+IGNvbXBvbmVudCBvbmx5IHVzZXMgY2hpbGRyZW4gdG8gcmVuZGVyIHRoZSBnbHlwaCBpZiBib3RoIHRoZSBnbHlwaCBwcm9wZXJ0eSBhbmQgY2hpbGRyZW4gYXJlIHByZXNlbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDEpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yT25jZSgnUGFzc2luZyBtdWx0aXBsZSBjaGlsZHJlbiB0byB0aGUgPFBpbj4gY29tcG9uZW50IG1pZ2h0IGxlYWQgdG8gdW5leHBlY3RlZCByZXN1bHRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBpblZpZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpO1xuICAgICAgICBjb25zdCBwaW5FbGVtZW50ID0gbmV3IGdvb2dsZS5tYXBzLm1hcmtlci5QaW5FbGVtZW50KHBpblZpZXdPcHRpb25zKTtcbiAgICAgICAgLy8gU2V0IGdseXBoIHRvIGdseXBoIGNvbnRhaW5lciBpZiBjaGlsZHJlbiBhcmUgcHJlc2VudCAocmVuZGVyZWQgdmlhIHBvcnRhbCkuXG4gICAgICAgIC8vIElmIGJvdGggcHJvcHMuZ2x5cGggYW5kIHByb3BzLmNoaWxkcmVuIGFyZSBwcmVzZW50LCBwcm9wcy5jaGlsZHJlbiB0YWtlcyBwcmlvcml0eS5cbiAgICAgICAgaWYgKHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBwaW5FbGVtZW50LmdseXBoID0gZ2x5cGhDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGNvbnRlbnQgb2YgQWR2YW5jZWQgTWFya2VyIFZpZXcgdG8gdGhlIFBpbiBWaWV3IGVsZW1lbnRcbiAgICAgICAgLy8gSGVyZSB3ZSBhcmUgc2VsZWN0aW5nIHRoZSBhbmNob3IgY29udGFpbmVyLlxuICAgICAgICAvLyBUaGUgaGllcmFyY2h5IGlzIGFzIGZvbGxvd3M6XG4gICAgICAgIC8vIFwiYWR2YW5jZWRNYXJrZXIuY29udGVudFwiIChmcm9tIGdvb2dsZSkgLT4gXCJhbmNob3IgY29udGFpbmVyXCJcbiAgICAgICAgY29uc3QgbWFya2VyQ29udGVudCA9IChfYSA9IGFkdmFuY2VkTWFya2VyLmNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAobWFya2VyQ29udGVudCA9PT0gbnVsbCB8fCBtYXJrZXJDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJDb250ZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIG1hcmtlckNvbnRlbnQucmVtb3ZlQ2hpbGQobWFya2VyQ29udGVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyQ29udGVudCkge1xuICAgICAgICAgICAgbWFya2VyQ29udGVudC5hcHBlbmRDaGlsZChwaW5FbGVtZW50LmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSwgW2FkdmFuY2VkTWFya2VyLCBnbHlwaENvbnRhaW5lciwgcHJvcHNdKTtcbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKHByb3BzLmNoaWxkcmVuLCBnbHlwaENvbnRhaW5lcik7XG59O1xuXG5jb25zdCBtYXBMaW5lYXIgPSAoeCwgYTEsIGEyLCBiMSwgYjIpID0+IGIxICsgKCh4IC0gYTEpICogKGIyIC0gYjEpKSAvIChhMiAtIGExKTtcbmNvbnN0IGdldE1hcE1heFRpbHQgPSAoem9vbSkgPT4ge1xuICAgIGlmICh6b29tIDw9IDEwKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9XG4gICAgaWYgKHpvb20gPj0gMTUuNSkge1xuICAgICAgICByZXR1cm4gNjcuNTtcbiAgICB9XG4gICAgLy8gcmFuZ2UgWzEwLi4uMTRdXG4gICAgaWYgKHpvb20gPD0gMTQpIHtcbiAgICAgICAgcmV0dXJuIG1hcExpbmVhcih6b29tLCAxMCwgMTQsIDMwLCA0NSk7XG4gICAgfVxuICAgIC8vIHJhbmdlIFsxNC4uLjE1LjVdXG4gICAgcmV0dXJuIG1hcExpbmVhcih6b29tLCAxNCwgMTUuNSwgNDUsIDY3LjUpO1xufTtcbi8qKlxuICogRnVuY3Rpb24gdG8gbGltaXQgdGhlIHRpbHQgcmFuZ2Ugb2YgdGhlIEdvb2dsZSBtYXAgd2hlbiB1cGRhdGluZyB0aGUgdmlldyBzdGF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgbGltaXRUaWx0UmFuZ2UgPSAoeyB2aWV3U3RhdGUgfSkgPT4ge1xuICAgIGNvbnN0IHBpdGNoID0gdmlld1N0YXRlLnBpdGNoO1xuICAgIGNvbnN0IGdtWm9vbSA9IHZpZXdTdGF0ZS56b29tICsgMTtcbiAgICBjb25zdCBtYXhUaWx0ID0gZ2V0TWFwTWF4VGlsdChnbVpvb20pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZXdTdGF0ZSksIHsgZm92eTogMjUsIHBpdGNoOiBNYXRoLm1pbihtYXhUaWx0LCBwaXRjaCkgfSk7XG59O1xuXG5leHBvcnQgeyBBUElMb2FkaW5nU3RhdHVzLCBBUElQcm92aWRlciwgQVBJUHJvdmlkZXJDb250ZXh0LCBBZHZhbmNlZE1hcmtlciwgQWR2YW5jZWRNYXJrZXJBbmNob3JQb2ludCwgQWR2YW5jZWRNYXJrZXJDb250ZXh0LCBDb2xsaXNpb25CZWhhdmlvciwgQ29sb3JTY2hlbWUsIENvbnRyb2xQb3NpdGlvbiwgR29vZ2xlTWFwc0NvbnRleHQsIEluZm9XaW5kb3csIE1hcCwgTWFwQ29udHJvbCwgTWFya2VyLCBQaW4sIFJlbmRlcmluZ1R5cGUsIFN0YXRpY01hcCwgVkVSU0lPTiwgY3JlYXRlU3RhdGljTWFwc1VybCwgaXNBZHZhbmNlZE1hcmtlciwgaXNMYXRMbmdMaXRlcmFsLCBsYXRMbmdFcXVhbHMsIGxpbWl0VGlsdFJhbmdlLCB0b0xhdExuZ0xpdGVyYWwsIHVzZUFkdmFuY2VkTWFya2VyUmVmLCB1c2VBcGlJc0xvYWRlZCwgdXNlQXBpTG9hZGluZ1N0YXR1cywgdXNlTWFwLCB1c2VNYXBzTGlicmFyeSwgdXNlTWFya2VyUmVmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTWVtbyIsInVzZVN0YXRlIiwidXNlUmVkdWNlciIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ29udGV4dCIsInVzZUxheW91dEVmZmVjdCIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiQ2hpbGRyZW4iLCJjcmVhdGVQb3J0YWwiLCJpc0RlZXBFcXVhbCIsIlZFUlNJT04iLCJfX3Jlc3QiLCJzIiwiZSIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiU3VwcHJlc3NlZEVycm9yIiwiZXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwibmFtZSIsIkFQSUxvYWRpbmdTdGF0dXMiLCJOT1RfTE9BREVEIiwiTE9BRElORyIsIkxPQURFRCIsIkZBSUxFRCIsIkFVVEhfRkFJTFVSRSIsIk1BUFNfQVBJX0JBU0VfVVJMIiwiR29vZ2xlTWFwc0FwaUxvYWRlciIsImxvYWQiLCJwYXJhbXMiLCJvbkxvYWRpbmdTdGF0dXNDaGFuZ2UiLCJfYSIsIl9iIiwibGlicmFyaWVzIiwic3BsaXQiLCJzZXJpYWxpemVkUGFyYW1zIiwic2VyaWFsaXplUGFyYW1zIiwibGlzdGVuZXJzIiwicHVzaCIsIndpbmRvdyIsImdvb2dsZSIsIm1hcHMiLCJpbXBvcnRMaWJyYXJ5Iiwic2VyaWFsaXplZEFwaVBhcmFtcyIsImxvYWRpbmdTdGF0dXMiLCJub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzIiwiaW5pdEltcG9ydExpYnJhcnkiLCJjb25zb2xlIiwid2FybiIsImxpYnJhcmllc1RvTG9hZCIsImFsbCIsIm1hcCIsInYiLCJrZXkiLCJsYW5ndWFnZSIsInJlZ2lvbiIsImF1dGhSZWZlcnJlclBvbGljeSIsInNvbHV0aW9uQ2hhbm5lbCIsImpvaW4iLCJhcGlQcm9taXNlIiwibG9hZEFwaSIsInNjcmlwdEVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJlbnRyaWVzIiwidXJsUGFyYW1OYW1lIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwic2V0IiwiU3RyaW5nIiwiYXN5bmMiLCJzcmMiLCJ0b1N0cmluZyIsIm5vbmNlIiwicXVlcnlTZWxlY3RvciIsIm9uZXJyb3IiLCJfX2dvb2dsZU1hcHNDYWxsYmFja19fIiwiZ21fYXV0aEZhaWx1cmUiLCJoZWFkIiwiYXBwZW5kIiwibGlicmFyeU5hbWUiLCJmbiIsIkRFRkFVTFRfU09MVVRJT05fQ0hBTk5FTCIsIkRFRkFVTFRfSU5URVJOQUxfVVNBR0VfQVRUUklCVVRJT05fSURTIiwiQVBJUHJvdmlkZXJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZU1hcEluc3RhbmNlcyIsIm1hcEluc3RhbmNlcyIsInNldE1hcEluc3RhbmNlcyIsImFkZE1hcEluc3RhbmNlIiwibWFwSW5zdGFuY2UiLCJpZCIsImluc3RhbmNlcyIsImFzc2lnbiIsInJlbW92ZU1hcEluc3RhbmNlIiwicmVtYWluaW5nIiwiY2xlYXJNYXBJbnN0YW5jZXMiLCJ1c2VHb29nbGVNYXBzQXBpTG9hZGVyIiwicHJvcHMiLCJvbkxvYWQiLCJvbkVycm9yIiwiYXBpS2V5IiwidmVyc2lvbiIsIm90aGVyQXBpUGFyYW1zIiwic3RhdHVzIiwic2V0U3RhdHVzIiwibG9hZGVkTGlicmFyaWVzIiwiYWRkTG9hZGVkTGlicmFyeSIsImFjdGlvbiIsImxpYnJhcmllc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXMiLCJjaGFubmVsIiwidW5kZWZpbmVkIiwidXNlSW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzIiwiaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzIiwiZGlzYWJsZVVzYWdlQXR0cmlidXRpb24iLCJBUElQcm92aWRlciIsImNoaWxkcmVuIiwibG9hZGVyUHJvcHMiLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsInVzZU1hcEV2ZW50cyIsInByb3BOYW1lIiwiZXZlbnRQcm9wTmFtZXMiLCJoYW5kbGVyIiwiZXZlbnRUeXBlIiwicHJvcE5hbWVUb0V2ZW50VHlwZSIsImxpc3RlbmVyIiwiZXZlbnQiLCJhZGRMaXN0ZW5lciIsImV2IiwiY3JlYXRlTWFwRXZlbnQiLCJyZW1vdmUiLCJ0eXBlIiwic3JjRXZlbnQiLCJkZXRhaWwiLCJzdG9wcGFibGUiLCJzdG9wIiwiY2FtZXJhRXZlbnRUeXBlcyIsImluY2x1ZGVzIiwiY2FtRXZlbnQiLCJjZW50ZXIiLCJnZXRDZW50ZXIiLCJ6b29tIiwiZ2V0Wm9vbSIsImhlYWRpbmciLCJnZXRIZWFkaW5nIiwidGlsdCIsImdldFRpbHQiLCJib3VuZHMiLCJnZXRCb3VuZHMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRvSlNPTiIsImxhdCIsImxuZyIsIm5vcnRoIiwiZWFzdCIsInNvdXRoIiwid2VzdCIsIm1vdXNlRXZlbnRUeXBlcyIsIm1vdXNlRXZlbnQiLCJkb21FdmVudCIsImxhdExuZyIsInBsYWNlSWQiLCJvbkJvdW5kc0NoYW5nZWQiLCJvbkNlbnRlckNoYW5nZWQiLCJvbkNsaWNrIiwib25Db250ZXh0bWVudSIsIm9uRGJsY2xpY2siLCJvbkRyYWciLCJvbkRyYWdlbmQiLCJvbkRyYWdzdGFydCIsIm9uSGVhZGluZ0NoYW5nZWQiLCJvbklkbGUiLCJvbklzRnJhY3Rpb25hbFpvb21FbmFibGVkQ2hhbmdlZCIsIm9uTWFwQ2FwYWJpbGl0aWVzQ2hhbmdlZCIsIm9uTWFwVHlwZUlkQ2hhbmdlZCIsIm9uTW91c2Vtb3ZlIiwib25Nb3VzZW91dCIsIm9uTW91c2VvdmVyIiwib25Qcm9qZWN0aW9uQ2hhbmdlZCIsIm9uUmVuZGVyaW5nVHlwZUNoYW5nZWQiLCJvblRpbGVzTG9hZGVkIiwib25UaWx0Q2hhbmdlZCIsIm9uWm9vbUNoYW5nZWQiLCJvbkNhbWVyYUNoYW5nZWQiLCJrZXlzIiwidXNlUHJldmlvdXMiLCJyZWYiLCJjdXJyZW50IiwidXNlTWVtb2l6ZWQiLCJpc0VxdWFsIiwicHJldmlvdXMiLCJ1c2VDdXN0b21Db21wYXJlRWZmZWN0IiwiZWZmZWN0IiwiZGVwZW5kZW5jaWVzIiwidXNlRGVlcENvbXBhcmVFZmZlY3QiLCJtYXBPcHRpb25LZXlzIiwiU2V0IiwidXNlTWFwT3B0aW9ucyIsIm1hcFByb3BzIiwibWFwT3B0aW9ucyIsImhhcyIsInNldE9wdGlvbnMiLCJ1c2VBcGlMb2FkaW5nU3RhdHVzIiwidXNlRGVja0dMQ2FtZXJhVXBkYXRlIiwidmlld3BvcnQiLCJ2aWV3U3RhdGUiLCJpc0RlY2tHbENvbnRyb2xsZWQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImJlYXJpbmciLCJwaXRjaCIsIm1vdmVDYW1lcmEiLCJpc0xhdExuZ0xpdGVyYWwiLCJvYmoiLCJsYXRMbmdFcXVhbHMiLCJhIiwiYiIsIkEiLCJ0b0xhdExuZ0xpdGVyYWwiLCJCIiwidXNlTWFwQ2FtZXJhUGFyYW1zIiwiY2FtZXJhU3RhdGVSZWYiLCJuZXh0Q2FtZXJhIiwibmVlZHNVcGRhdGUiLCJBdXRoRmFpbHVyZU1lc3NhZ2UiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwiekluZGV4IiwiZGlzcGxheSIsImZsZXhGbG93IiwidGV4dEFsaWduIiwianVzdGlmeUNvbnRlbnQiLCJmb250U2l6ZSIsImNvbG9yIiwiYmFja2dyb3VuZCIsInBhZGRpbmciLCJ1c2VDYWxsYmFja1JlZiIsImVsIiwic2V0RWwiLCJ1c2VBcGlJc0xvYWRlZCIsInVzZUZvcmNlVXBkYXRlIiwiZm9yY2VVcGRhdGUiLCJ4IiwiaGFuZGxlQm91bmRzQ2hhbmdlIiwidXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmIiwiQ2FjaGVkTWFwU3RhY2siLCJwb3AiLCJ1c2VNYXBJbnN0YW5jZSIsImNvbnRleHQiLCJhcGlJc0xvYWRlZCIsInNldE1hcCIsImNvbnRhaW5lciIsImNvbnRhaW5lclJlZiIsImRlZmF1bHRCb3VuZHMiLCJkZWZhdWx0Q2VudGVyIiwiZGVmYXVsdFpvb20iLCJkZWZhdWx0SGVhZGluZyIsImRlZmF1bHRUaWx0IiwicmV1c2VNYXBzIiwicmVuZGVyaW5nVHlwZSIsImNvbG9yU2NoZW1lIiwiaGFzWm9vbSIsImhhc0NlbnRlciIsImN1c3RvbUlkcyIsInNhdmVkTWFwU3RhdGVSZWYiLCJtYXBJZCIsImNhY2hlS2V5IiwibWFwRGl2IiwiZ2V0RGl2IiwiYXBwZW5kQ2hpbGQiLCJzZXRUaW1lb3V0Iiwic2V0Q2VudGVyIiwiaGVpZ2h0IiwiTWFwIiwiZGVmQm91bmRzIiwiZml0Qm91bmRzIiwic2F2ZWRNYXBJZCIsImNhbWVyYVN0YXRlIiwic2F2ZWRDYW1lcmFTdGF0ZSIsImNsZWFySW5zdGFuY2VMaXN0ZW5lcnMiLCJHb29nbGVNYXBzQ29udGV4dCIsIkNvbG9yU2NoZW1lIiwiREFSSyIsIkxJR0hUIiwiRk9MTE9XX1NZU1RFTSIsIlJlbmRlcmluZ1R5cGUiLCJWRUNUT1IiLCJSQVNURVIiLCJVTklOSVRJQUxJWkVEIiwiY2xhc3NOYW1lIiwibWFwUmVmIiwiaXNDb250cm9sbGVkRXh0ZXJuYWxseSIsImNvbnRyb2xsZWQiLCJkaXNhYmxlRGVmYXVsdFVJIiwiZ2VzdHVyZUhhbmRsaW5nIiwia2V5Ym9hcmRTaG9ydGN1dHMiLCJjYW1lcmFPcHRpb25zIiwiX2MiLCJjb21iaW5lZFN0eWxlIiwid2lkdGgiLCJkZWNrR0xWaWV3UHJvcHMiLCJzaG93bk1lc3NhZ2VzIiwibG9nRXJyb3JPbmNlIiwiYXJncyIsImFkZCIsInVzZU1hcCIsImN0eCIsInVzZU1hcHNMaWJyYXJ5IiwidXNlTWFwc0V2ZW50TGlzdGVuZXIiLCJ0YXJnZXQiLCJjYWxsYmFjayIsInVzZVByb3BCaW5kaW5nIiwib2JqZWN0IiwicHJvcCIsInVzZURvbUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkdsb2JhbFN0eWxlTWFuYWdlciIsImNvbnN0cnVjdG9yIiwicmVuZGVyZWRTdHlsZXMiLCJzdHlsZUVsZW1lbnQiLCJnZXRTdHlsZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhZGRBZHZhbmNlZE1hcmtlclBvaW50ZXJFdmVudHNPdmVyd3JpdGUiLCJ0ZXh0Q29udGVudCIsImNsZWFudXAiLCJjbGVhciIsImdsb2JhbFN0eWxlTWFuYWdlciIsImlzVmVyc2lvbkdyZWF0ZXJFcXVhbCIsIm1ham9yIiwibWlub3IiLCJjdXJyZW50TWFqb3IiLCJwYXJzZUludCIsImN1cnJlbnRNaW5vciIsIkNvbGxpc2lvbkJlaGF2aW9yIiwiUkVRVUlSRUQiLCJSRVFVSVJFRF9BTkRfSElERVNfT1BUSU9OQUwiLCJPUFRJT05BTF9BTkRfSElERVNfTE9XRVJfUFJJT1JJVFkiLCJBZHZhbmNlZE1hcmtlckNvbnRleHQiLCJBZHZhbmNlZE1hcmtlckFuY2hvclBvaW50IiwiVE9QX0xFRlQiLCJUT1BfQ0VOVEVSIiwiVE9QIiwiVE9QX1JJR0hUIiwiTEVGVF9DRU5URVIiLCJMRUZUX1RPUCIsIkxFRlQiLCJMRUZUX0JPVFRPTSIsIlJJR0hUX1RPUCIsIlJJR0hUIiwiUklHSFRfQ0VOVEVSIiwiUklHSFRfQk9UVE9NIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fQ0VOVEVSIiwiQk9UVE9NIiwiQk9UVE9NX1JJR0hUIiwiQ0VOVEVSIiwiQWR2YW5jZWRNYXJrZXIiLCJhbmNob3JQb2ludCIsIm1hcmtlciIsImNvbnRlbnRDb250YWluZXIiLCJ1c2VBZHZhbmNlZE1hcmtlciIsImFkdmFuY2VkTWFya2VyQ29udGV4dFZhbHVlIiwiTWFya2VyQ29udGVudCIsInN0eWxlcyIsImRpc3BsYXlOYW1lIiwidXNlQWR2YW5jZWRNYXJrZXJSZWYiLCJzZXRNYXJrZXIiLCJyZWZDYWxsYmFjayIsIm0iLCJpc0FkdmFuY2VkTWFya2VyIiwiY29udGVudCIsImlzRWxlbWVudE5vZGUiLCJub2RlIiwibm9kZVR5cGUiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwic2V0Q29udGVudENvbnRhaW5lciIsIm1hcmtlckxpYnJhcnkiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ0VuZCIsImNvbGxpc2lvbkJlaGF2aW9yIiwiY2xpY2thYmxlIiwiZHJhZ2dhYmxlIiwidGl0bGUiLCJhbmNob3JMZWZ0IiwiYW5jaG9yVG9wIiwibnVtQ2hpbGRyZW4iLCJjb3VudCIsIm5ld01hcmtlciIsIkFkdmFuY2VkTWFya2VyRWxlbWVudCIsImNvbnRlbnRFbGVtZW50IiwidXNlQWR2YW5jZWRNYXJrZXJBbmNob3JpbmciLCJnbXBEcmFnZ2FibGUiLCJnbXBDbGlja2FibGUiLCJCb29sZWFuIiwicG9pbnRlckV2ZW50cyIsImN1cnNvciIsImVsZW1lbnQiLCJoYXNDaGlsZHJlbiIsImFuY2hvck9wdGlvbnNTdXBwb3J0ZWQiLCJ5IiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJ0cmFuc2Zvcm0iLCJkYXRhc2V0Iiwib3JpZ2luIiwic2V0VmFsdWVGb3JTdHlsZXMiLCJwcmV2U3R5bGVzIiwiZWxlbWVudFN0eWxlIiwic3R5bGVOYW1lIiwic2V0VmFsdWVGb3JTdHlsZSIsImlzQ3VzdG9tUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsImNzc0Zsb2F0IiwiaXNVbml0bGVzc051bWJlciIsInRyaW0iLCJ1bml0bGVzc051bWJlcnMiLCJJbmZvV2luZG93IiwiaGVhZGVyQ29udGVudCIsInBpeGVsT2Zmc2V0IiwiYW5jaG9yIiwic2hvdWxkRm9jdXMiLCJvbkNsb3NlIiwib25DbG9zZUNsaWNrIiwidm9sYXRpbGVJbmZvV2luZG93T3B0aW9ucyIsIm1hcHNMaWJyYXJ5IiwiaW5mb1dpbmRvdyIsInNldEluZm9XaW5kb3ciLCJjb250ZW50Q29udGFpbmVyUmVmIiwiaGVhZGVyQ29udGFpbmVyUmVmIiwiaW5mb1dpbmRvd09wdGlvbnMiLCJvcHRzIiwiU2l6ZSIsInNldENvbnRlbnQiLCJwcmV2U3R5bGVSZWYiLCJpc09wZW5lZFdpdGhBbmNob3IiLCJvcGVuT3B0aW9ucyIsIkVsZW1lbnQiLCJhbmNob3JCY3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJhbmNob3JEb21Db250ZW50IiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJjb250ZW50QmNyIiwiYW5jaG9yT2Zmc2V0WCIsImFuY2hvck9mZnNldFkiLCJvcGVuIiwiY2xvc2UiLCJGcmFnbWVudCIsImZvcm1hdExvY2F0aW9uIiwibG9jYXRpb24iLCJmb3JtYXRQYXJhbSIsInN0cmluZyIsInNsaWNlIiwiYXNzZW1ibGVNYXJrZXJQYXJhbXMiLCJtYXJrZXJzIiwibWFya2VyUGFyYW1zIiwibWFya2Vyc0J5U3R5bGUiLCJyZWR1Y2UiLCJsYWJlbCIsInNpemUiLCJzY2FsZSIsImljb24iLCJyZWxldmFudFByb3BzIiwiZmlsdGVyIiwidmFsdWVzIiwiZm9yRWFjaCIsIm1hcmtlclBhcmFtIiwicmVsZXZhbnRLZXlzIiwiUEFUSF9TVFlMRV9LRVlTIiwiYnVpbGRTdHlsZVBhcmFtcyIsInBhdGgiLCJzdHlsZVBhcmFtcyIsImJ1aWxkQ29vcmRpbmF0ZVBhcmFtcyIsImNvb3JkaW5hdGVzIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiYXNzZW1ibGVQYXRoUGFyYW1zIiwicGF0aHMiLCJjb29yZGluYXRlUGFyYW1zIiwicGF0aFBhcmFtIiwiYXNzZW1ibGVNYXBUeXBlU3R5bGVzIiwibWFwVHlwZVN0eWxlIiwiZmVhdHVyZVR5cGUiLCJlbGVtZW50VHlwZSIsInN0eWxlcnMiLCJzdHlsZVN0cmluZyIsInN0eWxlciIsIlNUQVRJQ19NQVBTX0JBU0UiLCJjcmVhdGVTdGF0aWNNYXBzVXJsIiwiZm9ybWF0IiwibWFwVHlwZSIsInZpc2libGUiLCJtYXB0eXBlIiwibWFwX2lkIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiU3RhdGljTWFwIiwiQ29udHJvbFBvc2l0aW9uIiwiQkxPQ0tfU1RBUlRfSU5MSU5FX1NUQVJUIiwiQkxPQ0tfU1RBUlRfSU5MSU5FX0NFTlRFUiIsIkJMT0NLX1NUQVJUX0lOTElORV9FTkQiLCJJTkxJTkVfU1RBUlRfQkxPQ0tfQ0VOVEVSIiwiSU5MSU5FX1NUQVJUX0JMT0NLX1NUQVJUIiwiSU5MSU5FX1NUQVJUX0JMT0NLX0VORCIsIklOTElORV9FTkRfQkxPQ0tfU1RBUlQiLCJJTkxJTkVfRU5EX0JMT0NLX0NFTlRFUiIsIklOTElORV9FTkRfQkxPQ0tfRU5EIiwiQkxPQ0tfRU5EX0lOTElORV9TVEFSVCIsIkJMT0NLX0VORF9JTkxJTkVfQ0VOVEVSIiwiQkxPQ0tfRU5EX0lOTElORV9FTkQiLCJNYXBDb250cm9sIiwiY29udHJvbENvbnRhaW5lciIsImNvbnRyb2xzIiwiY29udHJvbHNBcnJheSIsImdldEFycmF5IiwiaW5kZXgiLCJyZW1vdmVBdCIsInVzZU1hcmtlciIsIm9uTW91c2VPdmVyIiwib25Nb3VzZU91dCIsIm1hcmtlck9wdGlvbnMiLCJNYXJrZXIiLCJnbWUiLCJzZXREcmFnZ2FibGUiLCJzZXRQb3NpdGlvbiIsInVzZU1hcmtlclJlZiIsIlBpbiIsImFkdmFuY2VkTWFya2VyIiwiZ2x5cGhDb250YWluZXIiLCJnbHlwaCIsInBpblZpZXdPcHRpb25zIiwicGluRWxlbWVudCIsIlBpbkVsZW1lbnQiLCJtYXJrZXJDb250ZW50IiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwibWFwTGluZWFyIiwiYTEiLCJhMiIsImIxIiwiYjIiLCJnZXRNYXBNYXhUaWx0IiwibGltaXRUaWx0UmFuZ2UiLCJnbVpvb20iLCJtYXhUaWx0IiwiZm92eSIsIk1hdGgiLCJtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n");

/***/ })

};
;