/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/projects/[id]/twin/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Cprojects%5Cpropmubi%5Capps%5Cweb%5Capp%5Cprojects%5C%5Bid%5D%5Ctwin%5Cpage.tsx&server=false!":
/*!*****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Cprojects%5Cpropmubi%5Capps%5Cweb%5Capp%5Cprojects%5C%5Bid%5D%5Ctwin%5Cpage.tsx&server=false! ***!
  \*****************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/projects/[id]/twin/page.tsx */ \"(app-pages-browser)/./app/projects/[id]/twin/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDcHJvamVjdHMlNUNwcm9wbXViaSU1Q2FwcHMlNUN3ZWIlNUNhcHAlNUNwcm9qZWN0cyU1QyU1QmlkJTVEJTVDdHdpbiU1Q3BhZ2UudHN4JnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz82Mjc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxccHJvamVjdHNcXFxccHJvcG11YmlcXFxcYXBwc1xcXFx3ZWJcXFxcYXBwXFxcXHByb2plY3RzXFxcXFtpZF1cXFxcdHdpblxcXFxwYWdlLnRzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Cprojects%5Cpropmubi%5Capps%5Cweb%5Capp%5Cprojects%5C%5Bid%5D%5Ctwin%5Cpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// do not edit .js files directly - edit src/index.jst\nmodule.exports = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for(i = length; i-- !== 0;){\n            var key = keys[i];\n            if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxzREFBc0Q7QUFJdERBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxNQUFNQyxDQUFDLEVBQUVDLENBQUM7SUFDbEMsSUFBSUQsTUFBTUMsR0FBRyxPQUFPO0lBRXBCLElBQUlELEtBQUtDLEtBQUssT0FBT0QsS0FBSyxZQUFZLE9BQU9DLEtBQUssVUFBVTtRQUMxRCxJQUFJRCxFQUFFRSxXQUFXLEtBQUtELEVBQUVDLFdBQVcsRUFBRSxPQUFPO1FBRTVDLElBQUlDLFFBQVFDLEdBQUdDO1FBQ2YsSUFBSUMsTUFBTUMsT0FBTyxDQUFDUCxJQUFJO1lBQ3BCRyxTQUFTSCxFQUFFRyxNQUFNO1lBQ2pCLElBQUlBLFVBQVVGLEVBQUVFLE1BQU0sRUFBRSxPQUFPO1lBQy9CLElBQUtDLElBQUlELFFBQVFDLFFBQVEsR0FDdkIsSUFBSSxDQUFDTCxNQUFNQyxDQUFDLENBQUNJLEVBQUUsRUFBRUgsQ0FBQyxDQUFDRyxFQUFFLEdBQUcsT0FBTztZQUNqQyxPQUFPO1FBQ1Q7UUFJQSxJQUFJSixFQUFFRSxXQUFXLEtBQUtNLFFBQVEsT0FBT1IsRUFBRVMsTUFBTSxLQUFLUixFQUFFUSxNQUFNLElBQUlULEVBQUVVLEtBQUssS0FBS1QsRUFBRVMsS0FBSztRQUNqRixJQUFJVixFQUFFVyxPQUFPLEtBQUtDLE9BQU9DLFNBQVMsQ0FBQ0YsT0FBTyxFQUFFLE9BQU9YLEVBQUVXLE9BQU8sT0FBT1YsRUFBRVUsT0FBTztRQUM1RSxJQUFJWCxFQUFFYyxRQUFRLEtBQUtGLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxFQUFFLE9BQU9kLEVBQUVjLFFBQVEsT0FBT2IsRUFBRWEsUUFBUTtRQUVoRlQsT0FBT08sT0FBT1AsSUFBSSxDQUFDTDtRQUNuQkcsU0FBU0UsS0FBS0YsTUFBTTtRQUNwQixJQUFJQSxXQUFXUyxPQUFPUCxJQUFJLENBQUNKLEdBQUdFLE1BQU0sRUFBRSxPQUFPO1FBRTdDLElBQUtDLElBQUlELFFBQVFDLFFBQVEsR0FDdkIsSUFBSSxDQUFDUSxPQUFPQyxTQUFTLENBQUNFLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDZixHQUFHSSxJQUFJLENBQUNELEVBQUUsR0FBRyxPQUFPO1FBRWhFLElBQUtBLElBQUlELFFBQVFDLFFBQVEsR0FBSTtZQUMzQixJQUFJYSxNQUFNWixJQUFJLENBQUNELEVBQUU7WUFFakIsSUFBSSxDQUFDTCxNQUFNQyxDQUFDLENBQUNpQixJQUFJLEVBQUVoQixDQUFDLENBQUNnQixJQUFJLEdBQUcsT0FBTztRQUNyQztRQUVBLE9BQU87SUFDVDtJQUVBLG9DQUFvQztJQUNwQyxPQUFPakIsTUFBSUEsS0FBS0MsTUFBSUE7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcz8wYmM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJlcXVhbCIsImEiLCJiIiwiY29uc3RydWN0b3IiLCJsZW5ndGgiLCJpIiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsIlJlZ0V4cCIsInNvdXJjZSIsImZsYWdzIiwidmFsdWVPZiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fast-deep-equal/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/client-only/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIoYXBwLXBhZ2VzLWJyb3dzZXIpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jbGllbnQtb25seS9pbmRleC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JB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c3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/projects/[id]/twin/page.tsx":
/*!*****************************************!*\
  !*** ./app/projects/[id]/twin/page.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DigitalTwinPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(app-pages-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vis.gl/react-google-maps */ \"(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n// --- ICONS ---\nconst Icons = {\n    Sun: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            children: \"\"\n        }, void 0, false, {\n            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n            lineNumber: 9,\n            columnNumber: 16\n        }, undefined),\n    Wind: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            children: \"\\uD83D\\uDCA8\"\n        }, void 0, false, {\n            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n            lineNumber: 10,\n            columnNumber: 17\n        }, undefined),\n    Vastu: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            children: \"\\uD83D\\uDD49\"\n        }, void 0, false, {\n            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n            lineNumber: 11,\n            columnNumber: 18\n        }, undefined),\n    Furniture: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            children: \"\\uD83E\\uDE91\"\n        }, void 0, false, {\n            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n            lineNumber: 12,\n            columnNumber: 22\n        }, undefined),\n    Back: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            children: \"\"\n        }, void 0, false, {\n            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n            lineNumber: 13,\n            columnNumber: 17\n        }, undefined)\n};\n// --- MOCK DATA ---\nconst TOWER_CONFIG = {\n    floors: 35,\n    unitsPerFloor: 8,\n    unitTypes: [\n        \"3BHK East\",\n        \"3BHK West\",\n        \"2BHK North\"\n    ]\n};\nfunction DigitalTwinPage(param) {\n    let { params } = param;\n    _s();\n    const [viewLevel, setViewLevel] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"SITE\");\n    const [selectedUnit, setSelectedUnit] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [currentTime, setCurrentTime] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(12); // 12 PM\n    const apiKey = \"AIzaSyDFsyNYExhBjsFFvVfBkWAIwdLQyZXq67w\" || 0;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            height: \"100vh\",\n            display: \"flex\",\n            flexDirection: \"column\",\n            fontFamily: \"sans-serif\",\n            background: \"#0f172a\",\n            color: \"white\"\n        },\n        className: \"jsx-4b4471c877cdb75d\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    height: 60,\n                    padding: \"0 20px\",\n                    display: \"flex\",\n                    alignItems: \"center\",\n                    justifyContent: \"space-between\",\n                    borderBottom: \"1px solid #334155\",\n                    background: \"#1e293b\"\n                },\n                className: \"jsx-4b4471c877cdb75d\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            alignItems: \"center\",\n                            gap: 15\n                        },\n                        className: \"jsx-4b4471c877cdb75d\",\n                        children: [\n                            viewLevel !== \"SITE\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setViewLevel((prev)=>prev === \"UNIT\" ? \"TOWER\" : \"SITE\"),\n                                style: {\n                                    background: \"none\",\n                                    border: \"none\",\n                                    color: \"white\",\n                                    cursor: \"pointer\",\n                                    fontSize: 20\n                                },\n                                className: \"jsx-4b4471c877cdb75d\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Icons.Back, {}, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 36,\n                                    columnNumber: 29\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 35,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                style: {\n                                    margin: 0,\n                                    fontSize: 18\n                                },\n                                className: \"jsx-4b4471c877cdb75d\",\n                                children: [\n                                    viewLevel === \"SITE\" && \"Project Site Map\",\n                                    viewLevel === \"TOWER\" && \"Tower 4 Structure\",\n                                    viewLevel === \"UNIT\" && \"Unit \".concat(selectedUnit, \" Interior Twin\")\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 39,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            alignItems: \"center\",\n                            gap: 10\n                        },\n                        className: \"jsx-4b4471c877cdb75d\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    fontSize: 12\n                                },\n                                className: \"jsx-4b4471c877cdb75d\",\n                                children: [\n                                    \"Time: \",\n                                    currentTime,\n                                    \":00\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 48,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"range\",\n                                min: \"6\",\n                                max: \"18\",\n                                value: currentTime,\n                                onChange: (e)=>setCurrentTime(parseInt(e.target.value)),\n                                style: {\n                                    width: 150\n                                },\n                                className: \"jsx-4b4471c877cdb75d\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 49,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Icons.Sun, {}, void 0, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 54,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 47,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                lineNumber: 32,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    flex: 1,\n                    display: \"flex\",\n                    overflow: \"hidden\"\n                },\n                className: \"jsx-4b4471c877cdb75d\",\n                children: [\n                    viewLevel === \"SITE\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            flex: 1,\n                            position: \"relative\"\n                        },\n                        className: \"jsx-4b4471c877cdb75d\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.APIProvider, {\n                                apiKey: apiKey,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.Map, {\n                                    defaultCenter: {\n                                        lat: 17.46,\n                                        lng: 78.29\n                                    },\n                                    defaultZoom: 18,\n                                    mapTypeId: \"satellite\",\n                                    disableDefaultUI: true,\n                                    style: {\n                                        width: \"100%\",\n                                        height: \"100%\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 65,\n                                    columnNumber: 29\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 64,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                onClick: ()=>setViewLevel(\"TOWER\"),\n                                style: {\n                                    position: \"absolute\",\n                                    top: \"40%\",\n                                    left: \"45%\",\n                                    width: 80,\n                                    height: 80,\n                                    background: \"rgba(52, 152, 219, 0.4)\",\n                                    border: \"2px solid #3498db\",\n                                    borderRadius: 8,\n                                    cursor: \"pointer\",\n                                    display: \"flex\",\n                                    alignItems: \"center\",\n                                    justifyContent: \"center\",\n                                    backdropFilter: \"blur(4px)\",\n                                    animation: \"pulse 2s infinite\"\n                                },\n                                className: \"jsx-4b4471c877cdb75d\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        fontWeight: \"bold\"\n                                    },\n                                    className: \"jsx-4b4471c877cdb75d\",\n                                    children: \"Tower 4\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 85,\n                                    columnNumber: 29\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 75,\n                                columnNumber: 25\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 63,\n                        columnNumber: 21\n                    }, this),\n                    viewLevel === \"TOWER\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TowerView, {\n                        onSelectUnit: (unit)=>{\n                            setSelectedUnit(unit);\n                            setViewLevel(\"UNIT\");\n                        }\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 92,\n                        columnNumber: 21\n                    }, this),\n                    viewLevel === \"UNIT\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(UnitInteriorDesigner, {\n                        unitId: selectedUnit,\n                        time: currentTime\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 97,\n                        columnNumber: 21\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                lineNumber: 59,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"4b4471c877cdb75d\",\n                children: \"@-webkit-keyframes pulse{0%{-webkit-transform:scale(1);transform:scale(1);border-color:rgba(52,152,219,.8)}50%{-webkit-transform:scale(1.05);transform:scale(1.05);border-color:rgba(52,152,219,.3)}100%{-webkit-transform:scale(1);transform:scale(1);border-color:rgba(52,152,219,.8)}}@-moz-keyframes pulse{0%{-moz-transform:scale(1);transform:scale(1);border-color:rgba(52,152,219,.8)}50%{-moz-transform:scale(1.05);transform:scale(1.05);border-color:rgba(52,152,219,.3)}100%{-moz-transform:scale(1);transform:scale(1);border-color:rgba(52,152,219,.8)}}@-o-keyframes pulse{0%{-o-transform:scale(1);transform:scale(1);border-color:rgba(52,152,219,.8)}50%{-o-transform:scale(1.05);transform:scale(1.05);border-color:rgba(52,152,219,.3)}100%{-o-transform:scale(1);transform:scale(1);border-color:rgba(52,152,219,.8)}}@keyframes pulse{0%{-webkit-transform:scale(1);-moz-transform:scale(1);-o-transform:scale(1);transform:scale(1);border-color:rgba(52,152,219,.8)}50%{-webkit-transform:scale(1.05);-moz-transform:scale(1.05);-o-transform:scale(1.05);transform:scale(1.05);border-color:rgba(52,152,219,.3)}100%{-webkit-transform:scale(1);-moz-transform:scale(1);-o-transform:scale(1);transform:scale(1);border-color:rgba(52,152,219,.8)}}\"\n            }, void 0, false, void 0, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n        lineNumber: 30,\n        columnNumber: 9\n    }, this);\n}\n_s(DigitalTwinPage, \"/Xnx5NCpEjKoIEsENw6iBjNb3rI=\");\n_c = DigitalTwinPage;\n// --- COMPONENT: TOWER VIEW ---\nfunction TowerView(param) {\n    let { onSelectUnit } = param;\n    // Generate floors\n    const floors = Array.from({\n        length: 15\n    }, (_, i)=>15 - i); // Just showing 15 floors for demo\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            flex: 1,\n            display: \"flex\",\n            background: \"#0f172a\",\n            padding: 40,\n            gap: 40\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    flex: 1,\n                    overflowY: \"auto\",\n                    paddingRight: 20\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        style: {\n                            borderBottom: \"1px solid #334155\",\n                            paddingBottom: 10\n                        },\n                        children: \"Tower 4 Stack\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 121,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            flexDirection: \"column\",\n                            gap: 5\n                        },\n                        children: floors.map((floor)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    display: \"flex\",\n                                    gap: 10,\n                                    alignItems: \"center\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        style: {\n                                            width: 40,\n                                            color: \"#94a3b8\",\n                                            fontSize: 12\n                                        },\n                                        children: [\n                                            \"Lvl \",\n                                            floor\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 125,\n                                        columnNumber: 29\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        style: {\n                                            display: \"flex\",\n                                            gap: 5,\n                                            flex: 1\n                                        },\n                                        children: [\n                                            1,\n                                            2,\n                                            3,\n                                            4\n                                        ].map((u)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                onClick: ()=>onSelectUnit(\"\".concat(floor, \"0\").concat(u)),\n                                                style: {\n                                                    flex: 1,\n                                                    height: 30,\n                                                    background: \"#1e293b\",\n                                                    borderRadius: 4,\n                                                    border: \"1px solid #334155\",\n                                                    cursor: \"pointer\",\n                                                    display: \"flex\",\n                                                    alignItems: \"center\",\n                                                    justifyContent: \"center\",\n                                                    fontSize: 11,\n                                                    color: \"#bfdbfe\",\n                                                    transition: \"all 0.2s\"\n                                                },\n                                                onMouseEnter: (e)=>e.currentTarget.style.background = \"#3b82f6\",\n                                                onMouseLeave: (e)=>e.currentTarget.style.background = \"#1e293b\",\n                                                children: [\n                                                    \"Unit \",\n                                                    floor,\n                                                    \"0\",\n                                                    u\n                                                ]\n                                            }, u, true, {\n                                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                                lineNumber: 128,\n                                                columnNumber: 37\n                                            }, this))\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 126,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, floor, true, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 124,\n                                columnNumber: 25\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 122,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                lineNumber: 120,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    width: 300,\n                    background: \"#1e293b\",\n                    borderRadius: 16,\n                    padding: 20\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        children: \"Structure Stats\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 151,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: \"Status: Structure Complete\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 152,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: \"Completion: Dec 2025\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 153,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            height: 200,\n                            background: \"#0f172a\",\n                            borderRadius: 8,\n                            marginTop: 20,\n                            display: \"flex\",\n                            alignItems: \"center\",\n                            justifyContent: \"center\",\n                            color: \"#64748b\"\n                        },\n                        children: \"[3D ISO VIEW]\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 154,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                lineNumber: 150,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n        lineNumber: 119,\n        columnNumber: 9\n    }, this);\n}\n_c1 = TowerView;\n// --- COMPONENT: UNIT INTERIOR DESIGNER ---\nfunction UnitInteriorDesigner(param) {\n    let { unitId, time } = param;\n    _s1();\n    const [layers, setLayers] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        vastu: false,\n        wind: false,\n        sun: true\n    });\n    const [furniture, setFurniture] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const toggle = (l)=>setLayers((p)=>({\n                ...p,\n                [l]: !p[l]\n            }));\n    const handleDragStart = (e, type)=>{\n        e.dataTransfer.setData(\"type\", type);\n    };\n    const handleDrop = (e)=>{\n        const type = e.dataTransfer.getData(\"type\");\n        const rect = e.currentTarget.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        setFurniture((p)=>[\n                ...p,\n                {\n                    id: Date.now(),\n                    type,\n                    x,\n                    y\n                }\n            ]);\n    };\n    // Derived Simulation Props\n    const sunOpacity = (time - 6) / 12 * 0.5; // Simple Logic\n    const sunAngle = (time - 6) * 15; // 0 to 180 deg\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            flex: 1,\n            display: \"flex\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    width: 250,\n                    background: \"#1e293b\",\n                    padding: 20,\n                    display: \"flex\",\n                    flexDirection: \"column\",\n                    gap: 20\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                style: {\n                                    color: \"#94a3b8\",\n                                    marginBottom: 10\n                                },\n                                children: \"SIMULATIONS\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 191,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    display: \"flex\",\n                                    flexDirection: \"column\",\n                                    gap: 10\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SimToggle, {\n                                        label: \" Sunlight\",\n                                        active: layers.sun,\n                                        onClick: ()=>toggle(\"sun\")\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 193,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SimToggle, {\n                                        label: \"\\uD83D\\uDCA8 Ventilation\",\n                                        active: layers.wind,\n                                        onClick: ()=>toggle(\"wind\")\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 194,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SimToggle, {\n                                        label: \"\\uD83D\\uDD49 Vastu Grid\",\n                                        active: layers.vastu,\n                                        onClick: ()=>toggle(\"vastu\")\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 195,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 192,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 190,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                style: {\n                                    color: \"#94a3b8\",\n                                    marginBottom: 10\n                                },\n                                children: \"DESIGN STUDIO\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 201,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    display: \"grid\",\n                                    gridTemplateColumns: \"1fr 1fr\",\n                                    gap: 10\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DraggableItem, {\n                                        type: \"Bed\",\n                                        icon: \"\\uD83D\\uDECF\",\n                                        onDragStart: handleDragStart\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 203,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DraggableItem, {\n                                        type: \"Sofa\",\n                                        icon: \"\\uD83D\\uDECB\",\n                                        onDragStart: handleDragStart\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 204,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DraggableItem, {\n                                        type: \"Table\",\n                                        icon: \"\\uD83C\\uDF7D\",\n                                        onDragStart: handleDragStart\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 205,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DraggableItem, {\n                                        type: \"Plant\",\n                                        icon: \"\\uD83E\\uDEB4\",\n                                        onDragStart: handleDragStart\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 206,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 202,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                        lineNumber: 200,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                lineNumber: 188,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    flex: 1,\n                    background: \"#cbd5e1\",\n                    position: \"relative\",\n                    overflow: \"hidden\"\n                },\n                onDragOver: (e)=>e.preventDefault(),\n                onDrop: handleDrop,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        width: \"80%\",\n                        height: \"80%\",\n                        margin: \"5% auto\",\n                        background: \"white\",\n                        border: \"5px solid #475569\",\n                        boxShadow: \"0 20px 50px rgba(0,0,0,0.5)\",\n                        position: \"relative\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                position: \"absolute\",\n                                top: 0,\n                                left: 0,\n                                right: 0,\n                                bottom: 0,\n                                display: \"grid\",\n                                gridTemplateColumns: \"1fr 1.5fr\",\n                                gridTemplateRows: \"1fr 1fr\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Room, {\n                                    name: \"Master Bedroom\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 225,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Room, {\n                                    name: \"Living Area\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 226,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Room, {\n                                    name: \"Kitchen\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 227,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Room, {\n                                    name: \"Guest Room\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 228,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                            lineNumber: 224,\n                            columnNumber: 21\n                        }, this),\n                        furniture.map((f)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    position: \"absolute\",\n                                    top: f.y - 20,\n                                    left: f.x - 20,\n                                    fontSize: 30,\n                                    cursor: \"grab\"\n                                },\n                                children: f.type === \"Bed\" ? \"\\uD83D\\uDECF\" : f.type === \"Sofa\" ? \"\\uD83D\\uDECB\" : \"\\uD83D\\uDCE6\"\n                            }, f.id, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 233,\n                                columnNumber: 25\n                            }, this)),\n                        layers.sun && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                position: \"absolute\",\n                                inset: 0,\n                                pointerEvents: \"none\",\n                                background: \"linear-gradient(\".concat(sunAngle, \"deg, rgba(255, 166, 0, \").concat(sunOpacity, \"), transparent 60%)\")\n                            }\n                        }, void 0, false, {\n                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                            lineNumber: 242,\n                            columnNumber: 25\n                        }, this),\n                        layers.vastu && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                position: \"absolute\",\n                                inset: 0,\n                                pointerEvents: \"none\",\n                                display: \"grid\",\n                                gridTemplateColumns: \"1fr 1fr\",\n                                gridTemplateRows: \"1fr 1fr\",\n                                opacity: 0.5\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        background: \"#ef4444\",\n                                        display: \"flex\",\n                                        alignItems: \"center\",\n                                        justifyContent: \"center\"\n                                    },\n                                    children: \"\\uD83D\\uDD25 Fire (SE)\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 251,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        background: \"#22c55e\",\n                                        display: \"flex\",\n                                        alignItems: \"center\",\n                                        justifyContent: \"center\"\n                                    },\n                                    children: \"\\uD83D\\uDCA7 Water (NE)\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 252,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        background: \"#eab308\",\n                                        display: \"flex\",\n                                        alignItems: \"center\",\n                                        justifyContent: \"center\"\n                                    },\n                                    children: \"\\uD83C\\uDF0D Earth (SW)\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 253,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        background: \"#3b82f6\",\n                                        display: \"flex\",\n                                        alignItems: \"center\",\n                                        justifyContent: \"center\"\n                                    },\n                                    children: \"\\uD83D\\uDCA8 Air (NW)\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                    lineNumber: 254,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                            lineNumber: 250,\n                            columnNumber: 25\n                        }, this),\n                        layers.wind && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"wind-layer\",\n                            style: {\n                                position: \"absolute\",\n                                inset: 0,\n                                pointerEvents: \"none\"\n                            },\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                width: \"100%\",\n                                height: \"100%\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"defs\", {\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"marker\", {\n                                            id: \"arrow\",\n                                            markerWidth: \"10\",\n                                            markerHeight: \"10\",\n                                            refX: \"0\",\n                                            refY: \"3\",\n                                            orient: \"auto\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                d: \"M0,0 L0,6 L9,3 z\",\n                                                fill: \"#60a5fa\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                                lineNumber: 265,\n                                                columnNumber: 41\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                            lineNumber: 264,\n                                            columnNumber: 37\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 263,\n                                        columnNumber: 33\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                        x1: \"0\",\n                                        y1: \"20%\",\n                                        x2: \"100%\",\n                                        y2: \"20%\",\n                                        stroke: \"#60a5fa\",\n                                        strokeWidth: \"2\",\n                                        strokeDasharray: \"5,5\",\n                                        markerEnd: \"url(#arrow)\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"animate\", {\n                                            attributeName: \"x1\",\n                                            from: \"-100\",\n                                            to: \"100%\",\n                                            dur: \"2s\",\n                                            repeatCount: \"indefinite\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                            lineNumber: 269,\n                                            columnNumber: 37\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 268,\n                                        columnNumber: 33\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                        x1: \"0\",\n                                        y1: \"60%\",\n                                        x2: \"100%\",\n                                        y2: \"80%\",\n                                        stroke: \"#60a5fa\",\n                                        strokeWidth: \"2\",\n                                        strokeDasharray: \"5,5\",\n                                        markerEnd: \"url(#arrow)\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"animate\", {\n                                            attributeName: \"x1\",\n                                            from: \"-100\",\n                                            to: \"100%\",\n                                            dur: \"3s\",\n                                            repeatCount: \"indefinite\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                            lineNumber: 272,\n                                            columnNumber: 37\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                        lineNumber: 271,\n                                        columnNumber: 33\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                                lineNumber: 262,\n                                columnNumber: 29\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                            lineNumber: 260,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                    lineNumber: 218,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                lineNumber: 212,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n        lineNumber: 186,\n        columnNumber: 9\n    }, this);\n}\n_s1(UnitInteriorDesigner, \"V5DrRrHlGYM4c6KiLSCbT0V+nqc=\");\n_c2 = UnitInteriorDesigner;\nfunction SimToggle(param) {\n    let { label, active, onClick } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        onClick: onClick,\n        style: {\n            padding: 10,\n            borderRadius: 8,\n            border: \"1px solid\",\n            borderColor: active ? \"#3b82f6\" : \"#334155\",\n            background: active ? \"rgba(59, 130, 246, 0.2)\" : \"transparent\",\n            color: active ? \"#60a5fa\" : \"#94a3b8\",\n            cursor: \"pointer\",\n            textAlign: \"left\",\n            fontWeight: \"bold\"\n        },\n        children: label\n    }, void 0, false, {\n        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n        lineNumber: 286,\n        columnNumber: 9\n    }, this);\n}\n_c3 = SimToggle;\nfunction DraggableItem(param) {\n    let { type, icon, onDragStart } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        draggable: true,\n        onDragStart: (e)=>onDragStart(e, type),\n        style: {\n            padding: 15,\n            background: \"#334155\",\n            borderRadius: 8,\n            display: \"flex\",\n            flexDirection: \"column\",\n            alignItems: \"center\",\n            gap: 5,\n            cursor: \"grab\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    fontSize: 24\n                },\n                children: icon\n            }, void 0, false, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                lineNumber: 310,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    fontSize: 12\n                },\n                children: type\n            }, void 0, false, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n                lineNumber: 311,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n        lineNumber: 302,\n        columnNumber: 9\n    }, this);\n}\n_c4 = DraggableItem;\nfunction Room(param) {\n    let { name } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            border: \"1px solid #e2e8f0\",\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n            color: \"#94a3b8\",\n            fontSize: 14,\n            fontWeight: \"bold\"\n        },\n        children: name\n    }, void 0, false, {\n        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\app\\\\projects\\\\[id]\\\\twin\\\\page.tsx\",\n        lineNumber: 318,\n        columnNumber: 9\n    }, this);\n}\n_c5 = Room;\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"DigitalTwinPage\");\n$RefreshReg$(_c1, \"TowerView\");\n$RefreshReg$(_c2, \"UnitInteriorDesigner\");\n$RefreshReg$(_c3, \"SimToggle\");\n$RefreshReg$(_c4, \"DraggableItem\");\n$RefreshReg$(_c5, \"Room\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wcm9qZWN0cy9baWRdL3R3aW4vcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVtRDtBQUNVO0FBRzdELGdCQUFnQjtBQUNoQixNQUFNSSxRQUFRO0lBQ1ZDLEtBQUssa0JBQU0sOERBQUNDO3NCQUFLOzs7Ozs7SUFDakJDLE1BQU0sa0JBQU0sOERBQUNEO3NCQUFLOzs7Ozs7SUFDbEJFLE9BQU8sa0JBQU0sOERBQUNGO3NCQUFLOzs7Ozs7SUFDbkJHLFdBQVcsa0JBQU0sOERBQUNIO3NCQUFLOzs7Ozs7SUFDdkJJLE1BQU0sa0JBQU0sOERBQUNKO3NCQUFLOzs7Ozs7QUFDdEI7QUFFQSxvQkFBb0I7QUFDcEIsTUFBTUssZUFBZTtJQUNqQkMsUUFBUTtJQUNSQyxlQUFlO0lBQ2ZDLFdBQVc7UUFBQztRQUFhO1FBQWE7S0FBYTtBQUN2RDtBQUVlLFNBQVNDLGdCQUFnQixLQUFzQztRQUF0QyxFQUFFQyxNQUFNLEVBQThCLEdBQXRDOztJQUNwQyxNQUFNLENBQUNDLFdBQVdDLGFBQWEsR0FBR2pCLCtDQUFRQSxDQUE0QjtJQUN0RSxNQUFNLENBQUNrQixjQUFjQyxnQkFBZ0IsR0FBR25CLCtDQUFRQSxDQUFnQjtJQUNoRSxNQUFNLENBQUNvQixhQUFhQyxlQUFlLEdBQUdyQiwrQ0FBUUEsQ0FBQyxLQUFLLFFBQVE7SUFDNUQsTUFBTXNCLFNBQVNDLHlDQUF1QyxJQUFJLENBQUU7SUFFNUQscUJBQ0ksOERBQUNHO1FBQUlDLE9BQU87WUFBRUMsUUFBUTtZQUFTQyxTQUFTO1lBQVFDLGVBQWU7WUFBVUMsWUFBWTtZQUFjQyxZQUFZO1lBQVdDLE9BQU87UUFBUTs7OzBCQUVySSw4REFBQ1A7Z0JBQUlDLE9BQU87b0JBQUVDLFFBQVE7b0JBQUlNLFNBQVM7b0JBQVVMLFNBQVM7b0JBQVFNLFlBQVk7b0JBQVVDLGdCQUFnQjtvQkFBaUJDLGNBQWM7b0JBQXFCTCxZQUFZO2dCQUFVOzs7a0NBQzFLLDhEQUFDTjt3QkFBSUMsT0FBTzs0QkFBRUUsU0FBUzs0QkFBUU0sWUFBWTs0QkFBVUcsS0FBSzt3QkFBRzs7OzRCQUN4RHRCLGNBQWMsd0JBQ1gsOERBQUN1QjtnQ0FBT0MsU0FBUyxJQUFNdkIsYUFBYXdCLENBQUFBLE9BQVFBLFNBQVMsU0FBUyxVQUFVO2dDQUFTZCxPQUFPO29DQUFFSyxZQUFZO29DQUFRVSxRQUFRO29DQUFRVCxPQUFPO29DQUFTVSxRQUFRO29DQUFXQyxVQUFVO2dDQUFHOzswQ0FDMUssNEVBQUN6QyxNQUFNTSxJQUFJOzs7Ozs7Ozs7OzBDQUduQiw4REFBQ29DO2dDQUFHbEIsT0FBTztvQ0FBRW1CLFFBQVE7b0NBQUdGLFVBQVU7Z0NBQUc7OztvQ0FDaEM1QixjQUFjLFVBQVc7b0NBQ3pCQSxjQUFjLFdBQVk7b0NBQzFCQSxjQUFjLFVBQVUsUUFBcUIsT0FBYkUsY0FBYTs7Ozs7Ozs7Ozs7OztrQ0FLdEQsOERBQUNRO3dCQUFJQyxPQUFPOzRCQUFFRSxTQUFTOzRCQUFRTSxZQUFZOzRCQUFVRyxLQUFLO3dCQUFHOzs7MENBQ3pELDhEQUFDakM7Z0NBQUtzQixPQUFPO29DQUFFaUIsVUFBVTtnQ0FBRzs7O29DQUFHO29DQUFPeEI7b0NBQVk7Ozs7Ozs7MENBQ2xELDhEQUFDMkI7Z0NBQ0dDLE1BQUs7Z0NBQVFDLEtBQUk7Z0NBQUlDLEtBQUk7Z0NBQUtDLE9BQU8vQjtnQ0FDckNnQyxVQUFVQyxDQUFBQSxJQUFLaEMsZUFBZWlDLFNBQVNELEVBQUVFLE1BQU0sQ0FBQ0osS0FBSztnQ0FDckR4QixPQUFPO29DQUFFNkIsT0FBTztnQ0FBSTs7Ozs7OzswQ0FFeEIsOERBQUNyRCxNQUFNQyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7OzswQkFLbEIsOERBQUNzQjtnQkFBSUMsT0FBTztvQkFBRThCLE1BQU07b0JBQUc1QixTQUFTO29CQUFRNkIsVUFBVTtnQkFBUzs7O29CQUd0RDFDLGNBQWMsd0JBQ1gsOERBQUNVO3dCQUFJQyxPQUFPOzRCQUFFOEIsTUFBTTs0QkFBR0UsVUFBVTt3QkFBVzs7OzBDQUN4Qyw4REFBQzFELGtFQUFXQTtnQ0FBQ3FCLFFBQVFBOzBDQUNqQiw0RUFBQ3BCLDBEQUFHQTtvQ0FDQTBELGVBQWU7d0NBQUVDLEtBQUs7d0NBQU9DLEtBQUs7b0NBQU07b0NBQ3hDQyxhQUFhO29DQUNiQyxXQUFXO29DQUNYQyxrQkFBa0I7b0NBQ2xCdEMsT0FBTzt3Q0FBRTZCLE9BQU87d0NBQVE1QixRQUFRO29DQUFPOzs7Ozs7Ozs7OzswQ0FLL0MsOERBQUNGO2dDQUNHYyxTQUFTLElBQU12QixhQUFhO2dDQUM1QlUsT0FBTztvQ0FDSGdDLFVBQVU7b0NBQVlPLEtBQUs7b0NBQU9DLE1BQU07b0NBQ3hDWCxPQUFPO29DQUFJNUIsUUFBUTtvQ0FBSUksWUFBWTtvQ0FDbkNVLFFBQVE7b0NBQXFCMEIsY0FBYztvQ0FBR3pCLFFBQVE7b0NBQ3REZCxTQUFTO29DQUFRTSxZQUFZO29DQUFVQyxnQkFBZ0I7b0NBQ3ZEaUMsZ0JBQWdCO29DQUNoQkMsV0FBVztnQ0FDZjs7MENBQ0EsNEVBQUNqRTtvQ0FBS3NCLE9BQU87d0NBQUU0QyxZQUFZO29DQUFPOzs4Q0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTWhEdkQsY0FBYyx5QkFDWCw4REFBQ3dEO3dCQUFVQyxjQUFjLENBQUNDOzRCQUFXdkQsZ0JBQWdCdUQ7NEJBQU96RCxhQUFhO3dCQUFTOzs7Ozs7b0JBSXJGRCxjQUFjLHdCQUNYLDhEQUFDMkQ7d0JBQXFCQyxRQUFRMUQ7d0JBQWMyRCxNQUFNekQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjdEU7R0F4RndCTjtLQUFBQTtBQTBGeEIsZ0NBQWdDO0FBQ2hDLFNBQVMwRCxVQUFVLEtBQXVEO1FBQXZELEVBQUVDLFlBQVksRUFBeUMsR0FBdkQ7SUFDZixrQkFBa0I7SUFDbEIsTUFBTTlELFNBQVNtRSxNQUFNQyxJQUFJLENBQUM7UUFBRUMsUUFBUTtJQUFHLEdBQUcsQ0FBQ0MsR0FBR0MsSUFBTSxLQUFLQSxJQUFJLGtDQUFrQztJQUUvRixxQkFDSSw4REFBQ3hEO1FBQUlDLE9BQU87WUFBRThCLE1BQU07WUFBRzVCLFNBQVM7WUFBUUcsWUFBWTtZQUFXRSxTQUFTO1lBQUlJLEtBQUs7UUFBRzs7MEJBQ2hGLDhEQUFDWjtnQkFBSUMsT0FBTztvQkFBRThCLE1BQU07b0JBQUcwQixXQUFXO29CQUFRQyxjQUFjO2dCQUFHOztrQ0FDdkQsOERBQUNDO3dCQUFHMUQsT0FBTzs0QkFBRVUsY0FBYzs0QkFBcUJpRCxlQUFlO3dCQUFHO2tDQUFHOzs7Ozs7a0NBQ3JFLDhEQUFDNUQ7d0JBQUlDLE9BQU87NEJBQUVFLFNBQVM7NEJBQVFDLGVBQWU7NEJBQVVRLEtBQUs7d0JBQUU7a0NBQzFEM0IsT0FBTzRFLEdBQUcsQ0FBQ0MsQ0FBQUEsc0JBQ1IsOERBQUM5RDtnQ0FBZ0JDLE9BQU87b0NBQUVFLFNBQVM7b0NBQVFTLEtBQUs7b0NBQUlILFlBQVk7Z0NBQVM7O2tEQUNyRSw4REFBQ1Q7d0NBQUlDLE9BQU87NENBQUU2QixPQUFPOzRDQUFJdkIsT0FBTzs0Q0FBV1csVUFBVTt3Q0FBRzs7NENBQUc7NENBQUs0Qzs7Ozs7OztrREFDaEUsOERBQUM5RDt3Q0FBSUMsT0FBTzs0Q0FBRUUsU0FBUzs0Q0FBUVMsS0FBSzs0Q0FBR21CLE1BQU07d0NBQUU7a0RBQzFDOzRDQUFDOzRDQUFHOzRDQUFHOzRDQUFHO3lDQUFFLENBQUM4QixHQUFHLENBQUNFLENBQUFBLGtCQUNkLDhEQUFDL0Q7Z0RBRUdjLFNBQVMsSUFBTWlDLGFBQWEsR0FBWWdCLE9BQVRELE9BQU0sS0FBSyxPQUFGQztnREFDeEM5RCxPQUFPO29EQUNIOEIsTUFBTTtvREFBRzdCLFFBQVE7b0RBQUlJLFlBQVk7b0RBQ2pDb0MsY0FBYztvREFBRzFCLFFBQVE7b0RBQXFCQyxRQUFRO29EQUN0RGQsU0FBUztvREFBUU0sWUFBWTtvREFBVUMsZ0JBQWdCO29EQUN2RFEsVUFBVTtvREFBSVgsT0FBTztvREFDckJ5RCxZQUFZO2dEQUNoQjtnREFDQUMsY0FBY3RDLENBQUFBLElBQU1BLEVBQUV1QyxhQUFhLENBQUNqRSxLQUFLLENBQUNLLFVBQVUsR0FBRztnREFDdkQ2RCxjQUFjeEMsQ0FBQUEsSUFBTUEsRUFBRXVDLGFBQWEsQ0FBQ2pFLEtBQUssQ0FBQ0ssVUFBVSxHQUFHOztvREFDMUQ7b0RBQ1N3RDtvREFBTTtvREFBRUM7OytDQVpUQTs7Ozs7Ozs7Ozs7K0JBTFhEOzs7Ozs7Ozs7Ozs7Ozs7OzBCQTBCdEIsOERBQUM5RDtnQkFBSUMsT0FBTztvQkFBRTZCLE9BQU87b0JBQUt4QixZQUFZO29CQUFXb0MsY0FBYztvQkFBSWxDLFNBQVM7Z0JBQUc7O2tDQUMzRSw4REFBQ21EO2tDQUFHOzs7Ozs7a0NBQ0osOERBQUNTO2tDQUFFOzs7Ozs7a0NBQ0gsOERBQUNBO2tDQUFFOzs7Ozs7a0NBQ0gsOERBQUNwRTt3QkFBSUMsT0FBTzs0QkFBRUMsUUFBUTs0QkFBS0ksWUFBWTs0QkFBV29DLGNBQWM7NEJBQUcyQixXQUFXOzRCQUFJbEUsU0FBUzs0QkFBUU0sWUFBWTs0QkFBVUMsZ0JBQWdCOzRCQUFVSCxPQUFPO3dCQUFVO2tDQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNdkw7TUE5Q1N1QztBQWdEVCw0Q0FBNEM7QUFDNUMsU0FBU0cscUJBQXFCLEtBQXlEO1FBQXpELEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUEyQyxHQUF6RDs7SUFDMUIsTUFBTSxDQUFDbUIsUUFBUUMsVUFBVSxHQUFHakcsK0NBQVFBLENBQUM7UUFBRWtHLE9BQU87UUFBT0MsTUFBTTtRQUFPQyxLQUFLO0lBQUs7SUFDNUUsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUd0RywrQ0FBUUEsQ0FBdUQsRUFBRTtJQUVuRyxNQUFNdUcsU0FBUyxDQUFDQyxJQUEyQlAsVUFBVUgsQ0FBQUEsSUFBTTtnQkFBRSxHQUFHQSxDQUFDO2dCQUFFLENBQUNVLEVBQUUsRUFBRSxDQUFDVixDQUFDLENBQUNVLEVBQUU7WUFBQztJQUU5RSxNQUFNQyxrQkFBa0IsQ0FBQ3BELEdBQW9CTDtRQUN6Q0ssRUFBRXFELFlBQVksQ0FBQ0MsT0FBTyxDQUFDLFFBQVEzRDtJQUNuQztJQUVBLE1BQU00RCxhQUFhLENBQUN2RDtRQUNoQixNQUFNTCxPQUFPSyxFQUFFcUQsWUFBWSxDQUFDRyxPQUFPLENBQUM7UUFDcEMsTUFBTUMsT0FBT3pELEVBQUV1QyxhQUFhLENBQUNtQixxQkFBcUI7UUFDbEQsTUFBTUMsSUFBSTNELEVBQUU0RCxPQUFPLEdBQUdILEtBQUszQyxJQUFJO1FBQy9CLE1BQU0rQyxJQUFJN0QsRUFBRThELE9BQU8sR0FBR0wsS0FBSzVDLEdBQUc7UUFDOUJvQyxhQUFhUixDQUFBQSxJQUFLO21CQUFJQTtnQkFBRztvQkFBRXNCLElBQUlDLEtBQUtDLEdBQUc7b0JBQUl0RTtvQkFBTWdFO29CQUFHRTtnQkFBRTthQUFFO0lBQzVEO0lBRUEsMkJBQTJCO0lBQzNCLE1BQU1LLGFBQWEsQ0FBQzFDLE9BQU8sS0FBSyxLQUFLLEtBQUssZUFBZTtJQUN6RCxNQUFNMkMsV0FBVyxDQUFDM0MsT0FBTyxLQUFLLElBQUksZUFBZTtJQUVqRCxxQkFDSSw4REFBQ25EO1FBQUlDLE9BQU87WUFBRThCLE1BQU07WUFBRzVCLFNBQVM7UUFBTzs7MEJBRW5DLDhEQUFDSDtnQkFBSUMsT0FBTztvQkFBRTZCLE9BQU87b0JBQUt4QixZQUFZO29CQUFXRSxTQUFTO29CQUFJTCxTQUFTO29CQUFRQyxlQUFlO29CQUFVUSxLQUFLO2dCQUFHOztrQ0FFNUcsOERBQUNaOzswQ0FDRyw4REFBQytGO2dDQUFHOUYsT0FBTztvQ0FBRU0sT0FBTztvQ0FBV3lGLGNBQWM7Z0NBQUc7MENBQUc7Ozs7OzswQ0FDbkQsOERBQUNoRztnQ0FBSUMsT0FBTztvQ0FBRUUsU0FBUztvQ0FBUUMsZUFBZTtvQ0FBVVEsS0FBSztnQ0FBRzs7a0RBQzVELDhEQUFDcUY7d0NBQVVDLE9BQU07d0NBQWNDLFFBQVE3QixPQUFPSSxHQUFHO3dDQUFFNUQsU0FBUyxJQUFNK0QsT0FBTzs7Ozs7O2tEQUN6RSw4REFBQ29CO3dDQUFVQyxPQUFNO3dDQUFpQkMsUUFBUTdCLE9BQU9HLElBQUk7d0NBQUUzRCxTQUFTLElBQU0rRCxPQUFPOzs7Ozs7a0RBQzdFLDhEQUFDb0I7d0NBQVVDLE9BQU07d0NBQWlCQyxRQUFRN0IsT0FBT0UsS0FBSzt3Q0FBRTFELFNBQVMsSUFBTStELE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FLdEYsOERBQUM3RTs7MENBQ0csOERBQUMrRjtnQ0FBRzlGLE9BQU87b0NBQUVNLE9BQU87b0NBQVd5RixjQUFjO2dDQUFHOzBDQUFHOzs7Ozs7MENBQ25ELDhEQUFDaEc7Z0NBQUlDLE9BQU87b0NBQUVFLFNBQVM7b0NBQVFpRyxxQkFBcUI7b0NBQVd4RixLQUFLO2dDQUFHOztrREFDbkUsOERBQUN5Rjt3Q0FBYy9FLE1BQUs7d0NBQU1nRixNQUFLO3dDQUFNQyxhQUFheEI7Ozs7OztrREFDbEQsOERBQUNzQjt3Q0FBYy9FLE1BQUs7d0NBQU9nRixNQUFLO3dDQUFNQyxhQUFheEI7Ozs7OztrREFDbkQsOERBQUNzQjt3Q0FBYy9FLE1BQUs7d0NBQVFnRixNQUFLO3dDQUFNQyxhQUFheEI7Ozs7OztrREFDcEQsOERBQUNzQjt3Q0FBYy9FLE1BQUs7d0NBQVFnRixNQUFLO3dDQUFLQyxhQUFheEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFNL0QsOERBQUMvRTtnQkFDR0MsT0FBTztvQkFBRThCLE1BQU07b0JBQUd6QixZQUFZO29CQUFXMkIsVUFBVTtvQkFBWUQsVUFBVTtnQkFBUztnQkFDbEZ3RSxZQUFZN0UsQ0FBQUEsSUFBS0EsRUFBRThFLGNBQWM7Z0JBQ2pDQyxRQUFReEI7MEJBR1IsNEVBQUNsRjtvQkFBSUMsT0FBTzt3QkFDUjZCLE9BQU87d0JBQU81QixRQUFRO3dCQUFPa0IsUUFBUTt3QkFDckNkLFlBQVk7d0JBQVNVLFFBQVE7d0JBQXFCMkYsV0FBVzt3QkFDN0QxRSxVQUFVO29CQUNkOztzQ0FFSSw4REFBQ2pDOzRCQUFJQyxPQUFPO2dDQUFFZ0MsVUFBVTtnQ0FBWU8sS0FBSztnQ0FBR0MsTUFBTTtnQ0FBR21FLE9BQU87Z0NBQUdDLFFBQVE7Z0NBQUcxRyxTQUFTO2dDQUFRaUcscUJBQXFCO2dDQUFhVSxrQkFBa0I7NEJBQVU7OzhDQUNySiw4REFBQ0M7b0NBQUtDLE1BQUs7Ozs7Ozs4Q0FDWCw4REFBQ0Q7b0NBQUtDLE1BQUs7Ozs7Ozs4Q0FDWCw4REFBQ0Q7b0NBQUtDLE1BQUs7Ozs7Ozs4Q0FDWCw4REFBQ0Q7b0NBQUtDLE1BQUs7Ozs7Ozs7Ozs7Ozt3QkFJZHJDLFVBQVVkLEdBQUcsQ0FBQ29ELENBQUFBLGtCQUNYLDhEQUFDakg7Z0NBQWVDLE9BQU87b0NBQUVnQyxVQUFVO29DQUFZTyxLQUFLeUUsRUFBRXpCLENBQUMsR0FBRztvQ0FBSS9DLE1BQU13RSxFQUFFM0IsQ0FBQyxHQUFHO29DQUFJcEUsVUFBVTtvQ0FBSUQsUUFBUTtnQ0FBTzswQ0FDdEdnRyxFQUFFM0YsSUFBSSxLQUFLLFFBQVEsa0JBQVEyRixFQUFFM0YsSUFBSSxLQUFLLFNBQVMsa0JBQVE7K0JBRGxEMkYsRUFBRXZCLEVBQUU7Ozs7O3dCQVFqQnBCLE9BQU9JLEdBQUcsa0JBQ1AsOERBQUMxRTs0QkFBSUMsT0FBTztnQ0FDUmdDLFVBQVU7Z0NBQVlpRixPQUFPO2dDQUFHQyxlQUFlO2dDQUMvQzdHLFlBQVksbUJBQXFEdUYsT0FBbENDLFVBQVMsMkJBQW9DLE9BQVhELFlBQVc7NEJBQ2hGOzs7Ozs7d0JBSUh2QixPQUFPRSxLQUFLLGtCQUNULDhEQUFDeEU7NEJBQUlDLE9BQU87Z0NBQUVnQyxVQUFVO2dDQUFZaUYsT0FBTztnQ0FBR0MsZUFBZTtnQ0FBUWhILFNBQVM7Z0NBQVFpRyxxQkFBcUI7Z0NBQVdVLGtCQUFrQjtnQ0FBV00sU0FBUzs0QkFBSTs7OENBQzVKLDhEQUFDcEg7b0NBQUlDLE9BQU87d0NBQUVLLFlBQVk7d0NBQVdILFNBQVM7d0NBQVFNLFlBQVk7d0NBQVVDLGdCQUFnQjtvQ0FBUzs4Q0FBRzs7Ozs7OzhDQUN4Ryw4REFBQ1Y7b0NBQUlDLE9BQU87d0NBQUVLLFlBQVk7d0NBQVdILFNBQVM7d0NBQVFNLFlBQVk7d0NBQVVDLGdCQUFnQjtvQ0FBUzs4Q0FBRzs7Ozs7OzhDQUN4Ryw4REFBQ1Y7b0NBQUlDLE9BQU87d0NBQUVLLFlBQVk7d0NBQVdILFNBQVM7d0NBQVFNLFlBQVk7d0NBQVVDLGdCQUFnQjtvQ0FBUzs4Q0FBRzs7Ozs7OzhDQUN4Ryw4REFBQ1Y7b0NBQUlDLE9BQU87d0NBQUVLLFlBQVk7d0NBQVdILFNBQVM7d0NBQVFNLFlBQVk7d0NBQVVDLGdCQUFnQjtvQ0FBUzs4Q0FBRzs7Ozs7Ozs7Ozs7O3dCQUsvRzRELE9BQU9HLElBQUksa0JBQ1IsOERBQUN6RTs0QkFBSXFILFdBQVU7NEJBQWFwSCxPQUFPO2dDQUFFZ0MsVUFBVTtnQ0FBWWlGLE9BQU87Z0NBQUdDLGVBQWU7NEJBQU87c0NBRXZGLDRFQUFDRztnQ0FBSXhGLE9BQU07Z0NBQU81QixRQUFPOztrREFDckIsOERBQUNxSDtrREFDRyw0RUFBQ0M7NENBQU85QixJQUFHOzRDQUFRK0IsYUFBWTs0Q0FBS0MsY0FBYTs0Q0FBS0MsTUFBSzs0Q0FBSUMsTUFBSzs0Q0FBSUMsUUFBTztzREFDM0UsNEVBQUNDO2dEQUFLQyxHQUFFO2dEQUFtQkMsTUFBSzs7Ozs7Ozs7Ozs7Ozs7OztrREFHeEMsOERBQUNDO3dDQUFLQyxJQUFHO3dDQUFJQyxJQUFHO3dDQUFNQyxJQUFHO3dDQUFPQyxJQUFHO3dDQUFNQyxRQUFPO3dDQUFVQyxhQUFZO3dDQUFJQyxpQkFBZ0I7d0NBQU1DLFdBQVU7a0RBQ3RHLDRFQUFDQzs0Q0FBUUMsZUFBYzs0Q0FBS3RGLE1BQUs7NENBQU91RixJQUFHOzRDQUFPQyxLQUFJOzRDQUFLQyxhQUFZOzs7Ozs7Ozs7OztrREFFM0UsOERBQUNiO3dDQUFLQyxJQUFHO3dDQUFJQyxJQUFHO3dDQUFNQyxJQUFHO3dDQUFPQyxJQUFHO3dDQUFNQyxRQUFPO3dDQUFVQyxhQUFZO3dDQUFJQyxpQkFBZ0I7d0NBQU1DLFdBQVU7a0RBQ3RHLDRFQUFDQzs0Q0FBUUMsZUFBYzs0Q0FBS3RGLE1BQUs7NENBQU91RixJQUFHOzRDQUFPQyxLQUFJOzRDQUFLQyxhQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVM0c7SUF2SFM3RjtNQUFBQTtBQXlIVCxTQUFTZ0QsVUFBVSxLQUErQjtRQUEvQixFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRXJGLE9BQU8sRUFBTyxHQUEvQjtJQUNmLHFCQUNJLDhEQUFDRDtRQUNHQyxTQUFTQTtRQUNUYixPQUFPO1lBQ0hPLFNBQVM7WUFBSWtDLGNBQWM7WUFBRzFCLFFBQVE7WUFDdEMrSCxhQUFhNUMsU0FBUyxZQUFZO1lBQ2xDN0YsWUFBWTZGLFNBQVMsNEJBQTRCO1lBQ2pENUYsT0FBTzRGLFNBQVMsWUFBWTtZQUM1QmxGLFFBQVE7WUFBVytILFdBQVc7WUFBUW5HLFlBQVk7UUFDdEQ7a0JBQ0NxRDs7Ozs7O0FBR2I7TUFkU0Q7QUFnQlQsU0FBU0ksY0FBYyxLQUFnQztRQUFoQyxFQUFFL0UsSUFBSSxFQUFFZ0YsSUFBSSxFQUFFQyxXQUFXLEVBQU8sR0FBaEM7SUFDbkIscUJBQ0ksOERBQUN2RztRQUNHaUosU0FBUztRQUNUMUMsYUFBYSxDQUFDNUUsSUFBTTRFLFlBQVk1RSxHQUFHTDtRQUNuQ3JCLE9BQU87WUFDSE8sU0FBUztZQUFJRixZQUFZO1lBQVdvQyxjQUFjO1lBQ2xEdkMsU0FBUztZQUFRQyxlQUFlO1lBQVVLLFlBQVk7WUFBVUcsS0FBSztZQUNyRUssUUFBUTtRQUNaOzswQkFDQSw4REFBQ2pCO2dCQUFJQyxPQUFPO29CQUFFaUIsVUFBVTtnQkFBRzswQkFBSW9GOzs7Ozs7MEJBQy9CLDhEQUFDdEc7Z0JBQUlDLE9BQU87b0JBQUVpQixVQUFVO2dCQUFHOzBCQUFJSTs7Ozs7Ozs7Ozs7O0FBRzNDO01BZFMrRTtBQWdCVCxTQUFTVSxLQUFLLEtBQWE7UUFBYixFQUFFQyxJQUFJLEVBQU8sR0FBYjtJQUNWLHFCQUNJLDhEQUFDaEg7UUFBSUMsT0FBTztZQUFFZSxRQUFRO1lBQXFCYixTQUFTO1lBQVFNLFlBQVk7WUFBVUMsZ0JBQWdCO1lBQVVILE9BQU87WUFBV1csVUFBVTtZQUFJMkIsWUFBWTtRQUFPO2tCQUMxSm1FOzs7Ozs7QUFHYjtNQU5TRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcHJvamVjdHMvW2lkXS90d2luL3BhZ2UudHN4P2IyNDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgQVBJUHJvdmlkZXIsIE1hcCB9IGZyb20gJ0B2aXMuZ2wvcmVhY3QtZ29vZ2xlLW1hcHMnO1xyXG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xyXG5cclxuLy8gLS0tIElDT05TIC0tLVxyXG5jb25zdCBJY29ucyA9IHtcclxuICAgIFN1bjogKCkgPT4gPHNwYW4+4piA77iPPC9zcGFuPixcclxuICAgIFdpbmQ6ICgpID0+IDxzcGFuPvCfkqg8L3NwYW4+LFxyXG4gICAgVmFzdHU6ICgpID0+IDxzcGFuPvCflYnvuI88L3NwYW4+LFxyXG4gICAgRnVybml0dXJlOiAoKSA9PiA8c3Bhbj7wn6qRPC9zcGFuPixcclxuICAgIEJhY2s6ICgpID0+IDxzcGFuPuKshe+4jzwvc3Bhbj5cclxufTtcclxuXHJcbi8vIC0tLSBNT0NLIERBVEEgLS0tXHJcbmNvbnN0IFRPV0VSX0NPTkZJRyA9IHtcclxuICAgIGZsb29yczogMzUsXHJcbiAgICB1bml0c1BlckZsb29yOiA4LFxyXG4gICAgdW5pdFR5cGVzOiBbJzNCSEsgRWFzdCcsICczQkhLIFdlc3QnLCAnMkJISyBOb3J0aCddXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaWdpdGFsVHdpblBhZ2UoeyBwYXJhbXMgfTogeyBwYXJhbXM6IHsgaWQ6IHN0cmluZyB9IH0pIHtcclxuICAgIGNvbnN0IFt2aWV3TGV2ZWwsIHNldFZpZXdMZXZlbF0gPSB1c2VTdGF0ZTwnU0lURScgfCAnVE9XRVInIHwgJ1VOSVQnPignU0lURScpO1xyXG4gICAgY29uc3QgW3NlbGVjdGVkVW5pdCwgc2V0U2VsZWN0ZWRVbml0XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3QgW2N1cnJlbnRUaW1lLCBzZXRDdXJyZW50VGltZV0gPSB1c2VTdGF0ZSgxMik7IC8vIDEyIFBNXHJcbiAgICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfTUFQU19LRVkgfHwgXCJcIjtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiAnMTAwdmgnLCBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLCBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsIGJhY2tncm91bmQ6ICcjMGYxNzJhJywgY29sb3I6ICd3aGl0ZScgfX0+XHJcbiAgICAgICAgICAgIHsvKiBIZWFkZXIgLyBOYXYgKi99XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiA2MCwgcGFkZGluZzogJzAgMjBweCcsIGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCAjMzM0MTU1JywgYmFja2dyb3VuZDogJyMxZTI5M2InIH19PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBnYXA6IDE1IH19PlxyXG4gICAgICAgICAgICAgICAgICAgIHt2aWV3TGV2ZWwgIT09ICdTSVRFJyAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0Vmlld0xldmVsKHByZXYgPT4gcHJldiA9PT0gJ1VOSVQnID8gJ1RPV0VSJyA6ICdTSVRFJyl9IHN0eWxlPXt7IGJhY2tncm91bmQ6ICdub25lJywgYm9yZGVyOiAnbm9uZScsIGNvbG9yOiAnd2hpdGUnLCBjdXJzb3I6ICdwb2ludGVyJywgZm9udFNpemU6IDIwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25zLkJhY2sgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8aDIgc3R5bGU9e3sgbWFyZ2luOiAwLCBmb250U2l6ZTogMTggfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2aWV3TGV2ZWwgPT09ICdTSVRFJyAmJiBgUHJvamVjdCBTaXRlIE1hcGB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2aWV3TGV2ZWwgPT09ICdUT1dFUicgJiYgYFRvd2VyIDQgU3RydWN0dXJlYH1cclxuICAgICAgICAgICAgICAgICAgICAgICAge3ZpZXdMZXZlbCA9PT0gJ1VOSVQnICYmIGBVbml0ICR7c2VsZWN0ZWRVbml0fSBJbnRlcmlvciBUd2luYH1cclxuICAgICAgICAgICAgICAgICAgICA8L2gyPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgey8qIEdsb2JhbCBUaW1lIENvbnRyb2wgKi99XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGdhcDogMTAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgZm9udFNpemU6IDEyIH19PlRpbWU6IHtjdXJyZW50VGltZX06MDA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYW5nZVwiIG1pbj1cIjZcIiBtYXg9XCIxOFwiIHZhbHVlPXtjdXJyZW50VGltZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gc2V0Q3VycmVudFRpbWUocGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IDE1MCB9fVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb25zLlN1biAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgey8qIE1haW4gQ29udGVudCBBcmVhICovfVxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZsZXg6IDEsIGRpc3BsYXk6ICdmbGV4Jywgb3ZlcmZsb3c6ICdoaWRkZW4nIH19PlxyXG5cclxuICAgICAgICAgICAgICAgIHsvKiBWSUVXIExFVkVMIDE6IFNJVEUgTUFQICovfVxyXG4gICAgICAgICAgICAgICAge3ZpZXdMZXZlbCA9PT0gJ1NJVEUnICYmIChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZsZXg6IDEsIHBvc2l0aW9uOiAncmVsYXRpdmUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QVBJUHJvdmlkZXIgYXBpS2V5PXthcGlLZXl9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDZW50ZXI9e3sgbGF0OiAxNy40NiwgbG5nOiA3OC4yOSB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRab29tPXsxOH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBUeXBlSWQ9eydzYXRlbGxpdGUnfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVEZWZhdWx0VUk9e3RydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQVBJUHJvdmlkZXI+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7LyogSW50ZXJhY3RpdmUgVG93ZXIgT3ZlcmxheSAqL31cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0Vmlld0xldmVsKCdUT1dFUicpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAnNDAlJywgbGVmdDogJzQ1JScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDgwLCBoZWlnaHQ6IDgwLCBiYWNrZ3JvdW5kOiAncmdiYSg1MiwgMTUyLCAyMTksIDAuNCknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJzJweCBzb2xpZCAjMzQ5OGRiJywgYm9yZGVyUmFkaXVzOiA4LCBjdXJzb3I6ICdwb2ludGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3BGaWx0ZXI6ICdibHVyKDRweCknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogJ3B1bHNlIDJzIGluZmluaXRlJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcgfX0+VG93ZXIgNDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICApfVxyXG5cclxuICAgICAgICAgICAgICAgIHsvKiBWSUVXIExFVkVMIDI6IFRPV0VSIFNUUlVDVFVSRSAoUmVwZWF0ZWQgRmxvb3JzKSAqL31cclxuICAgICAgICAgICAgICAgIHt2aWV3TGV2ZWwgPT09ICdUT1dFUicgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgIDxUb3dlclZpZXcgb25TZWxlY3RVbml0PXsodW5pdCkgPT4geyBzZXRTZWxlY3RlZFVuaXQodW5pdCk7IHNldFZpZXdMZXZlbCgnVU5JVCcpOyB9fSAvPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuXHJcbiAgICAgICAgICAgICAgICB7LyogVklFVyBMRVZFTCAzOiBVTklUIElOVEVSSU9SIChVbml0IFR3aW4pICovfVxyXG4gICAgICAgICAgICAgICAge3ZpZXdMZXZlbCA9PT0gJ1VOSVQnICYmIChcclxuICAgICAgICAgICAgICAgICAgICA8VW5pdEludGVyaW9yRGVzaWduZXIgdW5pdElkPXtzZWxlY3RlZFVuaXR9IHRpbWU9e2N1cnJlbnRUaW1lfSAvPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e2BcclxuICAgICAgICAgICAgICAgIEBrZXlmcmFtZXMgcHVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIDAlIHsgdHJhbnNmb3JtOiBzY2FsZSgxKTsgYm9yZGVyLWNvbG9yOiByZ2JhKDUyLCAxNTIsIDIxOSwgMC44KTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIDUwJSB7IHRyYW5zZm9ybTogc2NhbGUoMS4wNSk7IGJvcmRlci1jb2xvcjogcmdiYSg1MiwgMTUyLCAyMTksIDAuMyk7IH1cclxuICAgICAgICAgICAgICAgICAgICAxMDAlIHsgdHJhbnNmb3JtOiBzY2FsZSgxKTsgYm9yZGVyLWNvbG9yOiByZ2JhKDUyLCAxNTIsIDIxOSwgMC44KTsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBgfTwvc3R5bGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG4vLyAtLS0gQ09NUE9ORU5UOiBUT1dFUiBWSUVXIC0tLVxyXG5mdW5jdGlvbiBUb3dlclZpZXcoeyBvblNlbGVjdFVuaXQgfTogeyBvblNlbGVjdFVuaXQ6ICh1OiBzdHJpbmcpID0+IHZvaWQgfSkge1xyXG4gICAgLy8gR2VuZXJhdGUgZmxvb3JzXHJcbiAgICBjb25zdCBmbG9vcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNSB9LCAoXywgaSkgPT4gMTUgLSBpKTsgLy8gSnVzdCBzaG93aW5nIDE1IGZsb29ycyBmb3IgZGVtb1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17eyBmbGV4OiAxLCBkaXNwbGF5OiAnZmxleCcsIGJhY2tncm91bmQ6ICcjMGYxNzJhJywgcGFkZGluZzogNDAsIGdhcDogNDAgfX0+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleDogMSwgb3ZlcmZsb3dZOiAnYXV0bycsIHBhZGRpbmdSaWdodDogMjAgfX0+XHJcbiAgICAgICAgICAgICAgICA8aDMgc3R5bGU9e3sgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkICMzMzQxNTUnLCBwYWRkaW5nQm90dG9tOiAxMCB9fT5Ub3dlciA0IFN0YWNrPC9oMz5cclxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJywgZ2FwOiA1IH19PlxyXG4gICAgICAgICAgICAgICAgICAgIHtmbG9vcnMubWFwKGZsb29yID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2Zsb29yfSBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGdhcDogMTAsIGFsaWduSXRlbXM6ICdjZW50ZXInIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogNDAsIGNvbG9yOiAnIzk0YTNiOCcsIGZvbnRTaXplOiAxMiB9fT5Mdmwge2Zsb29yfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGdhcDogNSwgZmxleDogMSB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7WzEsIDIsIDMsIDRdLm1hcCh1ID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXt1fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb25TZWxlY3RVbml0KGAke2Zsb29yfTAke3V9YCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXg6IDEsIGhlaWdodDogMzAsIGJhY2tncm91bmQ6ICcjMWUyOTNiJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDQsIGJvcmRlcjogJzFweCBzb2xpZCAjMzM0MTU1JywgY3Vyc29yOiAncG9pbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMSwgY29sb3I6ICcjYmZkYmZlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuMnMnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtlID0+IChlLmN1cnJlbnRUYXJnZXQuc3R5bGUuYmFja2dyb3VuZCA9ICcjM2I4MmY2Jyl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e2UgPT4gKGUuY3VycmVudFRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kID0gJyMxZTI5M2InKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVW5pdCB7Zmxvb3J9MHt1fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IDMwMCwgYmFja2dyb3VuZDogJyMxZTI5M2InLCBib3JkZXJSYWRpdXM6IDE2LCBwYWRkaW5nOiAyMCB9fT5cclxuICAgICAgICAgICAgICAgIDxoMz5TdHJ1Y3R1cmUgU3RhdHM8L2gzPlxyXG4gICAgICAgICAgICAgICAgPHA+U3RhdHVzOiBTdHJ1Y3R1cmUgQ29tcGxldGU8L3A+XHJcbiAgICAgICAgICAgICAgICA8cD5Db21wbGV0aW9uOiBEZWMgMjAyNTwvcD5cclxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiAyMDAsIGJhY2tncm91bmQ6ICcjMGYxNzJhJywgYm9yZGVyUmFkaXVzOiA4LCBtYXJnaW5Ub3A6IDIwLCBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsIGNvbG9yOiAnIzY0NzQ4YicgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgWzNEIElTTyBWSUVXXVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG5cclxuLy8gLS0tIENPTVBPTkVOVDogVU5JVCBJTlRFUklPUiBERVNJR05FUiAtLS1cclxuZnVuY3Rpb24gVW5pdEludGVyaW9yRGVzaWduZXIoeyB1bml0SWQsIHRpbWUgfTogeyB1bml0SWQ6IHN0cmluZyB8IG51bGwsIHRpbWU6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCBbbGF5ZXJzLCBzZXRMYXllcnNdID0gdXNlU3RhdGUoeyB2YXN0dTogZmFsc2UsIHdpbmQ6IGZhbHNlLCBzdW46IHRydWUgfSk7XHJcbiAgICBjb25zdCBbZnVybml0dXJlLCBzZXRGdXJuaXR1cmVdID0gdXNlU3RhdGU8eyBpZDogbnVtYmVyLCB0eXBlOiBzdHJpbmcsIHg6IG51bWJlciwgeTogbnVtYmVyIH1bXT4oW10pO1xyXG5cclxuICAgIGNvbnN0IHRvZ2dsZSA9IChsOiBrZXlvZiB0eXBlb2YgbGF5ZXJzKSA9PiBzZXRMYXllcnMocCA9PiAoeyAuLi5wLCBbbF06ICFwW2xdIH0pKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSAoZTogUmVhY3QuRHJhZ0V2ZW50LCB0eXBlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0eXBlJywgdHlwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZURyb3AgPSAoZTogUmVhY3QuRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoJ3R5cGUnKTtcclxuICAgICAgICBjb25zdCByZWN0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XHJcbiAgICAgICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xyXG4gICAgICAgIHNldEZ1cm5pdHVyZShwID0+IFsuLi5wLCB7IGlkOiBEYXRlLm5vdygpLCB0eXBlLCB4LCB5IH1dKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRGVyaXZlZCBTaW11bGF0aW9uIFByb3BzXHJcbiAgICBjb25zdCBzdW5PcGFjaXR5ID0gKHRpbWUgLSA2KSAvIDEyICogMC41OyAvLyBTaW1wbGUgTG9naWNcclxuICAgIGNvbnN0IHN1bkFuZ2xlID0gKHRpbWUgLSA2KSAqIDE1OyAvLyAwIHRvIDE4MCBkZWdcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleDogMSwgZGlzcGxheTogJ2ZsZXgnIH19PlxyXG4gICAgICAgICAgICB7LyogU2lkZWJhciBDb250cm9scyAqL31cclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogMjUwLCBiYWNrZ3JvdW5kOiAnIzFlMjkzYicsIHBhZGRpbmc6IDIwLCBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLCBnYXA6IDIwIH19PlxyXG4gICAgICAgICAgICAgICAgey8qIFNpbXVsYXRpb24gVG9nZ2xlcyAqL31cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGg0IHN0eWxlPXt7IGNvbG9yOiAnIzk0YTNiOCcsIG1hcmdpbkJvdHRvbTogMTAgfX0+U0lNVUxBVElPTlM8L2g0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJywgZ2FwOiAxMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNpbVRvZ2dsZSBsYWJlbD1cIuKYgO+4jyBTdW5saWdodFwiIGFjdGl2ZT17bGF5ZXJzLnN1bn0gb25DbGljaz17KCkgPT4gdG9nZ2xlKCdzdW4nKX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNpbVRvZ2dsZSBsYWJlbD1cIvCfkqggVmVudGlsYXRpb25cIiBhY3RpdmU9e2xheWVycy53aW5kfSBvbkNsaWNrPXsoKSA9PiB0b2dnbGUoJ3dpbmQnKX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNpbVRvZ2dsZSBsYWJlbD1cIvCflYnvuI8gVmFzdHUgR3JpZFwiIGFjdGl2ZT17bGF5ZXJzLnZhc3R1fSBvbkNsaWNrPXsoKSA9PiB0b2dnbGUoJ3Zhc3R1Jyl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICB7LyogRnVybml0dXJlIFBhbGV0dGUgKi99XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxoNCBzdHlsZT17eyBjb2xvcjogJyM5NGEzYjgnLCBtYXJnaW5Cb3R0b206IDEwIH19PkRFU0lHTiBTVFVESU88L2g0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2dyaWQnLCBncmlkVGVtcGxhdGVDb2x1bW5zOiAnMWZyIDFmcicsIGdhcDogMTAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGVJdGVtIHR5cGU9XCJCZWRcIiBpY29uPVwi8J+bj++4j1wiIG9uRHJhZ1N0YXJ0PXtoYW5kbGVEcmFnU3RhcnR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGVJdGVtIHR5cGU9XCJTb2ZhXCIgaWNvbj1cIvCfm4vvuI9cIiBvbkRyYWdTdGFydD17aGFuZGxlRHJhZ1N0YXJ0fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlSXRlbSB0eXBlPVwiVGFibGVcIiBpY29uPVwi8J+Nve+4j1wiIG9uRHJhZ1N0YXJ0PXtoYW5kbGVEcmFnU3RhcnR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGVJdGVtIHR5cGU9XCJQbGFudFwiIGljb249XCLwn6q0XCIgb25EcmFnU3RhcnQ9e2hhbmRsZURyYWdTdGFydH0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHsvKiBDYW52YXMgQXJlYSAqL31cclxuICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgZmxleDogMSwgYmFja2dyb3VuZDogJyNjYmQ1ZTEnLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgb3ZlcmZsb3c6ICdoaWRkZW4nIH19XHJcbiAgICAgICAgICAgICAgICBvbkRyYWdPdmVyPXtlID0+IGUucHJldmVudERlZmF1bHQoKX1cclxuICAgICAgICAgICAgICAgIG9uRHJvcD17aGFuZGxlRHJvcH1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgey8qIDEuIEZMT09SIFBMQU4gSU1BR0UgKEJhY2tncm91bmQpICovfVxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnODAlJywgaGVpZ2h0OiAnODAlJywgbWFyZ2luOiAnNSUgYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3doaXRlJywgYm9yZGVyOiAnNXB4IHNvbGlkICM0NzU1NjknLCBib3hTaGFkb3c6ICcwIDIwcHggNTBweCByZ2JhKDAsMCwwLDAuNSknLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXHJcbiAgICAgICAgICAgICAgICB9fT5cclxuICAgICAgICAgICAgICAgICAgICB7LyogTW9jayBSb29tcyBMYXlvdXQgKi99XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBkaXNwbGF5OiAnZ3JpZCcsIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICcxZnIgMS41ZnInLCBncmlkVGVtcGxhdGVSb3dzOiAnMWZyIDFmcicgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSb29tIG5hbWU9XCJNYXN0ZXIgQmVkcm9vbVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSb29tIG5hbWU9XCJMaXZpbmcgQXJlYVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSb29tIG5hbWU9XCJLaXRjaGVuXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFJvb20gbmFtZT1cIkd1ZXN0IFJvb21cIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7LyogMi4gRlVSTklUVVJFIExBWUVSICovfVxyXG4gICAgICAgICAgICAgICAgICAgIHtmdXJuaXR1cmUubWFwKGYgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17Zi5pZH0gc3R5bGU9e3sgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogZi55IC0gMjAsIGxlZnQ6IGYueCAtIDIwLCBmb250U2l6ZTogMzAsIGN1cnNvcjogJ2dyYWInIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2YudHlwZSA9PT0gJ0JlZCcgPyAn8J+bj++4jycgOiBmLnR5cGUgPT09ICdTb2ZhJyA/ICfwn5uL77iPJyA6ICfwn5OmJ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgKSl9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHsvKiAzLiBTSU1VTEFUSU9OIExBWUVSUyAqL31cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgey8qIFNVTkxJR0hUIE9WRVJMQVkgKi99XHJcbiAgICAgICAgICAgICAgICAgICAge2xheWVycy5zdW4gJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJywgaW5zZXQ6IDAsIHBvaW50ZXJFdmVudHM6ICdub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGBsaW5lYXItZ3JhZGllbnQoJHtzdW5BbmdsZX1kZWcsIHJnYmEoMjU1LCAxNjYsIDAsICR7c3VuT3BhY2l0eX0pLCB0cmFuc3BhcmVudCA2MCUpYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHsvKiBWQVNUVSBHUklEICovfVxyXG4gICAgICAgICAgICAgICAgICAgIHtsYXllcnMudmFzdHUgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCBpbnNldDogMCwgcG9pbnRlckV2ZW50czogJ25vbmUnLCBkaXNwbGF5OiAnZ3JpZCcsIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICcxZnIgMWZyJywgZ3JpZFRlbXBsYXRlUm93czogJzFmciAxZnInLCBvcGFjaXR5OiAwLjUgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGJhY2tncm91bmQ6ICcjZWY0NDQ0JywgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInIH19PvCflKUgRmlyZSAoU0UpPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGJhY2tncm91bmQ6ICcjMjJjNTVlJywgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInIH19PvCfkqcgV2F0ZXIgKE5FKTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBiYWNrZ3JvdW5kOiAnI2VhYjMwOCcsIGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyB9fT7wn4yNIEVhcnRoIChTVyk8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgYmFja2dyb3VuZDogJyMzYjgyZjYnLCBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicgfX0+8J+SqCBBaXIgKE5XKTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7LyogV0lORCBGTE9XIEFOSU1BVElPTiAqL31cclxuICAgICAgICAgICAgICAgICAgICB7bGF5ZXJzLndpbmQgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndpbmQtbGF5ZXJcIiBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgaW5zZXQ6IDAsIHBvaW50ZXJFdmVudHM6ICdub25lJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBBbmltYXRlZCBTVkcgQXJyb3dzICovfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRlZnM+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxtYXJrZXIgaWQ9XCJhcnJvd1wiIG1hcmtlcldpZHRoPVwiMTBcIiBtYXJrZXJIZWlnaHQ9XCIxMFwiIHJlZlg9XCIwXCIgcmVmWT1cIjNcIiBvcmllbnQ9XCJhdXRvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTAsMCBMMCw2IEw5LDMgelwiIGZpbGw9XCIjNjBhNWZhXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9tYXJrZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZWZzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lIHgxPVwiMFwiIHkxPVwiMjAlXCIgeDI9XCIxMDAlXCIgeTI9XCIyMCVcIiBzdHJva2U9XCIjNjBhNWZhXCIgc3Ryb2tlV2lkdGg9XCIyXCIgc3Ryb2tlRGFzaGFycmF5PVwiNSw1XCIgbWFya2VyRW5kPVwidXJsKCNhcnJvdylcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cIngxXCIgZnJvbT1cIi0xMDBcIiB0bz1cIjEwMCVcIiBkdXI9XCIyc1wiIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saW5lPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lIHgxPVwiMFwiIHkxPVwiNjAlXCIgeDI9XCIxMDAlXCIgeTI9XCI4MCVcIiBzdHJva2U9XCIjNjBhNWZhXCIgc3Ryb2tlV2lkdGg9XCIyXCIgc3Ryb2tlRGFzaGFycmF5PVwiNSw1XCIgbWFya2VyRW5kPVwidXJsKCNhcnJvdylcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cIngxXCIgZnJvbT1cIi0xMDBcIiB0bz1cIjEwMCVcIiBkdXI9XCIzc1wiIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saW5lPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcblxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gU2ltVG9nZ2xlKHsgbGFiZWwsIGFjdGl2ZSwgb25DbGljayB9OiBhbnkpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrfVxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMTAsIGJvcmRlclJhZGl1czogOCwgYm9yZGVyOiAnMXB4IHNvbGlkJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBhY3RpdmUgPyAnIzNiODJmNicgOiAnIzMzNDE1NScsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBhY3RpdmUgPyAncmdiYSg1OSwgMTMwLCAyNDYsIDAuMiknIDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBhY3RpdmUgPyAnIzYwYTVmYScgOiAnIzk0YTNiOCcsXHJcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJywgdGV4dEFsaWduOiAnbGVmdCcsIGZvbnRXZWlnaHQ6ICdib2xkJ1xyXG4gICAgICAgICAgICB9fT5cclxuICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gRHJhZ2dhYmxlSXRlbSh7IHR5cGUsIGljb24sIG9uRHJhZ1N0YXJ0IH06IGFueSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIGRyYWdnYWJsZVxyXG4gICAgICAgICAgICBvbkRyYWdTdGFydD17KGUpID0+IG9uRHJhZ1N0YXJ0KGUsIHR5cGUpfVxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMTUsIGJhY2tncm91bmQ6ICcjMzM0MTU1JywgYm9yZGVyUmFkaXVzOiA4LFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLCBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGdhcDogNSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2dyYWInXHJcbiAgICAgICAgICAgIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRTaXplOiAyNCB9fT57aWNvbn08L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250U2l6ZTogMTIgfX0+e3R5cGV9PC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBSb29tKHsgbmFtZSB9OiBhbnkpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17eyBib3JkZXI6ICcxcHggc29saWQgI2UyZThmMCcsIGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJywgY29sb3I6ICcjOTRhM2I4JywgZm9udFNpemU6IDE0LCBmb250V2VpZ2h0OiAnYm9sZCcgfX0+XHJcbiAgICAgICAgICAgIHtuYW1lfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsIkFQSVByb3ZpZGVyIiwiTWFwIiwiSWNvbnMiLCJTdW4iLCJzcGFuIiwiV2luZCIsIlZhc3R1IiwiRnVybml0dXJlIiwiQmFjayIsIlRPV0VSX0NPTkZJRyIsImZsb29ycyIsInVuaXRzUGVyRmxvb3IiLCJ1bml0VHlwZXMiLCJEaWdpdGFsVHdpblBhZ2UiLCJwYXJhbXMiLCJ2aWV3TGV2ZWwiLCJzZXRWaWV3TGV2ZWwiLCJzZWxlY3RlZFVuaXQiLCJzZXRTZWxlY3RlZFVuaXQiLCJjdXJyZW50VGltZSIsInNldEN1cnJlbnRUaW1lIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dPT0dMRV9NQVBTX0tFWSIsImRpdiIsInN0eWxlIiwiaGVpZ2h0IiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJmb250RmFtaWx5IiwiYmFja2dyb3VuZCIsImNvbG9yIiwicGFkZGluZyIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsImJvcmRlckJvdHRvbSIsImdhcCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJwcmV2IiwiYm9yZGVyIiwiY3Vyc29yIiwiZm9udFNpemUiLCJoMiIsIm1hcmdpbiIsImlucHV0IiwidHlwZSIsIm1pbiIsIm1heCIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwicGFyc2VJbnQiLCJ0YXJnZXQiLCJ3aWR0aCIsImZsZXgiLCJvdmVyZmxvdyIsInBvc2l0aW9uIiwiZGVmYXVsdENlbnRlciIsImxhdCIsImxuZyIsImRlZmF1bHRab29tIiwibWFwVHlwZUlkIiwiZGlzYWJsZURlZmF1bHRVSSIsInRvcCIsImxlZnQiLCJib3JkZXJSYWRpdXMiLCJiYWNrZHJvcEZpbHRlciIsImFuaW1hdGlvbiIsImZvbnRXZWlnaHQiLCJUb3dlclZpZXciLCJvblNlbGVjdFVuaXQiLCJ1bml0IiwiVW5pdEludGVyaW9yRGVzaWduZXIiLCJ1bml0SWQiLCJ0aW1lIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJvdmVyZmxvd1kiLCJwYWRkaW5nUmlnaHQiLCJoMyIsInBhZGRpbmdCb3R0b20iLCJtYXAiLCJmbG9vciIsInUiLCJ0cmFuc2l0aW9uIiwib25Nb3VzZUVudGVyIiwiY3VycmVudFRhcmdldCIsIm9uTW91c2VMZWF2ZSIsInAiLCJtYXJnaW5Ub3AiLCJsYXllcnMiLCJzZXRMYXllcnMiLCJ2YXN0dSIsIndpbmQiLCJzdW4iLCJmdXJuaXR1cmUiLCJzZXRGdXJuaXR1cmUiLCJ0b2dnbGUiLCJsIiwiaGFuZGxlRHJhZ1N0YXJ0IiwiZGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsImhhbmRsZURyb3AiLCJnZXREYXRhIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJpZCIsIkRhdGUiLCJub3ciLCJzdW5PcGFjaXR5Iiwic3VuQW5nbGUiLCJoNCIsIm1hcmdpbkJvdHRvbSIsIlNpbVRvZ2dsZSIsImxhYmVsIiwiYWN0aXZlIiwiZ3JpZFRlbXBsYXRlQ29sdW1ucyIsIkRyYWdnYWJsZUl0ZW0iLCJpY29uIiwib25EcmFnU3RhcnQiLCJvbkRyYWdPdmVyIiwicHJldmVudERlZmF1bHQiLCJvbkRyb3AiLCJib3hTaGFkb3ciLCJyaWdodCIsImJvdHRvbSIsImdyaWRUZW1wbGF0ZVJvd3MiLCJSb29tIiwibmFtZSIsImYiLCJpbnNldCIsInBvaW50ZXJFdmVudHMiLCJvcGFjaXR5IiwiY2xhc3NOYW1lIiwic3ZnIiwiZGVmcyIsIm1hcmtlciIsIm1hcmtlcldpZHRoIiwibWFya2VySGVpZ2h0IiwicmVmWCIsInJlZlkiLCJvcmllbnQiLCJwYXRoIiwiZCIsImZpbGwiLCJsaW5lIiwieDEiLCJ5MSIsIngyIiwieTIiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZURhc2hhcnJheSIsIm1hcmtlckVuZCIsImFuaW1hdGUiLCJhdHRyaWJ1dGVOYW1lIiwidG8iLCJkdXIiLCJyZXBlYXRDb3VudCIsImJvcmRlckNvbG9yIiwidGV4dEFsaWduIiwiZHJhZ2dhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/projects/[id]/twin/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n__webpack_require__(/*! client-only */ \"(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\n_c = React__default;\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/ function _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar isProd = typeof process !== \"undefined\" && process.env && \"development\" === \"production\";\nvar isString = function(o) {\n    return Object.prototype.toString.call(o) === \"[object String]\";\n};\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(param) {\n        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? \"stylesheet\" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;\n        invariant$1(isString(name), \"`name` must be a string\");\n        this._name = name;\n        this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n        invariant$1(typeof optimizeForSpeed === \"boolean\", \"`optimizeForSpeed` must be a boolean\");\n        this._optimizeForSpeed = optimizeForSpeed;\n        this._serverSheet = undefined;\n        this._tags = [];\n        this._injected = false;\n        this._rulesCount = 0;\n        var node =  true && document.querySelector('meta[property=\"csp-nonce\"]');\n        this._nonce = node ? node.getAttribute(\"content\") : null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n        invariant$1(typeof bool === \"boolean\", \"`setOptimizeForSpeed` accepts a boolean\");\n        invariant$1(this._rulesCount === 0, \"optimizeForSpeed cannot be when rules have already been inserted\");\n        this.flush();\n        this._optimizeForSpeed = bool;\n        this.inject();\n    };\n    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n        return this._optimizeForSpeed;\n    };\n    _proto.inject = function inject() {\n        var _this = this;\n        invariant$1(!this._injected, \"sheet already injected\");\n        this._injected = true;\n        if ( true && this._optimizeForSpeed) {\n            this._tags[0] = this.makeStyleTag(this._name);\n            this._optimizeForSpeed = \"insertRule\" in this.getSheet();\n            if (!this._optimizeForSpeed) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.\");\n                }\n                this.flush();\n                this._injected = true;\n            }\n            return;\n        }\n        this._serverSheet = {\n            cssRules: [],\n            insertRule: function(rule, index) {\n                if (typeof index === \"number\") {\n                    _this._serverSheet.cssRules[index] = {\n                        cssText: rule\n                    };\n                } else {\n                    _this._serverSheet.cssRules.push({\n                        cssText: rule\n                    });\n                }\n                return index;\n            },\n            deleteRule: function(index) {\n                _this._serverSheet.cssRules[index] = null;\n            }\n        };\n    };\n    _proto.getSheetForTag = function getSheetForTag(tag) {\n        if (tag.sheet) {\n            return tag.sheet;\n        }\n        // this weirdness brought to you by firefox\n        for(var i = 0; i < document.styleSheets.length; i++){\n            if (document.styleSheets[i].ownerNode === tag) {\n                return document.styleSheets[i];\n            }\n        }\n    };\n    _proto.getSheet = function getSheet() {\n        return this.getSheetForTag(this._tags[this._tags.length - 1]);\n    };\n    _proto.insertRule = function insertRule(rule, index) {\n        invariant$1(isString(rule), \"`insertRule` accepts only strings\");\n        if (false) {}\n        if (this._optimizeForSpeed) {\n            var sheet = this.getSheet();\n            if (typeof index !== \"number\") {\n                index = sheet.cssRules.length;\n            }\n            // this weirdness for perf, and chrome's weird bug\n            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                return -1;\n            }\n        } else {\n            var insertionPoint = this._tags[index];\n            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n        }\n        return this._rulesCount++;\n    };\n    _proto.replaceRule = function replaceRule(index, rule) {\n        if (this._optimizeForSpeed || \"object\" === \"undefined\") {\n            var sheet =  true ? this.getSheet() : 0;\n            if (!rule.trim()) {\n                rule = this._deletedRulePlaceholder;\n            }\n            if (!sheet.cssRules[index]) {\n                // @TBD Should we throw an error?\n                return index;\n            }\n            sheet.deleteRule(index);\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                // In order to preserve the indices we insert a deleteRulePlaceholder\n                sheet.insertRule(this._deletedRulePlaceholder, index);\n            }\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"old rule at index `\" + index + \"` not found\");\n            tag.textContent = rule;\n        }\n        return index;\n    };\n    _proto.deleteRule = function deleteRule(index) {\n        if (false) {}\n        if (this._optimizeForSpeed) {\n            this.replaceRule(index, \"\");\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"rule at index `\" + index + \"` not found\");\n            tag.parentNode.removeChild(tag);\n            this._tags[index] = null;\n        }\n    };\n    _proto.flush = function flush() {\n        this._injected = false;\n        this._rulesCount = 0;\n        if (true) {\n            this._tags.forEach(function(tag) {\n                return tag && tag.parentNode.removeChild(tag);\n            });\n            this._tags = [];\n        } else {}\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        if (false) {}\n        return this._tags.reduce(function(rules, tag) {\n            if (tag) {\n                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {\n                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;\n                }));\n            } else {\n                rules.push(null);\n            }\n            return rules;\n        }, []);\n    };\n    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n        if (cssString) {\n            invariant$1(isString(cssString), \"makeStyleTag accepts only strings as second parameter\");\n        }\n        var tag = document.createElement(\"style\");\n        if (this._nonce) tag.setAttribute(\"nonce\", this._nonce);\n        tag.type = \"text/css\";\n        tag.setAttribute(\"data-\" + name, \"\");\n        if (cssString) {\n            tag.appendChild(document.createTextNode(cssString));\n        }\n        var head = document.head || document.getElementsByTagName(\"head\")[0];\n        if (relativeToTag) {\n            head.insertBefore(tag, relativeToTag);\n        } else {\n            head.appendChild(tag);\n        }\n        return tag;\n    };\n    _createClass(StyleSheet, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this._rulesCount;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\nfunction invariant$1(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheet: \" + message + \".\");\n    }\n}\nfunction hash(str) {\n    var _$hash = 5381, i = str.length;\n    while(i){\n        _$hash = _$hash * 33 ^ str.charCodeAt(--i);\n    }\n    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;\n}\nvar stringHash = hash;\nvar sanitize = function(rule) {\n    return rule.replace(/\\/style/gi, \"\\\\/style\");\n};\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */ function computeId(baseId, props) {\n    if (!props) {\n        return \"jsx-\" + baseId;\n    }\n    var propsToString = String(props);\n    var key = baseId + propsToString;\n    if (!cache[key]) {\n        cache[key] = \"jsx-\" + stringHash(baseId + \"-\" + propsToString);\n    }\n    return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */ function computeSelector(id, css) {\n    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;\n    // Sanitize SSR-ed CSS.\n    // Client side code doesn't need to be sanitized since we use\n    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n    if (false) {}\n    var idcss = id + css;\n    if (!cache[idcss]) {\n        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n    }\n    return cache[idcss];\n}\nfunction mapRulesToStyle(cssRules, options) {\n    if (options === void 0) options = {};\n    return cssRules.map(function(args) {\n        var id = args[0];\n        var css = args[1];\n        return /*#__PURE__*/ React__default[\"default\"].createElement(\"style\", {\n            id: \"__\" + id,\n            // Avoid warnings upon render with a key\n            key: \"__\" + id,\n            nonce: options.nonce ? options.nonce : undefined,\n            dangerouslySetInnerHTML: {\n                __html: css\n            }\n        });\n    });\n}\nvar StyleSheetRegistry = /*#__PURE__*/ function() {\n    function StyleSheetRegistry(param) {\n        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;\n        this._sheet = styleSheet || new StyleSheet({\n            name: \"styled-jsx\",\n            optimizeForSpeed: optimizeForSpeed\n        });\n        this._sheet.inject();\n        if (styleSheet && typeof optimizeForSpeed === \"boolean\") {\n            this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    }\n    var _proto = StyleSheetRegistry.prototype;\n    _proto.add = function add(props) {\n        var _this = this;\n        if (undefined === this._optimizeForSpeed) {\n            this._optimizeForSpeed = Array.isArray(props.children);\n            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        if ( true && !this._fromServer) {\n            this._fromServer = this.selectFromServer();\n            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {\n                acc[tagName] = 0;\n                return acc;\n            }, {});\n        }\n        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;\n        // Deduping: just increase the instances count.\n        if (styleId in this._instancesCounts) {\n            this._instancesCounts[styleId] += 1;\n            return;\n        }\n        var indices = rules.map(function(rule) {\n            return _this._sheet.insertRule(rule);\n        }) // Filter out invalid rules\n        .filter(function(index) {\n            return index !== -1;\n        });\n        this._indices[styleId] = indices;\n        this._instancesCounts[styleId] = 1;\n    };\n    _proto.remove = function remove(props) {\n        var _this = this;\n        var styleId = this.getIdAndRules(props).styleId;\n        invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n        this._instancesCounts[styleId] -= 1;\n        if (this._instancesCounts[styleId] < 1) {\n            var tagFromServer = this._fromServer && this._fromServer[styleId];\n            if (tagFromServer) {\n                tagFromServer.parentNode.removeChild(tagFromServer);\n                delete this._fromServer[styleId];\n            } else {\n                this._indices[styleId].forEach(function(index) {\n                    return _this._sheet.deleteRule(index);\n                });\n                delete this._indices[styleId];\n            }\n            delete this._instancesCounts[styleId];\n        }\n    };\n    _proto.update = function update(props, nextProps) {\n        this.add(nextProps);\n        this.remove(props);\n    };\n    _proto.flush = function flush() {\n        this._sheet.flush();\n        this._sheet.inject();\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {\n            return [\n                styleId,\n                _this._fromServer[styleId]\n            ];\n        }) : [];\n        var cssRules = this._sheet.cssRules();\n        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {\n            return [\n                styleId,\n                _this._indices[styleId].map(function(index) {\n                    return cssRules[index].cssText;\n                }).join(_this._optimizeForSpeed ? \"\" : \"\\n\")\n            ];\n        }) // filter out empty rules\n        .filter(function(rule) {\n            return Boolean(rule[1]);\n        }));\n    };\n    _proto.styles = function styles(options) {\n        return mapRulesToStyle(this.cssRules(), options);\n    };\n    _proto.getIdAndRules = function getIdAndRules(props) {\n        var css = props.children, dynamic = props.dynamic, id = props.id;\n        if (dynamic) {\n            var styleId = computeId(id, dynamic);\n            return {\n                styleId: styleId,\n                rules: Array.isArray(css) ? css.map(function(rule) {\n                    return computeSelector(styleId, rule);\n                }) : [\n                    computeSelector(styleId, css)\n                ]\n            };\n        }\n        return {\n            styleId: computeId(id),\n            rules: Array.isArray(css) ? css : [\n                css\n            ]\n        };\n    };\n    /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */ _proto.selectFromServer = function selectFromServer() {\n        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n        return elements.reduce(function(acc, element) {\n            var id = element.id.slice(2);\n            acc[id] = element;\n            return acc;\n        }, {});\n    };\n    return StyleSheetRegistry;\n}();\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n    }\n}\nvar StyleSheetContext = /*#__PURE__*/ React.createContext(null);\nStyleSheetContext.displayName = \"StyleSheetContext\";\nfunction createStyleRegistry() {\n    return new StyleSheetRegistry();\n}\nfunction StyleRegistry(param) {\n    _s();\n    var configuredRegistry = param.registry, children = param.children;\n    var rootRegistry = React.useContext(StyleSheetContext);\n    var ref = React.useState(function() {\n        return rootRegistry || configuredRegistry || createStyleRegistry();\n    }), registry = ref[0];\n    return /*#__PURE__*/ React__default[\"default\"].createElement(StyleSheetContext.Provider, {\n        value: registry\n    }, children);\n}\n_s(StyleRegistry, \"vgRS4YV7PcSMQCYHzGaNuBIBcZQ=\");\n_c1 = StyleRegistry;\nfunction useStyleRegistry() {\n    _s1();\n    return React.useContext(StyleSheetContext);\n}\n_s1(useStyleRegistry, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = React__default[\"default\"].useInsertionEffect || React__default[\"default\"].useLayoutEffect;\nvar defaultRegistry =  true ? createStyleRegistry() : 0;\nfunction JSXStyle(props) {\n    _s2();\n    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();\n    // If `registry` does not exist, we do nothing here.\n    if (!registry) {\n        return null;\n    }\n    if (false) {}\n    useInsertionEffect(function() {\n        registry.add(props);\n        return function() {\n            registry.remove(props);\n        };\n    // props.children can be string[], will be striped since id is identical\n    }, [\n        props.id,\n        String(props.dynamic)\n    ]);\n    return null;\n}\n_s2(JSXStyle, \"48Sqj1BUqkshsPdz6NEWXDn8pF4=\", false, function() {\n    return [\n        useStyleRegistry,\n        useInsertionEffect\n    ];\n});\n_c2 = JSXStyle;\nJSXStyle.dynamic = function(info) {\n    return info.map(function(tagInfo) {\n        var baseId = tagInfo[0];\n        var props = tagInfo[1];\n        return computeId(baseId, props);\n    }).join(\" \");\n};\nexports.StyleRegistry = StyleRegistry;\nexports.createStyleRegistry = createStyleRegistry;\nexports.style = JSXStyle;\nexports.useStyleRegistry = useStyleRegistry;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"React__default\");\n$RefreshReg$(_c1, \"StyleRegistry\");\n$RefreshReg$(_c2, \"JSXStyle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7QUFBQUEsbUJBQU9BLENBQUM7QUFDUixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUVwQixTQUFTRSxzQkFBdUJDLENBQUM7SUFBSSxPQUFPQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQUUsV0FBV0E7SUFBRTtBQUFHO0FBRWpILElBQUlDLGlCQUFpQixXQUFXLEdBQUVGLHNCQUFzQkQ7O0FBRXhEOzs7QUFHQSxHQUFHLFNBQVNJLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQ3ZDLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUk7UUFDakMsSUFBSUUsYUFBYUgsS0FBSyxDQUFDQyxFQUFFO1FBQ3pCRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUNqREQsV0FBV0UsWUFBWSxHQUFHO1FBQzFCLElBQUksV0FBV0YsWUFBWUEsV0FBV0csUUFBUSxHQUFHO1FBQ2pEQyxPQUFPQyxjQUFjLENBQUNULFFBQVFJLFdBQVdNLEdBQUcsRUFBRU47SUFDbEQ7QUFDSjtBQUNBLFNBQVNPLGFBQWFDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQ3RELElBQUlELFlBQVlkLGtCQUFrQmEsWUFBWUcsU0FBUyxFQUFFRjtJQUN6RCxJQUFJQyxhQUFhZixrQkFBa0JhLGFBQWFFO0lBQ2hELE9BQU9GO0FBQ1g7QUFDQSxJQUFJSSxTQUFTLE9BQU9DLE9BQU9BLEtBQUssZUFBZUEsT0FBT0EsQ0FBQ0MsR0FBRyxJQUFJRCxrQkFBeUI7QUFDdkYsSUFBSUUsV0FBVyxTQUFTQyxDQUFDO0lBQ3JCLE9BQU9aLE9BQU9PLFNBQVMsQ0FBQ00sUUFBUSxDQUFDQyxJQUFJLENBQUNGLE9BQU87QUFDakQ7QUFDQSxJQUFJRyxhQUFhLFdBQVcsR0FB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Qkcsd0JBQXdCLEdBQUdQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanM/YjAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCdjbGllbnQtb25seScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xuXG4vKlxuQmFzZWQgb24gR2xhbW9yJ3Mgc2hlZXRcbmh0dHBzOi8vZ2l0aHViLmNvbS90aHJlZXBvaW50b25lL2dsYW1vci9ibG9iLzY2N2I0ODBkMzFiMzcyMWE5MDUwMjFiMjZlMTI5MGNlOTJjYTI4Nzkvc3JjL3NoZWV0LmpzXG4qLyBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbnZhciBpc1Byb2QgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbn07XG52YXIgU3R5bGVTaGVldCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldChwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9uYW1lID0gcmVmLm5hbWUsIG5hbWUgPSBfbmFtZSA9PT0gdm9pZCAwID8gXCJzdHlsZXNoZWV0XCIgOiBfbmFtZSwgX29wdGltaXplRm9yU3BlZWQgPSByZWYub3B0aW1pemVGb3JTcGVlZCwgb3B0aW1pemVGb3JTcGVlZCA9IF9vcHRpbWl6ZUZvclNwZWVkID09PSB2b2lkIDAgPyBpc1Byb2QgOiBfb3B0aW1pemVGb3JTcGVlZDtcbiAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcobmFtZSksIFwiYG5hbWVgIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID0gXCIjXCIgKyBuYW1lICsgXCItZGVsZXRlZC1ydWxlX19fX3t9XCI7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSBcImJvb2xlYW5cIiwgXCJgb3B0aW1pemVGb3JTcGVlZGAgbXVzdCBiZSBhIGJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBvcHRpbWl6ZUZvclNwZWVkO1xuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFncyA9IFtdO1xuICAgICAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgICAgICAgdGhpcy5fbm9uY2UgPSBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRPcHRpbWl6ZUZvclNwZWVkID0gZnVuY3Rpb24gc2V0T3B0aW1pemVGb3JTcGVlZChib29sKSB7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBib29sID09PSBcImJvb2xlYW5cIiwgXCJgc2V0T3B0aW1pemVGb3JTcGVlZGAgYWNjZXB0cyBhIGJvb2xlYW5cIik7XG4gICAgICAgIGludmFyaWFudCQxKHRoaXMuX3J1bGVzQ291bnQgPT09IDAsIFwib3B0aW1pemVGb3JTcGVlZCBjYW5ub3QgYmUgd2hlbiBydWxlcyBoYXZlIGFscmVhZHkgYmVlbiBpbnNlcnRlZFwiKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gYm9vbDtcbiAgICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9O1xuICAgIF9wcm90by5pc09wdGltaXplRm9yU3BlZWQgPSBmdW5jdGlvbiBpc09wdGltaXplRm9yU3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkO1xuICAgIH07XG4gICAgX3Byb3RvLmluamVjdCA9IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaW52YXJpYW50JDEoIXRoaXMuX2luamVjdGVkLCBcInNoZWV0IGFscmVhZHkgaW5qZWN0ZWRcIik7XG4gICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGFnc1swXSA9IHRoaXMubWFrZVN0eWxlVGFnKHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IFwiaW5zZXJ0UnVsZVwiIGluIHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IG9wdGltaXplRm9yU3BlZWQgbW9kZSBub3Qgc3VwcG9ydGVkIGZhbGxpbmcgYmFjayB0byBzdGFuZGFyZCBtb2RlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHtcbiAgICAgICAgICAgIGNzc1J1bGVzOiBbXSxcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IGZ1bmN0aW9uKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXNbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogcnVsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVSdWxlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmdldFNoZWV0Rm9yVGFnID0gZnVuY3Rpb24gZ2V0U2hlZXRGb3JUYWcodGFnKSB7XG4gICAgICAgIGlmICh0YWcuc2hlZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyB3ZWlyZG5lc3MgYnJvdWdodCB0byB5b3UgYnkgZmlyZWZveFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldLm93bmVyTm9kZSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U2hlZXQgPSBmdW5jdGlvbiBnZXRTaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hlZXRGb3JUYWcodGhpcy5fdGFnc1t0aGlzLl90YWdzLmxlbmd0aCAtIDFdKTtcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCkge1xuICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhydWxlKSwgXCJgaW5zZXJ0UnVsZWAgYWNjZXB0cyBvbmx5IHN0cmluZ3NcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgICAgIHZhciBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgd2VpcmRuZXNzIGZvciBwZXJmLCBhbmQgY2hyb21lJ3Mgd2VpcmQgYnVnXG4gICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDAwNzk5Mi9jaHJvbWUtc3VkZGVubHktc3RvcHBlZC1hY2NlcHRpbmctaW5zZXJ0cnVsZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogaWxsZWdhbCBydWxlOiBcXG5cXG5cIiArIHJ1bGUgKyBcIlxcblxcblNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjAwMDc5OTIgZm9yIG1vcmUgaW5mb1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLl90YWdzLnB1c2godGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSwgcnVsZSwgaW5zZXJ0aW9uUG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZXNDb3VudCsrO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUoaW5kZXgsIHJ1bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuZ2V0U2hlZXQoKSA6IHRoaXMuX3NlcnZlclNoZWV0O1xuICAgICAgICAgICAgaWYgKCFydWxlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIHJ1bGUgPSB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGVldC5jc3NSdWxlc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBAVEJEIFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IGlsbGVnYWwgcnVsZTogXFxuXFxuXCIgKyBydWxlICsgXCJcXG5cXG5TZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzIwMDA3OTkyIGZvciBtb3JlIGluZm9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBpbmRpY2VzIHdlIGluc2VydCBhIGRlbGV0ZVJ1bGVQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUodGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgICAgICAgaW52YXJpYW50JDEodGFnLCBcIm9sZCBydWxlIGF0IGluZGV4IGBcIiArIGluZGV4ICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHRhZy50ZXh0Q29udGVudCA9IHJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUnVsZShpbmRleCwgXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSh0YWcsIFwicnVsZSBhdCBpbmRleCBgXCIgKyBpbmRleCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgdGhpcy5fdGFnc1tpbmRleF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcnVsZXNDb3VudCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl90YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZyAmJiB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90YWdzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaW1wbGVyIG9uIHNlcnZlclxuICAgICAgICAgICAgdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNzc1J1bGVzID0gZnVuY3Rpb24gY3NzUnVsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ3MucmVkdWNlKGZ1bmN0aW9uKHJ1bGVzLCB0YWcpIHtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoX3RoaXMuZ2V0U2hlZXRGb3JUYWcodGFnKS5jc3NSdWxlcywgZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS5jc3NUZXh0ID09PSBfdGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciA/IG51bGwgOiBydWxlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgX3Byb3RvLm1ha2VTdHlsZVRhZyA9IGZ1bmN0aW9uIG1ha2VTdHlsZVRhZyhuYW1lLCBjc3NTdHJpbmcsIHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgaWYgKGNzc1N0cmluZykge1xuICAgICAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcoY3NzU3RyaW5nKSwgXCJtYWtlU3R5bGVUYWcgYWNjZXB0cyBvbmx5IHN0cmluZ3MgYXMgc2Vjb25kIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAodGhpcy5fbm9uY2UpIHRhZy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0aGlzLl9ub25jZSk7XG4gICAgICAgIHRhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICB0YWcuc2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUsIFwiXCIpO1xuICAgICAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHRhZywgcmVsYXRpdmVUb1RhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhTdHlsZVNoZWV0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5mdW5jdGlvbiBpbnZhcmlhbnQkMShjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0OiBcIiArIG1lc3NhZ2UgKyBcIi5cIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIHZhciBfJGhhc2ggPSA1MzgxLCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZShpKXtcbiAgICAgICAgXyRoYXNoID0gXyRoYXNoICogMzMgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgKiBzaWduZWQgaW50IHRvIGFuIHVuc2lnbmVkIGJ5IGRvaW5nIGFuIHVuc2lnbmVkIGJpdHNoaWZ0LiAqLyByZXR1cm4gXyRoYXNoID4+PiAwO1xufVxudmFyIHN0cmluZ0hhc2ggPSBoYXNoO1xuXG52YXIgc2FuaXRpemUgPSBmdW5jdGlvbihydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUucmVwbGFjZSgvXFwvc3R5bGUvZ2ksIFwiXFxcXC9zdHlsZVwiKTtcbn07XG52YXIgY2FjaGUgPSB7fTtcbi8qKlxuICogY29tcHV0ZUlkXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBhIGpzeCBpZCBmcm9tIGEgYmFzZWRJZCBhbmQgb3B0aW9uYWxseSBwcm9wcy5cbiAqLyBmdW5jdGlvbiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIFwianN4LVwiICsgYmFzZUlkO1xuICAgIH1cbiAgICB2YXIgcHJvcHNUb1N0cmluZyA9IFN0cmluZyhwcm9wcyk7XG4gICAgdmFyIGtleSA9IGJhc2VJZCArIHByb3BzVG9TdHJpbmc7XG4gICAgaWYgKCFjYWNoZVtrZXldKSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSBcImpzeC1cIiArIHN0cmluZ0hhc2goYmFzZUlkICsgXCItXCIgKyBwcm9wc1RvU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG59XG4vKipcbiAqIGNvbXB1dGVTZWxlY3RvclxuICpcbiAqIENvbXB1dGUgYW5kIG1lbW9pemUgZHluYW1pYyBzZWxlY3RvcnMuXG4gKi8gZnVuY3Rpb24gY29tcHV0ZVNlbGVjdG9yKGlkLCBjc3MpIHtcbiAgICB2YXIgc2VsZWN0b1BsYWNlaG9sZGVyUmVnZXhwID0gL19fanN4LXN0eWxlLWR5bmFtaWMtc2VsZWN0b3IvZztcbiAgICAvLyBTYW5pdGl6ZSBTU1ItZWQgQ1NTLlxuICAgIC8vIENsaWVudCBzaWRlIGNvZGUgZG9lc24ndCBuZWVkIHRvIGJlIHNhbml0aXplZCBzaW5jZSB3ZSB1c2VcbiAgICAvLyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSAoZGV2KSBhbmQgdGhlIENTU09NIGFwaSBzaGVldC5pbnNlcnRSdWxlIChwcm9kKS5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjc3MgPSBzYW5pdGl6ZShjc3MpO1xuICAgIH1cbiAgICB2YXIgaWRjc3MgPSBpZCArIGNzcztcbiAgICBpZiAoIWNhY2hlW2lkY3NzXSkge1xuICAgICAgICBjYWNoZVtpZGNzc10gPSBjc3MucmVwbGFjZShzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAsIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2lkY3NzXTtcbn1cblxuZnVuY3Rpb24gbWFwUnVsZXNUb1N0eWxlKGNzc1J1bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHJldHVybiBjc3NSdWxlcy5tYXAoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaWQgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgY3NzID0gYXJnc1sxXTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7XG4gICAgICAgICAgICBpZDogXCJfX1wiICsgaWQsXG4gICAgICAgICAgICAvLyBBdm9pZCB3YXJuaW5ncyB1cG9uIHJlbmRlciB3aXRoIGEga2V5XG4gICAgICAgICAgICBrZXk6IFwiX19cIiArIGlkLFxuICAgICAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgICAgICBfX2h0bWw6IGNzc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbnZhciBTdHlsZVNoZWV0UmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlU2hlZXRSZWdpc3RyeShwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9zdHlsZVNoZWV0ID0gcmVmLnN0eWxlU2hlZXQsIHN0eWxlU2hlZXQgPSBfc3R5bGVTaGVldCA9PT0gdm9pZCAwID8gbnVsbCA6IF9zdHlsZVNoZWV0LCBfb3B0aW1pemVGb3JTcGVlZCA9IHJlZi5vcHRpbWl6ZUZvclNwZWVkLCBvcHRpbWl6ZUZvclNwZWVkID0gX29wdGltaXplRm9yU3BlZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGltaXplRm9yU3BlZWQ7XG4gICAgICAgIHRoaXMuX3NoZWV0ID0gc3R5bGVTaGVldCB8fCBuZXcgU3R5bGVTaGVldCh7XG4gICAgICAgICAgICBuYW1lOiBcInN0eWxlZC1qc3hcIixcbiAgICAgICAgICAgIG9wdGltaXplRm9yU3BlZWQ6IG9wdGltaXplRm9yU3BlZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuICAgICAgICBpZiAoc3R5bGVTaGVldCAmJiB0eXBlb2Ygb3B0aW1pemVGb3JTcGVlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoZWV0LnNldE9wdGltaXplRm9yU3BlZWQob3B0aW1pemVGb3JTcGVlZCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXRSZWdpc3RyeS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB0aGlzLl9zaGVldC5zZXRPcHRpbWl6ZUZvclNwZWVkKHRoaXMuX29wdGltaXplRm9yU3BlZWQpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IHRoaXMuX3NoZWV0LmlzT3B0aW1pemVGb3JTcGVlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICF0aGlzLl9mcm9tU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdGhpcy5zZWxlY3RGcm9tU2VydmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgYWNjW3RhZ05hbWVdID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSB0aGlzLmdldElkQW5kUnVsZXMocHJvcHMpLCBzdHlsZUlkID0gcmVmLnN0eWxlSWQsIHJ1bGVzID0gcmVmLnJ1bGVzO1xuICAgICAgICAvLyBEZWR1cGluZzoganVzdCBpbmNyZWFzZSB0aGUgaW5zdGFuY2VzIGNvdW50LlxuICAgICAgICBpZiAoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSArPSAxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRpY2VzID0gcnVsZXMubWFwKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hlZXQuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgICAgfSkvLyBGaWx0ZXIgb3V0IGludmFsaWQgcnVsZXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0gPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gPSAxO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3R5bGVJZCA9IHRoaXMuZ2V0SWRBbmRSdWxlcyhwcm9wcykuc3R5bGVJZDtcbiAgICAgICAgaW52YXJpYW50KHN0eWxlSWQgaW4gdGhpcy5faW5zdGFuY2VzQ291bnRzLCBcInN0eWxlSWQ6IGBcIiArIHN0eWxlSWQgKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSA8IDEpIHtcbiAgICAgICAgICAgIHZhciB0YWdGcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciAmJiB0aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdO1xuICAgICAgICAgICAgaWYgKHRhZ0Zyb21TZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0YWdGcm9tU2VydmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnRnJvbVNlcnZlcik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0uZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3NoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuYWRkKG5leHRQcm9wcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKHByb3BzKTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9zaGVldC5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9zaGVldC5pbmplY3QoKTtcbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5jc3NSdWxlcyA9IGZ1bmN0aW9uIGNzc1J1bGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJvbVNlcnZlciA9IHRoaXMuX2Zyb21TZXJ2ZXIgPyBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5tYXAoZnVuY3Rpb24oc3R5bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIF90aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLl9zaGVldC5jc3NSdWxlcygpO1xuICAgICAgICByZXR1cm4gZnJvbVNlcnZlci5jb25jYXQoT2JqZWN0LmtleXModGhpcy5faW5kaWNlcykubWFwKGZ1bmN0aW9uKHN0eWxlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5kaWNlc1tzdHlsZUlkXS5tYXAoZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzc1J1bGVzW2luZGV4XS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oX3RoaXMuX29wdGltaXplRm9yU3BlZWQgPyBcIlwiIDogXCJcXG5cIilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pLy8gZmlsdGVyIG91dCBlbXB0eSBydWxlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHJ1bGVbMV0pO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1hcFJ1bGVzVG9TdHlsZSh0aGlzLmNzc1J1bGVzKCksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkQW5kUnVsZXMgPSBmdW5jdGlvbiBnZXRJZEFuZFJ1bGVzKHByb3BzKSB7XG4gICAgICAgIHZhciBjc3MgPSBwcm9wcy5jaGlsZHJlbiwgZHluYW1pYyA9IHByb3BzLmR5bmFtaWMsIGlkID0gcHJvcHMuaWQ7XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVJZCA9IGNvbXB1dGVJZChpZCwgZHluYW1pYyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgcnVsZXM6IEFycmF5LmlzQXJyYXkoY3NzKSA/IGNzcy5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHV0ZVNlbGVjdG9yKHN0eWxlSWQsIHJ1bGUpO1xuICAgICAgICAgICAgICAgIH0pIDogW1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgY3NzKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0eWxlSWQ6IGNvbXB1dGVJZChpZCksXG4gICAgICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzIDogW1xuICAgICAgICAgICAgICAgIGNzc1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAqIHNlbGVjdEZyb21TZXJ2ZXJcbiAgICpcbiAgICogQ29sbGVjdHMgc3R5bGUgdGFncyBmcm9tIHRoZSBkb2N1bWVudCB3aXRoIGlkIF9fanN4LVhYWFxuICAgKi8gX3Byb3RvLnNlbGVjdEZyb21TZXJ2ZXIgPSBmdW5jdGlvbiBzZWxlY3RGcm9tU2VydmVyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWRePVwiX19qc3gtXCJdJykpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudC5pZC5zbGljZSgyKTtcbiAgICAgICAgICAgIGFjY1tpZF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlU2hlZXRSZWdpc3RyeTtcbn0oKTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0UmVnaXN0cnk6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgICB9XG59XG52YXIgU3R5bGVTaGVldENvbnRleHQgPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5TdHlsZVNoZWV0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiU3R5bGVTaGVldENvbnRleHRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZVNoZWV0UmVnaXN0cnkoKTtcbn1cbmZ1bmN0aW9uIFN0eWxlUmVnaXN0cnkocGFyYW0pIHtcbiAgICB2YXIgY29uZmlndXJlZFJlZ2lzdHJ5ID0gcGFyYW0ucmVnaXN0cnksIGNoaWxkcmVuID0gcGFyYW0uY2hpbGRyZW47XG4gICAgdmFyIHJvb3RSZWdpc3RyeSA9IFJlYWN0LnVzZUNvbnRleHQoU3R5bGVTaGVldENvbnRleHQpO1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RSZWdpc3RyeSB8fCBjb25maWd1cmVkUmVnaXN0cnkgfHwgY3JlYXRlU3R5bGVSZWdpc3RyeSgpO1xuICAgIH0pLCByZWdpc3RyeSA9IHJlZlswXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTdHlsZVNoZWV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcmVnaXN0cnlcbiAgICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1c2VTdHlsZVJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFN0eWxlU2hlZXRDb250ZXh0KTtcbn1cblxuLy8gT3B0LWludG8gdGhlIG5ldyBgdXNlSW5zZXJ0aW9uRWZmZWN0YCBBUEkgaW4gUmVhY3QgMTgsIGZhbGxiYWNrIHRvIGB1c2VMYXlvdXRFZmZlY3RgLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvMTEwXG52YXIgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVzZUluc2VydGlvbkVmZmVjdCB8fCBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlTGF5b3V0RWZmZWN0O1xudmFyIGRlZmF1bHRSZWdpc3RyeSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBKU1hTdHlsZShwcm9wcykge1xuICAgIHZhciByZWdpc3RyeSA9IGRlZmF1bHRSZWdpc3RyeSA/IGRlZmF1bHRSZWdpc3RyeSA6IHVzZVN0eWxlUmVnaXN0cnkoKTtcbiAgICAvLyBJZiBgcmVnaXN0cnlgIGRvZXMgbm90IGV4aXN0LCB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgaWYgKCFyZWdpc3RyeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVzZUluc2VydGlvbkVmZmVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVnaXN0cnkucmVtb3ZlKHByb3BzKTtcbiAgICAgICAgfTtcbiAgICAvLyBwcm9wcy5jaGlsZHJlbiBjYW4gYmUgc3RyaW5nW10sIHdpbGwgYmUgc3RyaXBlZCBzaW5jZSBpZCBpcyBpZGVudGljYWxcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLmlkLFxuICAgICAgICBTdHJpbmcocHJvcHMuZHluYW1pYylcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbkpTWFN0eWxlLmR5bmFtaWMgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ubWFwKGZ1bmN0aW9uKHRhZ0luZm8pIHtcbiAgICAgICAgdmFyIGJhc2VJZCA9IHRhZ0luZm9bMF07XG4gICAgICAgIHZhciBwcm9wcyA9IHRhZ0luZm9bMV07XG4gICAgICAgIHJldHVybiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcyk7XG4gICAgfSkuam9pbihcIiBcIik7XG59O1xuXG5leHBvcnRzLlN0eWxlUmVnaXN0cnkgPSBTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5jcmVhdGVTdHlsZVJlZ2lzdHJ5ID0gY3JlYXRlU3R5bGVSZWdpc3RyeTtcbmV4cG9ydHMuc3R5bGUgPSBKU1hTdHlsZTtcbmV4cG9ydHMudXNlU3R5bGVSZWdpc3RyeSA9IHVzZVN0eWxlUmVnaXN0cnk7XG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIlJlYWN0IiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIlJlYWN0X19kZWZhdWx0IiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImlzUHJvZCIsInByb2Nlc3MiLCJlbnYiLCJpc1N0cmluZyIsIm8iLCJ0b1N0cmluZyIsImNhbGwiLCJTdHlsZVNoZWV0IiwicGFyYW0iLCJyZWYiLCJfbmFtZSIsIm5hbWUiLCJfb3B0aW1pemVGb3JTcGVlZCIsIm9wdGltaXplRm9yU3BlZWQiLCJpbnZhcmlhbnQkMSIsIl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyIiwiX3NlcnZlclNoZWV0IiwidW5kZWZpbmVkIiwiX3RhZ3MiLCJfaW5qZWN0ZWQiLCJfcnVsZXNDb3VudCIsIm5vZGUiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJfbm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJfcHJvdG8iLCJzZXRPcHRpbWl6ZUZvclNwZWVkIiwiYm9vbCIsImZsdXNoIiwiaW5qZWN0IiwiaXNPcHRpbWl6ZUZvclNwZWVkIiwiX3RoaXMiLCJtYWtlU3R5bGVUYWciLCJnZXRTaGVldCIsImNvbnNvbGUiLCJ3YXJuIiwiY3NzUnVsZXMiLCJpbnNlcnRSdWxlIiwicnVsZSIsImluZGV4IiwiY3NzVGV4dCIsInB1c2giLCJkZWxldGVSdWxlIiwiZ2V0U2hlZXRGb3JUYWciLCJ0YWciLCJzaGVldCIsInN0eWxlU2hlZXRzIiwib3duZXJOb2RlIiwiZXJyb3IiLCJpbnNlcnRpb25Qb2ludCIsInJlcGxhY2VSdWxlIiwidHJpbSIsInRleHRDb250ZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZm9yRWFjaCIsInJlZHVjZSIsInJ1bGVzIiwiY29uY2F0IiwiQXJyYXkiLCJtYXAiLCJjc3NTdHJpbmciLCJyZWxhdGl2ZVRvVGFnIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInR5cGUiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiaGFzaCIsInN0ciIsIl8kaGFzaCIsImNoYXJDb2RlQXQiLCJzdHJpbmdIYXNoIiwic2FuaXRpemUiLCJyZXBsYWNlIiwiY2FjaGUiLCJjb21wdXRlSWQiLCJiYXNlSWQiLCJwcm9wc1RvU3RyaW5nIiwiU3RyaW5nIiwiY29tcHV0ZVNlbGVjdG9yIiwiaWQiLCJjc3MiLCJzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAiLCJpZGNzcyIsIm1hcFJ1bGVzVG9TdHlsZSIsIm9wdGlvbnMiLCJhcmdzIiwibm9uY2UiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsIlN0eWxlU2hlZXRSZWdpc3RyeSIsIl9zdHlsZVNoZWV0Iiwic3R5bGVTaGVldCIsIl9zaGVldCIsIl9mcm9tU2VydmVyIiwiX2luZGljZXMiLCJfaW5zdGFuY2VzQ291bnRzIiwiYWRkIiwiaXNBcnJheSIsImNoaWxkcmVuIiwic2VsZWN0RnJvbVNlcnZlciIsImtleXMiLCJhY2MiLCJ0YWdOYW1lIiwiZ2V0SWRBbmRSdWxlcyIsInN0eWxlSWQiLCJpbmRpY2VzIiwiZmlsdGVyIiwicmVtb3ZlIiwiaW52YXJpYW50IiwidGFnRnJvbVNlcnZlciIsInVwZGF0ZSIsIm5leHRQcm9wcyIsImZyb21TZXJ2ZXIiLCJqb2luIiwiQm9vbGVhbiIsInN0eWxlcyIsImR5bmFtaWMiLCJlbGVtZW50cyIsInNsaWNlIiwicXVlcnlTZWxlY3RvckFsbCIsImVsZW1lbnQiLCJTdHlsZVNoZWV0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsImNyZWF0ZVN0eWxlUmVnaXN0cnkiLCJTdHlsZVJlZ2lzdHJ5IiwiY29uZmlndXJlZFJlZ2lzdHJ5IiwicmVnaXN0cnkiLCJyb290UmVnaXN0cnkiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJQcm92aWRlciIsInZhbHVlIiwidXNlU3R5bGVSZWdpc3RyeSIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImRlZmF1bHRSZWdpc3RyeSIsIkpTWFN0eWxlIiwiaW5mbyIsInRhZ0luZm8iLCJleHBvcnRzIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./dist/index */ \"(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\").style;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsbUlBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzPzM3MGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXgnKS5zdHlsZVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/style.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APILoadingStatus: function() { return /* binding */ APILoadingStatus; },\n/* harmony export */   APIProvider: function() { return /* binding */ APIProvider; },\n/* harmony export */   APIProviderContext: function() { return /* binding */ APIProviderContext; },\n/* harmony export */   AdvancedMarker: function() { return /* binding */ AdvancedMarker; },\n/* harmony export */   AdvancedMarkerAnchorPoint: function() { return /* binding */ AdvancedMarkerAnchorPoint; },\n/* harmony export */   AdvancedMarkerContext: function() { return /* binding */ AdvancedMarkerContext; },\n/* harmony export */   CollisionBehavior: function() { return /* binding */ CollisionBehavior; },\n/* harmony export */   ColorScheme: function() { return /* binding */ ColorScheme; },\n/* harmony export */   ControlPosition: function() { return /* binding */ ControlPosition; },\n/* harmony export */   GoogleMapsContext: function() { return /* binding */ GoogleMapsContext; },\n/* harmony export */   InfoWindow: function() { return /* binding */ InfoWindow; },\n/* harmony export */   Map: function() { return /* binding */ Map; },\n/* harmony export */   MapControl: function() { return /* binding */ MapControl; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   Pin: function() { return /* binding */ Pin; },\n/* harmony export */   RenderingType: function() { return /* binding */ RenderingType; },\n/* harmony export */   StaticMap: function() { return /* binding */ StaticMap; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   createStaticMapsUrl: function() { return /* binding */ createStaticMapsUrl; },\n/* harmony export */   isAdvancedMarker: function() { return /* binding */ isAdvancedMarker; },\n/* harmony export */   isLatLngLiteral: function() { return /* binding */ isLatLngLiteral; },\n/* harmony export */   latLngEquals: function() { return /* binding */ latLngEquals; },\n/* harmony export */   limitTiltRange: function() { return /* binding */ limitTiltRange; },\n/* harmony export */   toLatLngLiteral: function() { return /* binding */ toLatLngLiteral; },\n/* harmony export */   useAdvancedMarkerRef: function() { return /* binding */ useAdvancedMarkerRef; },\n/* harmony export */   useApiIsLoaded: function() { return /* binding */ useApiIsLoaded; },\n/* harmony export */   useApiLoadingStatus: function() { return /* binding */ useApiLoadingStatus; },\n/* harmony export */   useMap: function() { return /* binding */ useMap; },\n/* harmony export */   useMapsLibrary: function() { return /* binding */ useMapsLibrary; },\n/* harmony export */   useMarkerRef: function() { return /* binding */ useMarkerRef; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(app-pages-browser)/./node_modules/fast-deep-equal/index.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$();\n\n\n\n// This file is automatically updated by the build process.\nconst VERSION = \"1.7.1\";\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst APILoadingStatus = {\n    NOT_LOADED: \"NOT_LOADED\",\n    LOADING: \"LOADING\",\n    LOADED: \"LOADED\",\n    FAILED: \"FAILED\",\n    AUTH_FAILURE: \"AUTH_FAILURE\"\n};\nconst MAPS_API_BASE_URL = \"https://maps.googleapis.com/maps/api/js\";\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */ class GoogleMapsApiLoader {\n    /**\n     * Loads the Maps JavaScript API with the specified parameters.\n     * Since the Maps library can only be loaded once per page, this will\n     * produce a warning when called multiple times with different\n     * parameters.\n     *\n     * The returned promise resolves when loading completes\n     * and rejects in case of an error or when the loading was aborted.\n     */ static load(params, onLoadingStatusChange) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const libraries = params.libraries ? params.libraries.split(\",\") : [];\n            const serializedParams = this.serializeParams(params);\n            this.listeners.push(onLoadingStatusChange);\n            // Note: if `google.maps.importLibrary` has been defined externally, we\n            //   assume that loading is complete and successful.\n            //   If it was defined by a previous call to this method, a warning\n            //   message is logged if there are differences in api-parameters used\n            //   for both calls.\n            if ((_b = (_a = window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary) {\n                // no serialized parameters means it was loaded externally\n                if (!this.serializedApiParams) {\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                }\n                this.notifyLoadingStatusListeners();\n            } else {\n                this.serializedApiParams = serializedParams;\n                this.initImportLibrary(params);\n            }\n            if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n                console.warn(\"[google-maps-api-loader] The maps API has already been loaded \" + \"with different parameters and will not be loaded again. Refresh the \" + \"page for new values to have effect.\");\n            }\n            const librariesToLoad = [\n                \"maps\",\n                ...libraries\n            ];\n            yield Promise.all(librariesToLoad.map((name)=>google.maps.importLibrary(name)));\n        });\n    }\n    /**\n     * Serialize the parameters used to load the library for easier comparison.\n     */ static serializeParams(params) {\n        return [\n            params.v,\n            params.key,\n            params.language,\n            params.region,\n            params.authReferrerPolicy,\n            params.solutionChannel\n        ].join(\"/\");\n    }\n    /**\n     * Creates the global `google.maps.importLibrary` function for bootstrapping.\n     * This is essentially a formatted version of the dynamic loading script\n     * from the official documentation with some minor adjustments.\n     *\n     * The created importLibrary function will load the Google Maps JavaScript API,\n     * which will then replace the `google.maps.importLibrary` function with the full\n     * implementation.\n     *\n     * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n     */ static initImportLibrary(params) {\n        if (!window.google) window.google = {};\n        if (!window.google.maps) window.google.maps = {};\n        if (window.google.maps[\"importLibrary\"]) {\n            console.error(\"[google-maps-api-loader-internal]: initImportLibrary must only be called once\");\n            return;\n        }\n        let apiPromise = null;\n        const loadApi = ()=>{\n            if (apiPromise) return apiPromise;\n            apiPromise = new Promise((resolve, reject)=>{\n                var _a;\n                const scriptElement = document.createElement(\"script\");\n                const urlParams = new URLSearchParams();\n                for (const [key, value] of Object.entries(params)){\n                    const urlParamName = key.replace(/[A-Z]/g, (t)=>\"_\" + t[0].toLowerCase());\n                    urlParams.set(urlParamName, String(value));\n                }\n                urlParams.set(\"loading\", \"async\");\n                urlParams.set(\"callback\", \"__googleMapsCallback__\");\n                scriptElement.async = true;\n                scriptElement.src = MAPS_API_BASE_URL + \"?\" + urlParams.toString();\n                scriptElement.nonce = ((_a = document.querySelector(\"script[nonce]\")) === null || _a === void 0 ? void 0 : _a.nonce) || \"\";\n                scriptElement.onerror = ()=>{\n                    this.loadingStatus = APILoadingStatus.FAILED;\n                    this.notifyLoadingStatusListeners();\n                    reject(new Error(\"The Google Maps JavaScript API could not load.\"));\n                };\n                window.__googleMapsCallback__ = ()=>{\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                    this.notifyLoadingStatusListeners();\n                    resolve();\n                };\n                window.gm_authFailure = ()=>{\n                    this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n                    this.notifyLoadingStatusListeners();\n                };\n                this.loadingStatus = APILoadingStatus.LOADING;\n                this.notifyLoadingStatusListeners();\n                document.head.append(scriptElement);\n            });\n            return apiPromise;\n        };\n        // for the first load, we declare an importLibrary function that will\n        // be overwritten once the api is loaded.\n        google.maps.importLibrary = (libraryName)=>loadApi().then(()=>google.maps.importLibrary(libraryName));\n    }\n    /**\n     * Calls all registered loadingStatusListeners after a status update.\n     */ static notifyLoadingStatusListeners() {\n        for (const fn of this.listeners){\n            fn(this.loadingStatus);\n        }\n    }\n}\n/**\n * The current loadingStatus of the API.\n */ GoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\n/**\n * A list of functions to be notified when the loading status changes.\n */ GoogleMapsApiLoader.listeners = [];\nconst DEFAULT_SOLUTION_CHANNEL = \"GMP_visgl_rgmlibrary_v1_default\";\nconst DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS = [\n    \"gmp_visgl_reactgooglemaps_v\".concat(VERSION)\n];\nconst APIProviderContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */ function useMapInstances() {\n    _s();\n    const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const addMapInstance = function(mapInstance) {\n        let id = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"default\";\n        setMapInstances((instances)=>Object.assign(Object.assign({}, instances), {\n                [id]: mapInstance\n            }));\n    };\n    const removeMapInstance = function() {\n        let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"default\";\n        setMapInstances((_a)=>{\n            var _b = id;\n            _a[_b];\n            var remaining = __rest(_a, [\n                typeof _b === \"symbol\" ? _b : _b + \"\"\n            ]);\n            return remaining;\n        });\n    };\n    const clearMapInstances = ()=>{\n        setMapInstances({});\n    };\n    return {\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances\n    };\n}\n_s(useMapInstances, \"hsntVWRr8sQi9gSPNtNDFGcwkPA=\");\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */ function useGoogleMapsApiLoader(props) {\n    _s1();\n    const { onLoad, onError, apiKey, version, libraries = [] } = props, otherApiParams = __rest(props, [\n        \"onLoad\",\n        \"onError\",\n        \"apiKey\",\n        \"version\",\n        \"libraries\"\n    ]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n    const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action)=>{\n        return loadedLibraries[action.name] ? loadedLibraries : Object.assign(Object.assign({}, loadedLibraries), {\n            [action.name]: action.value\n        });\n    }, {});\n    const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>libraries === null || libraries === void 0 ? void 0 : libraries.join(\",\"), [\n        libraries\n    ]);\n    const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>JSON.stringify(Object.assign({\n            apiKey,\n            version\n        }, otherApiParams)), [\n        apiKey,\n        version,\n        otherApiParams\n    ]);\n    const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name)=>__awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (loadedLibraries[name]) {\n                return loadedLibraries[name];\n            }\n            if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.importLibrary)) {\n                throw new Error(\"[api-provider-internal] importLibrary was called before \" + \"google.maps.importLibrary was defined.\");\n            }\n            const res = yield window.google.maps.importLibrary(name);\n            addLoadedLibrary({\n                name,\n                value: res\n            });\n            return res;\n        }), [\n        loadedLibraries\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        (()=>__awaiter(this, void 0, void 0, function*() {\n                try {\n                    const params = Object.assign({\n                        key: apiKey\n                    }, otherApiParams);\n                    if (version) params.v = version;\n                    if ((librariesString === null || librariesString === void 0 ? void 0 : librariesString.length) > 0) params.libraries = librariesString;\n                    if (params.channel === undefined || params.channel < 0 || params.channel > 999) delete params.channel;\n                    if (params.solutionChannel === undefined) params.solutionChannel = DEFAULT_SOLUTION_CHANNEL;\n                    else if (params.solutionChannel === \"\") delete params.solutionChannel;\n                    yield GoogleMapsApiLoader.load(params, (status)=>setStatus(status));\n                    for (const name of [\n                        \"core\",\n                        \"maps\",\n                        ...libraries\n                    ]){\n                        yield importLibrary(name);\n                    }\n                    if (onLoad) {\n                        onLoad();\n                    }\n                } catch (error) {\n                    if (onError) {\n                        onError(error);\n                    } else {\n                        console.error(\"<ApiProvider> failed to load the Google Maps JavaScript API\", error);\n                    }\n                }\n            }))();\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        apiKey,\n        librariesString,\n        serializedParams\n    ]);\n    return {\n        status,\n        loadedLibraries,\n        importLibrary\n    };\n}\n_s1(useGoogleMapsApiLoader, \"tAqGGf6QjsgSH4cSRTniCSFuVJo=\");\nfunction useInternalUsageAttributionIds(props) {\n    _s2();\n    const internalUsageAttributionIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disableUsageAttribution ? null : DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS, [\n        props.disableUsageAttribution\n    ]);\n    return internalUsageAttributionIds;\n}\n_s2(useInternalUsageAttributionIds, \"j25p1744kcrJvSmGtAPEaHx3Hhg=\");\n/**\n * Component to wrap the components from this library and load the Google Maps JavaScript API\n */ const APIProvider = (props)=>{\n    _s3();\n    const { children } = props, loaderProps = __rest(props, [\n        \"children\"\n    ]);\n    const { mapInstances, addMapInstance, removeMapInstance, clearMapInstances } = useMapInstances();\n    const { status, loadedLibraries, importLibrary } = useGoogleMapsApiLoader(loaderProps);\n    const internalUsageAttributionIds = useInternalUsageAttributionIds(loaderProps);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            mapInstances,\n            addMapInstance,\n            removeMapInstance,\n            clearMapInstances,\n            status,\n            loadedLibraries,\n            importLibrary,\n            internalUsageAttributionIds\n        }), [\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary,\n        internalUsageAttributionIds\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, {\n        value: contextValue\n    }, children);\n};\n_s3(APIProvider, \"S6wcp3Dcoe9TGIgaE2N+QRV0JO0=\", false, function() {\n    return [\n        useMapInstances,\n        useGoogleMapsApiLoader,\n        useInternalUsageAttributionIds\n    ];\n});\n_c = APIProvider;\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */ function useMapEvents(map, props) {\n    // note: calling a useEffect hook from within a loop is prohibited by the\n    // rules of hooks, but it's ok here since it's unconditional and the number\n    // and order of iterations is always strictly the same.\n    // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n    for (const propName of eventPropNames){\n        // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n        //   a proper solution seems way too complicated right now\n        const handler = props[propName];\n        const eventType = propNameToEventType[propName];\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            if (!map) return;\n            if (!handler) return;\n            const listener = google.maps.event.addListener(map, eventType, (ev)=>{\n                handler(createMapEvent(eventType, map, ev));\n            });\n            return ()=>listener.remove();\n        }, [\n            map,\n            eventType,\n            handler\n        ]);\n    }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */ function createMapEvent(type, map, srcEvent) {\n    var _a;\n    const ev = {\n        type,\n        map,\n        detail: {},\n        stoppable: false,\n        stop: ()=>{}\n    };\n    if (cameraEventTypes.includes(type)) {\n        const camEvent = ev;\n        const center = map.getCenter();\n        const zoom = map.getZoom();\n        const heading = map.getHeading() || 0;\n        const tilt = map.getTilt() || 0;\n        const bounds = map.getBounds();\n        if (!center || !bounds || !Number.isFinite(zoom)) {\n            console.warn(\"[createEvent] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n        }\n        camEvent.detail = {\n            center: (center === null || center === void 0 ? void 0 : center.toJSON()) || {\n                lat: 0,\n                lng: 0\n            },\n            zoom: zoom || 0,\n            heading: heading,\n            tilt: tilt,\n            bounds: (bounds === null || bounds === void 0 ? void 0 : bounds.toJSON()) || {\n                north: 90,\n                east: 180,\n                south: -90,\n                west: -180\n            }\n        };\n        return camEvent;\n    } else if (mouseEventTypes.includes(type)) {\n        if (!srcEvent) throw new Error(\"[createEvent] mouse events must provide a srcEvent\");\n        const mouseEvent = ev;\n        mouseEvent.domEvent = srcEvent.domEvent;\n        mouseEvent.stoppable = true;\n        mouseEvent.stop = ()=>srcEvent.stop();\n        mouseEvent.detail = {\n            latLng: ((_a = srcEvent.latLng) === null || _a === void 0 ? void 0 : _a.toJSON()) || null,\n            placeId: srcEvent.placeId\n        };\n        return mouseEvent;\n    }\n    return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */ const propNameToEventType = {\n    onBoundsChanged: \"bounds_changed\",\n    onCenterChanged: \"center_changed\",\n    onClick: \"click\",\n    onContextmenu: \"contextmenu\",\n    onDblclick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragend: \"dragend\",\n    onDragstart: \"dragstart\",\n    onHeadingChanged: \"heading_changed\",\n    onIdle: \"idle\",\n    onIsFractionalZoomEnabledChanged: \"isfractionalzoomenabled_changed\",\n    onMapCapabilitiesChanged: \"mapcapabilities_changed\",\n    onMapTypeIdChanged: \"maptypeid_changed\",\n    onMousemove: \"mousemove\",\n    onMouseout: \"mouseout\",\n    onMouseover: \"mouseover\",\n    onProjectionChanged: \"projection_changed\",\n    onRenderingTypeChanged: \"renderingtype_changed\",\n    onTilesLoaded: \"tilesloaded\",\n    onTiltChanged: \"tilt_changed\",\n    onZoomChanged: \"zoom_changed\",\n    // note: onCameraChanged is an alias for the bounds_changed event,\n    // since that is going to be fired in every situation where the camera is\n    // updated.\n    onCameraChanged: \"bounds_changed\"\n};\nconst cameraEventTypes = [\n    \"bounds_changed\",\n    \"center_changed\",\n    \"heading_changed\",\n    \"tilt_changed\",\n    \"zoom_changed\"\n];\nconst mouseEventTypes = [\n    \"click\",\n    \"contextmenu\",\n    \"dblclick\",\n    \"mousemove\",\n    \"mouseout\",\n    \"mouseover\"\n];\nconst eventPropNames = Object.keys(propNameToEventType);\n/**\n * A hook to store the previous value of a variable.\n * @param value The value to store\n * @returns The previous value\n */ function usePrevious(value) {\n    _s4();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    });\n    // eslint-disable-next-line react-hooks/refs\n    return ref.current;\n}\n_s4(usePrevious, \"8uVE59eA/r6b92xF80p7sH8rXLk=\");\nfunction useMemoized(value, isEqual) {\n    _s5();\n    const previous = usePrevious(value);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (previous && isEqual(previous, value)) {\n            return previous;\n        }\n        return value;\n    }, [\n        value,\n        previous,\n        isEqual\n    ]);\n}\n_s5(useMemoized, \"W2ZjP41u9xKWAlx4QuRg5jjNbZI=\", false, function() {\n    return [\n        usePrevious\n    ];\n});\nfunction useCustomCompareEffect(effect, dependencies, isEqual) {\n    _s6();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, [\n        useMemoized(dependencies, isEqual)\n    ]);\n}\n_s6(useCustomCompareEffect, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nfunction useDeepCompareEffect(effect, dependencies) {\n    _s7();\n    useCustomCompareEffect(effect, dependencies, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n}\n_s7(useDeepCompareEffect, \"mylLLUfHnSoueBnkTkWWeM9ilrA=\", false, function() {\n    return [\n        useCustomCompareEffect\n    ];\n});\nconst mapOptionKeys = new Set([\n    \"backgroundColor\",\n    \"clickableIcons\",\n    \"controlSize\",\n    \"disableDefaultUI\",\n    \"disableDoubleClickZoom\",\n    \"draggable\",\n    \"draggableCursor\",\n    \"draggingCursor\",\n    \"fullscreenControl\",\n    \"fullscreenControlOptions\",\n    \"gestureHandling\",\n    \"headingInteractionEnabled\",\n    \"isFractionalZoomEnabled\",\n    \"keyboardShortcuts\",\n    \"mapTypeControl\",\n    \"mapTypeControlOptions\",\n    \"mapTypeId\",\n    \"maxZoom\",\n    \"minZoom\",\n    \"noClear\",\n    \"panControl\",\n    \"panControlOptions\",\n    \"restriction\",\n    \"rotateControl\",\n    \"rotateControlOptions\",\n    \"scaleControl\",\n    \"scaleControlOptions\",\n    \"scrollwheel\",\n    \"streetView\",\n    \"streetViewControl\",\n    \"streetViewControlOptions\",\n    \"styles\",\n    \"tiltInteractionEnabled\",\n    \"zoomControl\",\n    \"zoomControlOptions\"\n]);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */ function useMapOptions(map, mapProps) {\n    _s8();\n    /* eslint-disable react-hooks/exhaustive-deps --\n     *\n     * The following effects aren't triggered when the map is changed.\n     * In that case, the values will be or have been passed to the map\n     * constructor via mapOptions.\n     */ const mapOptions = {};\n    const keys = Object.keys(mapProps);\n    for (const key of keys){\n        if (!mapOptionKeys.has(key)) continue;\n        mapOptions[key] = mapProps[key];\n    }\n    // update the map options when mapOptions is changed\n    // Note: due to the destructuring above, mapOptions will be seen as changed\n    //   with every re-render, so we're assuming the maps-api will properly\n    //   deal with unchanged option-values passed into setOptions.\n    useDeepCompareEffect(()=>{\n        if (!map) return;\n        map.setOptions(mapOptions);\n    }, [\n        mapOptions\n    ]);\n/* eslint-enable react-hooks/exhaustive-deps */ }\n_s8(useMapOptions, \"9P7jum8Mqo4RIt9ebKErbOvo2AQ=\", false, function() {\n    return [\n        useDeepCompareEffect\n    ];\n});\nfunction useApiLoadingStatus() {\n    _s9();\n    var _a;\n    return ((_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) === null || _a === void 0 ? void 0 : _a.status) || APILoadingStatus.NOT_LOADED;\n}\n_s9(useApiLoadingStatus, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */ function useDeckGLCameraUpdate(map, props) {\n    _s10();\n    const { viewport, viewState } = props;\n    const isDeckGlControlled = !!viewport;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !viewState) return;\n        const { latitude, longitude, bearing: heading, pitch: tilt, zoom } = viewState;\n        map.moveCamera({\n            center: {\n                lat: latitude,\n                lng: longitude\n            },\n            heading,\n            tilt,\n            zoom: zoom + 1\n        });\n    }, [\n        map,\n        viewState\n    ]);\n    return isDeckGlControlled;\n}\n_s10(useDeckGLCameraUpdate, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\nfunction isLatLngLiteral(obj) {\n    if (!obj || typeof obj !== \"object\") return false;\n    if (!(\"lat\" in obj && \"lng\" in obj)) return false;\n    return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n    if (!a || !b) return false;\n    const A = toLatLngLiteral(a);\n    const B = toLatLngLiteral(b);\n    if (A.lat !== B.lat || A.lng !== B.lng) return false;\n    return true;\n}\nfunction toLatLngLiteral(obj) {\n    if (isLatLngLiteral(obj)) return obj;\n    return obj.toJSON();\n}\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n    _s11();\n    const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const zoom = Number.isFinite(mapProps.zoom) ? mapProps.zoom : null;\n    const heading = Number.isFinite(mapProps.heading) ? mapProps.heading : null;\n    const tilt = Number.isFinite(mapProps.tilt) ? mapProps.tilt : null;\n    // the following effect runs for every render of the map component and checks\n    // if there are differences between the known state of the map instance\n    // (cameraStateRef, which is updated by all bounds_changed events) and the\n    // desired state in the props.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map) return;\n        const nextCamera = {};\n        let needsUpdate = false;\n        if (lat !== null && lng !== null && (cameraStateRef.current.center.lat !== lat || cameraStateRef.current.center.lng !== lng)) {\n            nextCamera.center = {\n                lat,\n                lng\n            };\n            needsUpdate = true;\n        }\n        if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n            nextCamera.zoom = zoom;\n            needsUpdate = true;\n        }\n        if (heading !== null && cameraStateRef.current.heading !== heading) {\n            nextCamera.heading = heading;\n            needsUpdate = true;\n        }\n        if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n            nextCamera.tilt = tilt;\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            map.moveCamera(nextCamera);\n        }\n    });\n}\n_s11(useMapCameraParams, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\nconst AuthFailureMessage = ()=>{\n    const style = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        zIndex: 999,\n        display: \"flex\",\n        flexFlow: \"column nowrap\",\n        textAlign: \"center\",\n        justifyContent: \"center\",\n        fontSize: \".8rem\",\n        color: \"rgba(0,0,0,0.6)\",\n        background: \"#dddddd\",\n        padding: \"1rem 1.5rem\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: style\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\n_c1 = AuthFailureMessage;\nfunction useCallbackRef() {\n    _s12();\n    const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>setEl(value), [\n        setEl\n    ]);\n    return [\n        el,\n        ref\n    ];\n}\n_s12(useCallbackRef, \"VloTnEpYwfVP5sjWXc1w8xQWZ+Q=\");\n/**\n * Hook to check if the Maps JavaScript API is loaded\n */ function useApiIsLoaded() {\n    _s13();\n    const status = useApiLoadingStatus();\n    return status === APILoadingStatus.LOADED;\n}\n_s13(useApiIsLoaded, \"SdrWm+4Nu53O23DKCYwlLCyijMQ=\", false, function() {\n    return [\n        useApiLoadingStatus\n    ];\n});\nfunction useForceUpdate() {\n    _s14();\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((x)=>x + 1, 0);\n    return forceUpdate;\n}\n_s14(useForceUpdate, \"OYvExaf+rzzVf06crq8byWAi7Rk=\");\nfunction handleBoundsChange(map, ref) {\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n        console.warn(\"[useTrackedCameraState] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n    }\n    // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n    Object.assign(ref.current, {\n        center: (center === null || center === void 0 ? void 0 : center.toJSON()) || {\n            lat: 0,\n            lng: 0\n        },\n        zoom: zoom || 0,\n        heading: heading,\n        tilt: tilt\n    });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */ function useTrackedCameraStateRef(map) {\n    _s15();\n    const forceUpdate = useForceUpdate();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        center: {\n            lat: 0,\n            lng: 0\n        },\n        heading: 0,\n        tilt: 0,\n        zoom: 0\n    });\n    // Record camera state with every bounds_changed event dispatched by the map.\n    // This data is used to prevent feeding these values back to the\n    // map-instance when a typical \"controlled component\" setup (state variable is\n    // fed into and updated by the map).\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const listener = google.maps.event.addListener(map, \"bounds_changed\", ()=>{\n            handleBoundsChange(map, ref);\n            // When an event is occured, we have to update during the next cycle.\n            // The application could decide to ignore the event and not update any\n            // camera props of the map, meaning that in that case we will have to\n            // 'undo' the change to the camera.\n            forceUpdate();\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        forceUpdate\n    ]);\n    return ref;\n}\n_s15(useTrackedCameraStateRef, \"ZmjndRMGldGtdD0sNNTfC29J5s8=\", false, function() {\n    return [\n        useForceUpdate\n    ];\n});\n/**\n * Stores a stack of map-instances for each mapId. Whenever an\n * instance is used, it is removed from the stack while in use,\n * and returned to the stack when the component unmounts.\n * This allows us to correctly implement caching for multiple\n * maps om the same page, while reusing as much as possible.\n *\n * FIXME: while it should in theory be possible to reuse maps solely\n *   based on the mapId (as all other parameters can be changed at\n *   runtime), we don't yet have good enough tracking of options to\n *   reliably unset all the options that have been set.\n */ class CachedMapStack {\n    static has(key) {\n        return this.entries[key] && this.entries[key].length > 0;\n    }\n    static pop(key) {\n        if (!this.entries[key]) return null;\n        return this.entries[key].pop() || null;\n    }\n    static push(key, value) {\n        if (!this.entries[key]) this.entries[key] = [];\n        this.entries[key].push(value);\n    }\n}\nCachedMapStack.entries = {};\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */ function useMapInstance(props, context) {\n    _s16();\n    const apiIsLoaded = useApiIsLoaded();\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [container, containerRef] = useCallbackRef();\n    const cameraStateRef = useTrackedCameraStateRef(map);\n    const { id, defaultBounds, defaultCenter, defaultZoom, defaultHeading, defaultTilt, reuseMaps, renderingType, colorScheme } = props, mapOptions = __rest(props, [\n        \"id\",\n        \"defaultBounds\",\n        \"defaultCenter\",\n        \"defaultZoom\",\n        \"defaultHeading\",\n        \"defaultTilt\",\n        \"reuseMaps\",\n        \"renderingType\",\n        \"colorScheme\"\n    ]);\n    const hasZoom = props.zoom !== undefined || props.defaultZoom !== undefined;\n    const hasCenter = props.center !== undefined || props.defaultCenter !== undefined;\n    if (!defaultBounds && (!hasZoom || !hasCenter)) {\n        console.warn(\"<Map> component is missing configuration. \" + \"You have to provide zoom and center (via the `zoom`/`defaultZoom` and \" + \"`center`/`defaultCenter` props) or specify the region to show using \" + \"`defaultBounds`. See \" + \"https://visgl.github.io/react-google-maps/docs/api-reference/components/map#required\");\n    }\n    // apply default camera props if available and not overwritten by controlled props\n    if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n    if (!mapOptions.zoom && Number.isFinite(defaultZoom)) mapOptions.zoom = defaultZoom;\n    if (!mapOptions.heading && Number.isFinite(defaultHeading)) mapOptions.heading = defaultHeading;\n    if (!mapOptions.tilt && Number.isFinite(defaultTilt)) mapOptions.tilt = defaultTilt;\n    // Handle internalUsageAttributionIds\n    const customIds = mapOptions.internalUsageAttributionIds;\n    if (customIds == null) {\n        // Not specified - use context default (which may be null if disabled)\n        mapOptions.internalUsageAttributionIds = context.internalUsageAttributionIds;\n    } else {\n        // Merge context defaults with custom IDs\n        mapOptions.internalUsageAttributionIds = [\n            ...context.internalUsageAttributionIds || [],\n            ...customIds\n        ];\n    }\n    for (const key of Object.keys(mapOptions))if (mapOptions[key] === undefined) delete mapOptions[key];\n    const savedMapStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    // create the map instance and register it in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!container || !apiIsLoaded) return;\n        const { addMapInstance, removeMapInstance } = context;\n        // note: colorScheme (upcoming feature) isn't yet in the typings, remove once that is fixed:\n        const { mapId } = props;\n        const cacheKey = \"\".concat(mapId || \"default\", \":\").concat(renderingType || \"default\", \":\").concat(colorScheme || \"LIGHT\");\n        let mapDiv;\n        let map;\n        if (reuseMaps && CachedMapStack.has(cacheKey)) {\n            map = CachedMapStack.pop(cacheKey);\n            mapDiv = map.getDiv();\n            container.appendChild(mapDiv);\n            map.setOptions(mapOptions);\n            // detaching the element from the DOM lets the map fall back to its default\n            // size, setting the center will trigger reloading the map.\n            setTimeout(()=>map.setCenter(map.getCenter()), 0);\n        } else {\n            mapDiv = document.createElement(\"div\");\n            mapDiv.style.height = \"100%\";\n            container.appendChild(mapDiv);\n            map = new google.maps.Map(mapDiv, Object.assign(Object.assign(Object.assign({}, mapOptions), renderingType ? {\n                renderingType: renderingType\n            } : {}), colorScheme ? {\n                colorScheme: colorScheme\n            } : {}));\n        }\n        setMap(map);\n        addMapInstance(map, id);\n        if (defaultBounds) {\n            const { padding } = defaultBounds, defBounds = __rest(defaultBounds, [\n                \"padding\"\n            ]);\n            map.fitBounds(defBounds, padding);\n        } else if (!hasZoom || !hasCenter) {\n            map.fitBounds({\n                east: 180,\n                west: -180,\n                south: -90,\n                north: 90\n            });\n        }\n        // the savedMapState is used to restore the camera parameters when the mapId is changed\n        if (savedMapStateRef.current) {\n            const { mapId: savedMapId, cameraState: savedCameraState } = savedMapStateRef.current;\n            if (savedMapId !== mapId) {\n                map.setOptions(savedCameraState);\n            }\n        }\n        return ()=>{\n            savedMapStateRef.current = {\n                mapId,\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                cameraState: cameraStateRef.current\n            };\n            // detach the map-div from the dom\n            mapDiv.remove();\n            if (reuseMaps) {\n                // push back on the stack\n                CachedMapStack.push(cacheKey, map);\n            } else {\n                // remove all event-listeners to minimize the possibility of memory-leaks\n                google.maps.event.clearInstanceListeners(map);\n            }\n            setMap(null);\n            removeMapInstance(id);\n        };\n    }, // some dependencies are ignored in the list below:\n    //  - defaultBounds and the default* camera props will only be used once, and\n    //    changes should be ignored\n    //  - mapOptions has special hooks that take care of updating the options\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        container,\n        apiIsLoaded,\n        id,\n        // these props can't be changed after initialization and require a new\n        // instance to be created\n        props.mapId,\n        props.renderingType,\n        props.colorScheme\n    ]);\n    return [\n        map,\n        containerRef,\n        cameraStateRef\n    ];\n}\n_s16(useMapInstance, \"DZMQ8Zdrmcxeq6bZUR6EMFctnC8=\", false, function() {\n    return [\n        useApiIsLoaded,\n        useCallbackRef,\n        useTrackedCameraStateRef\n    ];\n});\nconst GoogleMapsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// ColorScheme and RenderingType are redefined here to make them usable before the\n// maps API has been fully loaded.\nconst ColorScheme = {\n    DARK: \"DARK\",\n    LIGHT: \"LIGHT\",\n    FOLLOW_SYSTEM: \"FOLLOW_SYSTEM\"\n};\nconst RenderingType = {\n    VECTOR: \"VECTOR\",\n    RASTER: \"RASTER\",\n    UNINITIALIZED: \"UNINITIALIZED\"\n};\nconst Map = (props)=>{\n    _s17();\n    const { children, id, className, style } = props;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const loadingStatus = useApiLoadingStatus();\n    if (!context) {\n        throw new Error(\"<Map> can only be used inside an <ApiProvider> component.\");\n    }\n    const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n    useMapCameraParams(map, cameraStateRef, props);\n    useMapEvents(map, props);\n    useMapOptions(map, props);\n    const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n    const isControlledExternally = !!props.controlled;\n    // disable interactions with the map for externally controlled maps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n        //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n        //   any default map controls pretty much useless\n        if (isDeckGlControlled) {\n            map.setOptions({\n                disableDefaultUI: true\n            });\n        }\n        // disable all control-inputs when the map is controlled externally\n        if (isDeckGlControlled || isControlledExternally) {\n            map.setOptions({\n                gestureHandling: \"none\",\n                keyboardShortcuts: false\n            });\n        }\n        return ()=>{\n            map.setOptions({\n                gestureHandling: props.gestureHandling,\n                keyboardShortcuts: props.keyboardShortcuts\n            });\n        };\n    }, [\n        map,\n        isDeckGlControlled,\n        isControlledExternally,\n        props.gestureHandling,\n        props.keyboardShortcuts\n    ]);\n    // setup a stable cameraOptions object that can be used as dependency\n    const center = props.center ? toLatLngLiteral(props.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _a, _b, _c;\n        return {\n            center: {\n                lat: lat !== null && lat !== void 0 ? lat : 0,\n                lng: lng !== null && lng !== void 0 ? lng : 0\n            },\n            zoom: (_a = props.zoom) !== null && _a !== void 0 ? _a : 0,\n            heading: (_b = props.heading) !== null && _b !== void 0 ? _b : 0,\n            tilt: (_c = props.tilt) !== null && _c !== void 0 ? _c : 0\n        };\n    }, [\n        lat,\n        lng,\n        props.zoom,\n        props.heading,\n        props.tilt\n    ]);\n    // externally controlled mode: reject all camera changes that don't correspond to changes in props\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !isControlledExternally) return;\n        map.moveCamera(cameraOptions);\n        const listener = map.addListener(\"bounds_changed\", ()=>{\n            map.moveCamera(cameraOptions);\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        isControlledExternally,\n        cameraOptions\n    ]);\n    const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>Object.assign({\n            width: \"100%\",\n            height: \"100%\",\n            position: \"relative\",\n            // when using deckgl, the map should be sent to the back\n            zIndex: isDeckGlControlled ? -1 : 0\n        }, style), [\n        style,\n        isDeckGlControlled\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            map\n        }), [\n        map\n    ]);\n    if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            style: Object.assign({\n                position: \"relative\"\n            }, className ? {} : combinedStyle),\n            className: className\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({\n        ref: mapRef,\n        \"data-testid\": \"map\",\n        style: className ? undefined : combinedStyle,\n        className: className\n    }, id ? {\n        id\n    } : {}), map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, {\n        value: contextValue\n    }, children) : null);\n};\n_s17(Map, \"AWqdKwgFin3XaAkt73rOuEv5ICk=\", false, function() {\n    return [\n        useApiLoadingStatus,\n        useMapInstance,\n        useMapCameraParams,\n        useMapEvents,\n        useMapOptions,\n        useDeckGLCameraUpdate\n    ];\n});\n_c2 = Map;\n// The deckGLViewProps flag here indicates to deck.gl that the Map component is\n// able to handle viewProps from deck.gl when deck.gl is used to control the map.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nMap.deckGLViewProps = true;\nconst shownMessages = new Set();\nfunction logErrorOnce() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    const key = JSON.stringify(args);\n    if (!shownMessages.has(key)) {\n        shownMessages.add(key);\n        console.error(...args);\n    }\n}\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */ const useMap = function() {\n    let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    _s18();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const { map } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n    if (ctx === null) {\n        logErrorOnce(\"useMap(): failed to retrieve APIProviderContext. \" + \"Make sure that the <APIProvider> component exists and that the \" + \"component you are calling `useMap()` from is a sibling of the \" + \"<APIProvider>.\");\n        return null;\n    }\n    const { mapInstances } = ctx;\n    // if an id is specified, the corresponding map or null is returned\n    if (id !== null) return mapInstances[id] || null;\n    // otherwise, return the closest ancestor\n    if (map) return map;\n    // finally, return the default map instance\n    return mapInstances[\"default\"] || null;\n};\n_s18(useMap, \"02oyNIqv7n0uhMRysGwaojH8Xj0=\");\nfunction useMapsLibrary(name) {\n    _s19();\n    const apiIsLoaded = useApiIsLoaded();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!apiIsLoaded || !ctx) return;\n        // Trigger loading the libraries via our proxy-method.\n        // The returned promise is ignored, since importLibrary will update loadedLibraries\n        // list in the context, triggering a re-render.\n        void ctx.importLibrary(name);\n    }, [\n        apiIsLoaded,\n        ctx,\n        name\n    ]);\n    return (ctx === null || ctx === void 0 ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n_s19(useMapsLibrary, \"E3X53atPXTwKH7JamUeR87Uqn9c=\", false, function() {\n    return [\n        useApiIsLoaded\n    ];\n});\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Internally used to bind events to Maps JavaScript API objects.\n * @internal\n */ function useMapsEventListener(target, name, callback) {\n    _s20();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!target || !name || !callback) return;\n        const listener = google.maps.event.addListener(target, name, callback);\n        return ()=>listener.remove();\n    }, [\n        target,\n        name,\n        callback\n    ]);\n}\n_s20(useMapsEventListener, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n/**\n * Internally used to copy values from props into API-Objects\n * whenever they change.\n *\n * @example\n *   usePropBinding(marker, 'position', position);\n *\n * @internal\n */ function usePropBinding(object, prop, value) {\n    _s21();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!object) return;\n        // eslint-disable-next-line react-hooks/immutability\n        object[prop] = value;\n    }, [\n        object,\n        prop,\n        value\n    ]);\n}\n_s21(usePropBinding, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Internally used to bind events to DOM nodes.\n * @internal\n */ function useDomEventListener(target, name, callback) {\n    _s22();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!target || !name || !callback) return;\n        target.addEventListener(name, callback);\n        return ()=>target.removeEventListener(name, callback);\n    }, [\n        target,\n        name,\n        callback\n    ]);\n}\n_s22(useDomEventListener, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n// Global style manager to track rendered styles and avoid duplicates\nclass GlobalStyleManager {\n    getStyleElement() {\n        if (!this.styleElement) {\n            this.styleElement = document.createElement(\"style\");\n            this.styleElement.setAttribute(\"data-rgm-anchor-styles\", \"\");\n            document.head.appendChild(this.styleElement);\n        }\n        return this.styleElement;\n    }\n    addAdvancedMarkerPointerEventsOverwrite() {\n        if (this.renderedStyles.has(\"marker-pointer-events\")) {\n            return;\n        }\n        const styleElement = this.getStyleElement();\n        styleElement.textContent += \"\\n      gmp-advanced-marker[data-origin='rgm'] {\\n        pointer-events: none !important;\\n      }\\n    \";\n        this.renderedStyles.add(\"marker-pointer-events\");\n    }\n    cleanup() {\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n            this.renderedStyles.clear();\n        }\n    }\n    constructor(){\n        this.renderedStyles = new Set();\n        this.styleElement = null;\n    }\n}\nconst globalStyleManager = new GlobalStyleManager();\nfunction isVersionGreaterEqual(major, minor) {\n    var _a;\n    if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.version)) return undefined;\n    const version = google.maps.version.split(\".\");\n    const currentMajor = parseInt(version[0], 10);\n    const currentMinor = parseInt(version[1], 10);\n    return currentMajor > major || currentMajor === major && currentMinor >= minor;\n}\n/* eslint-disable react-hooks/immutability */ // The `react-hooks/immutability` rule is disabled in this file because the\n// google.maps.marker.AdvancedMarkerElement object is designed to be mutated\n// directly. This is a common pattern when working with imperative APIs like\n// the Google Maps JavaScript API. While this goes against the principles of\n// immutable state in React, it is a necessary evil to integrate with the\n// Google Maps API. The mutations are carefully managed within the `useEffect`\n// hooks to ensure that they only happen when the props change.\n/**\n * Copy of the `google.maps.CollisionBehavior` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */ const CollisionBehavior = {\n    REQUIRED: \"REQUIRED\",\n    REQUIRED_AND_HIDES_OPTIONAL: \"REQUIRED_AND_HIDES_OPTIONAL\",\n    OPTIONAL_AND_HIDES_LOWER_PRIORITY: \"OPTIONAL_AND_HIDES_LOWER_PRIORITY\"\n};\nconst AdvancedMarkerContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// [xPosition, yPosition] when the top left corner is [0, 0]\n/**\n * @deprecated Using `anchorPosition` is deprecated.\n *   Use `anchorLeft` and `anchorTop` instead.\n */ const AdvancedMarkerAnchorPoint = {\n    TOP_LEFT: [\n        \"0%\",\n        \"0%\"\n    ],\n    TOP_CENTER: [\n        \"50%\",\n        \"0%\"\n    ],\n    TOP: [\n        \"50%\",\n        \"0%\"\n    ],\n    TOP_RIGHT: [\n        \"100%\",\n        \"0%\"\n    ],\n    LEFT_CENTER: [\n        \"0%\",\n        \"50%\"\n    ],\n    LEFT_TOP: [\n        \"0%\",\n        \"0%\"\n    ],\n    LEFT: [\n        \"0%\",\n        \"50%\"\n    ],\n    LEFT_BOTTOM: [\n        \"0%\",\n        \"100%\"\n    ],\n    RIGHT_TOP: [\n        \"100%\",\n        \"0%\"\n    ],\n    RIGHT: [\n        \"100%\",\n        \"50%\"\n    ],\n    RIGHT_CENTER: [\n        \"100%\",\n        \"50%\"\n    ],\n    RIGHT_BOTTOM: [\n        \"100%\",\n        \"100%\"\n    ],\n    BOTTOM_LEFT: [\n        \"0%\",\n        \"100%\"\n    ],\n    BOTTOM_CENTER: [\n        \"50%\",\n        \"100%\"\n    ],\n    BOTTOM: [\n        \"50%\",\n        \"100%\"\n    ],\n    BOTTOM_RIGHT: [\n        \"100%\",\n        \"100%\"\n    ],\n    CENTER: [\n        \"50%\",\n        \"50%\"\n    ]\n};\nconst AdvancedMarker = /*#__PURE__*/ _s23((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c3 = _s23((props, ref)=>{\n    _s23();\n    const { children, style, className, anchorPoint } = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n    const advancedMarkerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>marker ? {\n            marker\n        } : null, [\n        marker\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    if (!contentContainer) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, {\n        value: advancedMarkerContextValue\n    }, /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerContent, {\n        anchorPoint: anchorPoint,\n        styles: style,\n        className: className\n    }, children), contentContainer));\n}, \"qJce2Vx4SAXrecQVbB/locDIwzI=\", false, function() {\n    return [\n        useAdvancedMarker\n    ];\n})), \"qJce2Vx4SAXrecQVbB/locDIwzI=\", false, function() {\n    return [\n        useAdvancedMarker\n    ];\n});\n_c4 = AdvancedMarker;\nAdvancedMarker.displayName = \"AdvancedMarker\";\nfunction useAdvancedMarkerRef() {\n    _s24();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\n_s24(useAdvancedMarkerRef, \"FBQ4v4HcC4JdZrPyl/BGQ2M+tPY=\");\nfunction isAdvancedMarker(marker) {\n    return marker.content !== undefined;\n}\nfunction isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\nconst MarkerContent = (param)=>{\n    let { children, styles, className } = param;\n    /* AdvancedMarker div that user can give styles and classes */ return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: className,\n        style: styles\n    }, children);\n};\n_c5 = MarkerContent;\nfunction useAdvancedMarker(props) {\n    _s25();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const markerLibrary = useMapsLibrary(\"marker\");\n    const { children, onClick, className, onMouseEnter, onMouseLeave, onDrag, onDragStart, onDragEnd, collisionBehavior, clickable, draggable, position, title, zIndex, anchorPoint, anchorLeft, anchorTop } = props;\n    const numChildren = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n    // create an AdvancedMarkerElement instance and add it to the map once available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map || !markerLibrary) return;\n        const newMarker = new markerLibrary.AdvancedMarkerElement();\n        newMarker.map = map;\n        setMarker(newMarker);\n        // create the container for marker content if there are children\n        let contentElement = null;\n        if (numChildren > 0) {\n            contentElement = document.createElement(\"div\");\n            newMarker.content = contentElement;\n            setContentContainer(contentElement);\n        }\n        return ()=>{\n            newMarker.map = null;\n            contentElement === null || contentElement === void 0 ? void 0 : contentElement.remove();\n            setMarker(null);\n            setContentContainer(null);\n        };\n    }, [\n        map,\n        markerLibrary,\n        numChildren\n    ]);\n    // When no children are present we don't have our own wrapper div\n    // which usually gets the user provided className. In this case\n    // we set the className directly on the marker.content element that comes\n    // with the AdvancedMarker.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!(marker === null || marker === void 0 ? void 0 : marker.content) || !isElementNode(marker.content) || numChildren > 0) return;\n        marker.content.className = className !== null && className !== void 0 ? className : \"\";\n    }, [\n        marker,\n        className,\n        numChildren\n    ]);\n    useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, numChildren > 0);\n    // copy other props\n    usePropBinding(marker, \"position\", position);\n    usePropBinding(marker, \"title\", title !== null && title !== void 0 ? title : \"\");\n    usePropBinding(marker, \"zIndex\", zIndex);\n    usePropBinding(marker, \"collisionBehavior\", collisionBehavior);\n    // set gmpDraggable from props (when unspecified, it's true if any drag-event\n    // callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (draggable !== undefined) marker.gmpDraggable = draggable;\n        else if (onDrag || onDragStart || onDragEnd) marker.gmpDraggable = true;\n        else marker.gmpDraggable = false;\n    }, [\n        marker,\n        draggable,\n        onDrag,\n        onDragEnd,\n        onDragStart\n    ]);\n    // set gmpClickable from props (when unspecified, it's true if the onClick or one of\n    // the hover events callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const gmpClickable = clickable !== undefined || Boolean(onClick) || Boolean(onMouseEnter) || Boolean(onMouseLeave);\n        // gmpClickable is only available in beta version of the\n        // maps api (as of 2024-10-10)\n        marker.gmpClickable = gmpClickable;\n        // enable pointer events for the markers with custom content\n        if (gmpClickable && (marker === null || marker === void 0 ? void 0 : marker.content) && isElementNode(marker.content)) {\n            marker.content.style.pointerEvents = \"all\";\n            if (onClick) {\n                marker.content.style.cursor = \"pointer\";\n            }\n        }\n    }, [\n        marker,\n        clickable,\n        onClick,\n        onMouseEnter,\n        onMouseLeave\n    ]);\n    useMapsEventListener(marker, \"click\", onClick);\n    useMapsEventListener(marker, \"drag\", onDrag);\n    useMapsEventListener(marker, \"dragstart\", onDragStart);\n    useMapsEventListener(marker, \"dragend\", onDragEnd);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, \"mouseenter\", onMouseEnter);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, \"mouseleave\", onMouseLeave);\n    return [\n        marker,\n        contentContainer\n    ];\n}\n_s25(useAdvancedMarker, \"WUKBV+zUxqaU5AjpAVzs1hQQp9Q=\", false, function() {\n    return [\n        useMap,\n        useMapsLibrary,\n        useAdvancedMarkerAnchoring,\n        usePropBinding,\n        usePropBinding,\n        usePropBinding,\n        usePropBinding,\n        useMapsEventListener,\n        useMapsEventListener,\n        useMapsEventListener,\n        useMapsEventListener,\n        useDomEventListener,\n        useDomEventListener\n    ];\n});\nfunction useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, hasChildren) {\n    _s26();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker || !hasChildren) return;\n        // The anchorLeft and anchorTop options are available since version 3.62.9c\n        // With the release of 3.65 (~May 2026) there will no longer be a version\n        // that doesn't support it.\n        const anchorOptionsSupported = isVersionGreaterEqual(3, 62);\n        const contentElement = marker.content;\n        if (!contentElement || !isElementNode(contentElement)) return;\n        if (anchorLeft !== undefined || anchorTop !== undefined) {\n            if (!anchorOptionsSupported) {\n                console.warn(\"AdvancedMarker: The anchorLeft and anchorTop props are only supported \" + \"in Google Maps API version 3.62 and above. \" + \"The current version is \".concat(google.maps.version, \".\"));\n            }\n            marker.anchorLeft = anchorLeft;\n            marker.anchorTop = anchorTop;\n            // when anchorLeft and/or anchorTop are set, we'll ignore the anchorPoint\n            if (anchorPoint !== undefined) {\n                console.warn(\"AdvancedMarker: the anchorPoint prop is ignored when anchorLeft \" + \"and/or anchorTop are set.\");\n            }\n            return;\n        }\n        if (anchorPoint !== undefined) {\n            // TODO: add console.warn in a future version to inform about deprecation\n            const [x, y] = anchorPoint !== null && anchorPoint !== void 0 ? anchorPoint : AdvancedMarkerAnchorPoint[\"BOTTOM\"];\n            // NOTE: since x and y can be any valid CSS length-percentage\n            //   value, we need to use calc() to negate them.\n            const translateX = \"calc(-1 * \".concat(x, \")\");\n            const translateY = \"calc(-1 * \".concat(y, \")\");\n            if (anchorOptionsSupported) {\n                // implement anchorPoint using the new anchorLeft and anchorTop options\n                marker.anchorLeft = translateX;\n                marker.anchorTop = translateY;\n                // reset transform from legacy implementation\n                contentElement.style.transform = \"\";\n            } else {\n                // The \"translate(50%, 100%)\" counters and resets the default\n                // anchoring of the advanced marker element from the api\n                contentElement.style.transform = \"translate(50%, 100%) translate(\".concat(translateX, \", \").concat(translateY, \")\");\n                // data-origin is needed to identify the custom marker content in the\n                // InfoWindow component as well as in the global CSS used to disable\n                // the pointer event when anchor points are used in older Google Maps\n                // versions.\n                marker.dataset.origin = \"rgm\";\n                globalStyleManager.addAdvancedMarkerPointerEventsOverwrite();\n            }\n        }\n    }, [\n        marker,\n        anchorPoint,\n        anchorLeft,\n        anchorTop,\n        hasChildren\n    ]);\n}\n_s26(useAdvancedMarkerAnchoring, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nfunction setValueForStyles(element, styles, prevStyles) {\n    if (styles != null && typeof styles !== \"object\") {\n        throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n    }\n    const elementStyle = element.style;\n    // without `prevStyles`, just set all values\n    if (prevStyles == null) {\n        if (styles == null) return;\n        for(const styleName in styles){\n            if (!styles.hasOwnProperty(styleName)) continue;\n            setValueForStyle(elementStyle, styleName, styles[styleName]);\n        }\n        return;\n    }\n    // unset all styles in `prevStyles` that aren't in `styles`\n    for(const styleName in prevStyles){\n        if (prevStyles.hasOwnProperty(styleName) && (styles == null || !styles.hasOwnProperty(styleName))) {\n            // Clear style\n            const isCustomProperty = styleName.indexOf(\"--\") === 0;\n            if (isCustomProperty) {\n                elementStyle.setProperty(styleName, \"\");\n            } else if (styleName === \"float\") {\n                elementStyle.cssFloat = \"\";\n            } else {\n                elementStyle[styleName] = \"\";\n            }\n        }\n    }\n    // only assign values from `styles` that are different from `prevStyles`\n    if (styles == null) return;\n    for(const styleName in styles){\n        const value = styles[styleName];\n        if (styles.hasOwnProperty(styleName) && prevStyles[styleName] !== value) {\n            setValueForStyle(elementStyle, styleName, value);\n        }\n    }\n}\nfunction setValueForStyle(elementStyle, styleName, value) {\n    const isCustomProperty = styleName.indexOf(\"--\") === 0;\n    // falsy values will unset the style property\n    if (value == null || typeof value === \"boolean\" || value === \"\") {\n        if (isCustomProperty) {\n            elementStyle.setProperty(styleName, \"\");\n        } else if (styleName === \"float\") {\n            elementStyle.cssFloat = \"\";\n        } else {\n            elementStyle[styleName] = \"\";\n        }\n    } else if (isCustomProperty) {\n        elementStyle.setProperty(styleName, value);\n    } else if (typeof value === \"number\" && value !== 0 && !isUnitlessNumber(styleName)) {\n        elementStyle[styleName] = value + \"px\"; // Presumes implicit 'px' suffix for unitless numbers\n    } else {\n        if (styleName === \"float\") {\n            elementStyle.cssFloat = value;\n        } else {\n            elementStyle[styleName] = (\"\" + value).trim();\n        }\n    }\n}\n// CSS properties which accept numbers but are not in units of \"px\".\nconst unitlessNumbers = new Set([\n    \"animationIterationCount\",\n    \"aspectRatio\",\n    \"borderImageOutset\",\n    \"borderImageSlice\",\n    \"borderImageWidth\",\n    \"boxFlex\",\n    \"boxFlexGroup\",\n    \"boxOrdinalGroup\",\n    \"columnCount\",\n    \"columns\",\n    \"flex\",\n    \"flexGrow\",\n    \"flexPositive\",\n    \"flexShrink\",\n    \"flexNegative\",\n    \"flexOrder\",\n    \"gridArea\",\n    \"gridRow\",\n    \"gridRowEnd\",\n    \"gridRowSpan\",\n    \"gridRowStart\",\n    \"gridColumn\",\n    \"gridColumnEnd\",\n    \"gridColumnSpan\",\n    \"gridColumnStart\",\n    \"fontWeight\",\n    \"lineClamp\",\n    \"lineHeight\",\n    \"opacity\",\n    \"order\",\n    \"orphans\",\n    \"scale\",\n    \"tabSize\",\n    \"widows\",\n    \"zIndex\",\n    \"zoom\",\n    \"fillOpacity\",\n    \"floodOpacity\",\n    \"stopOpacity\",\n    \"strokeDasharray\",\n    \"strokeDashoffset\",\n    \"strokeMiterlimit\",\n    \"strokeOpacity\",\n    \"strokeWidth\"\n]);\nfunction isUnitlessNumber(name) {\n    return unitlessNumbers.has(name);\n}\n/**\n * Component to render an Info Window with the Maps JavaScript API\n */ const InfoWindow = (props)=>{\n    _s27();\n    const { // content options\n    children, headerContent, style, className, pixelOffset, // open options\n    anchor, shouldFocus, // events\n    onClose, onCloseClick } = props, // other options\n    volatileInfoWindowOptions = __rest(props, [\n        \"children\",\n        \"headerContent\",\n        \"style\",\n        \"className\",\n        \"pixelOffset\",\n        \"anchor\",\n        \"shouldFocus\",\n        \"onClose\",\n        \"onCloseClick\"\n    ]);\n    // ## create infowindow instance once the mapsLibrary is available.\n    const mapsLibrary = useMapsLibrary(\"maps\");\n    const [infoWindow, setInfoWindow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const contentContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const headerContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const infoWindowOptions = useMemoized(volatileInfoWindowOptions, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!mapsLibrary) return;\n        contentContainerRef.current = document.createElement(\"div\");\n        headerContainerRef.current = document.createElement(\"div\");\n        const opts = infoWindowOptions;\n        if (pixelOffset) {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (headerContent) {\n            // if headerContent is specified as string we can directly forward it,\n            // otherwise we'll pass the element the portal will render into\n            opts.headerContent = typeof headerContent === \"string\" ? headerContent : headerContainerRef.current;\n        }\n        // intentionally shadowing the state variables here\n        const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n        infoWindow.setContent(contentContainerRef.current);\n        setInfoWindow(infoWindow);\n        // unmount: remove infoWindow and content elements (note: close is called in a different effect-cleanup)\n        return ()=>{\n            var _a, _b;\n            infoWindow.setContent(null);\n            (_a = contentContainerRef.current) === null || _a === void 0 ? void 0 : _a.remove();\n            (_b = headerContainerRef.current) === null || _b === void 0 ? void 0 : _b.remove();\n            contentContainerRef.current = null;\n            headerContainerRef.current = null;\n            setInfoWindow(null);\n        };\n    }, // `infoWindowOptions` and other props are missing from dependencies:\n    //\n    // We don't want to re-create the infowindow instance\n    // when the options change.\n    // Updating the options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        mapsLibrary\n    ]);\n    // ---- update className and styles for `contentContainer`\n    // prevStyleRef stores previously applied style properties, so they can be\n    // removed when unset\n    const prevStyleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!infoWindow || !contentContainerRef.current) return;\n        setValueForStyles(contentContainerRef.current, style || null, prevStyleRef.current);\n        prevStyleRef.current = style || null;\n        if (className !== contentContainerRef.current.className) contentContainerRef.current.className = className || \"\";\n    }, [\n        infoWindow,\n        className,\n        style\n    ]);\n    // ---- update options\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!infoWindow) return;\n        const opts = infoWindowOptions;\n        if (!pixelOffset) {\n            opts.pixelOffset = null;\n        } else {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (!headerContent) {\n            opts.headerContent = null;\n        } else {\n            opts.headerContent = typeof headerContent === \"string\" ? headerContent : headerContainerRef.current;\n        }\n        infoWindow.setOptions(infoWindowOptions);\n    }, // dependency `infoWindow` isn't needed since options are also passed\n    // to the constructor when a new infoWindow is created.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        infoWindowOptions,\n        pixelOffset,\n        headerContent\n    ]);\n    // ## bind event handlers\n    useMapsEventListener(infoWindow, \"close\", onClose);\n    useMapsEventListener(infoWindow, \"closeclick\", onCloseClick);\n    // ---- open info window when content and map are available\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        // `anchor === null` means an anchor is defined but not ready yet.\n        if (!map || !infoWindow || anchor === null) return;\n        const isOpenedWithAnchor = !!anchor;\n        const openOptions = {\n            map\n        };\n        if (anchor) {\n            openOptions.anchor = anchor;\n            // Only do the infowindow adjusting when dealing with an AdvancedMarker\n            if (isAdvancedMarker(anchor) && anchor.content instanceof Element) {\n                const anchorBcr = anchor === null || anchor === void 0 ? void 0 : anchor.getBoundingClientRect();\n                // This checks whether or not the anchor has custom content with our own\n                // div wrapper. If not, that means we have a regular AdvancedMarker without\n                // children, or an AdvancedMarker that uses the anchorLeft/anchorTop props.\n                // In that case we do not want to adjust the infowindow since it is all handled correctly\n                // by the Google Maps API.\n                if (anchorBcr && anchor.dataset.origin === \"rgm\") {\n                    // We can safely typecast here since we control that element and we know that\n                    // it is a div\n                    const anchorDomContent = (_a = anchor.content.firstElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild;\n                    const contentBcr = anchorDomContent === null || anchorDomContent === void 0 ? void 0 : anchorDomContent.getBoundingClientRect();\n                    // center infowindow above marker\n                    const anchorOffsetX = contentBcr.x - anchorBcr.x + (contentBcr.width - anchorBcr.width) / 2;\n                    const anchorOffsetY = contentBcr.y - anchorBcr.y;\n                    const opts = infoWindowOptions;\n                    opts.pixelOffset = new google.maps.Size(pixelOffset ? pixelOffset[0] + anchorOffsetX : anchorOffsetX, pixelOffset ? pixelOffset[1] + anchorOffsetY : anchorOffsetY);\n                    infoWindow.setOptions(opts);\n                }\n            }\n        }\n        if (shouldFocus !== undefined) {\n            openOptions.shouldFocus = shouldFocus;\n        }\n        infoWindow.open(openOptions);\n        return ()=>{\n            // Note: when the infowindow has an anchor, it will automatically show up again when the\n            // anchor was removed from the map before infoWindow.close() is called but the it gets\n            // added back to the map after that.\n            // More information here: https://issuetracker.google.com/issues/343750849\n            if (isOpenedWithAnchor) infoWindow.set(\"anchor\", null);\n            infoWindow.close();\n        };\n    }, [\n        infoWindow,\n        anchor,\n        map,\n        shouldFocus,\n        infoWindowOptions,\n        pixelOffset\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, contentContainerRef.current && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainerRef.current), headerContainerRef.current !== null && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(headerContent, headerContainerRef.current));\n};\n_s27(InfoWindow, \"CUqPxc/ZFo+cir/zjZlow7bh/5s=\", false, function() {\n    return [\n        useMapsLibrary,\n        useMemoized,\n        useMapsEventListener,\n        useMapsEventListener,\n        useMap\n    ];\n});\n_c6 = InfoWindow;\n/**\n * Formats a location into a string representation suitable for Google Static Maps API.\n *\n * @param location - The location to format, can be either a string or an object with lat/lng properties\n * @returns A string representation of the location in the format \"lat,lng\" or the original string\n *\n * @example\n * // Returns \"40.714728,-73.998672\"\n * formatLocation({ lat: 40.714728, lng: -73.998672 })\n *\n * @example\n * // Returns \"New York, NY\"\n * formatLocation(\"New York, NY\")\n */ function formatLocation(location) {\n    return typeof location === \"string\" ? location : \"\".concat(location.lat, \",\").concat(location.lng);\n}\n// Used for removing the leading pipe from the param string\nfunction formatParam(string) {\n    return string.slice(1);\n}\n/**\n * Assembles marker parameters for static maps.\n *\n * This function takes an array of markers and groups them by their style properties.\n * It then creates a string representation of these markers, including their styles and locations,\n * which can be used as parameters for static map APIs.\n *\n * @param {StaticMapsMarker[]} [markers=[]] - An array of markers to be processed. Each marker can have properties such as color, label, size, scale, icon, anchor, and location.\n * @returns {string[]} An array of strings, each representing a group of markers with their styles and locations.\n *\n * @example\n * const markers = [\n *   { color: 'blue', label: 'A', size: 'mid', location: '40.714728,-73.998672' },\n *   { color: 'blue', label: 'B', size: 'mid', location: '40.714728,-73.998672' },\n *   { icon: 'http://example.com/icon.png', location: { lat: 40.714728, lng: -73.998672 } }\n * ];\n * const params = assembleMarkerParams(markers);\n * // Params will be an array of strings representing the marker parameters\n * Example output: [\n *   \"color:blue|label:A|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"color:blue|label:B|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"icon:http://example.com/icon.png|40.714728,-73.998672\"\n * ]\n */ function assembleMarkerParams() {\n    let markers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    const markerParams = [];\n    // Group markers by style\n    const markersByStyle = markers === null || markers === void 0 ? void 0 : markers.reduce((styles, marker)=>{\n        const { color = \"red\", label, size, scale, icon, anchor } = marker;\n        // Create a unique style key based on either icon properties or standard marker properties\n        const relevantProps = icon ? [\n            icon,\n            anchor,\n            scale\n        ] : [\n            color,\n            label,\n            size\n        ];\n        const key = relevantProps.filter(Boolean).join(\"-\");\n        styles[key] = styles[key] || [];\n        styles[key].push(marker);\n        return styles;\n    }, {});\n    Object.values(markersByStyle !== null && markersByStyle !== void 0 ? markersByStyle : {}).forEach((markers)=>{\n        let markerParam = \"\";\n        const { icon } = markers[0];\n        // Create marker style from first marker in group since all markers share the same style.\n        Object.entries(markers[0]).forEach((param)=>{\n            let [key, value] = param;\n            // Determine which properties to include based on whether marker uses custom icon\n            const relevantKeys = icon ? [\n                \"icon\",\n                \"anchor\",\n                \"scale\"\n            ] : [\n                \"color\",\n                \"label\",\n                \"size\"\n            ];\n            if (relevantKeys.includes(key)) {\n                markerParam += \"|\".concat(key, \":\").concat(value);\n            }\n        });\n        // Add location coordinates for each marker in the style group\n        // Handles both string locations and lat/lng object formats.\n        for (const marker of markers){\n            const location = typeof marker.location === \"string\" ? marker.location : \"\".concat(marker.location.lat, \",\").concat(marker.location.lng);\n            markerParam += \"|\".concat(location);\n        }\n        markerParams.push(markerParam);\n    });\n    return markerParams.map(formatParam);\n}\n// Style properties that can be applied to paths in the Static Maps API\nconst PATH_STYLE_KEYS = [\n    \"color\",\n    \"weight\",\n    \"fillcolor\",\n    \"geodesic\"\n];\n/**\n * Builds the style portion of a path parameter string.\n * @param path - The path object containing style properties\n * @returns A string with style parameters in the format \"|key:value\"\n */ function buildStyleParams(path) {\n    let styleParams = \"\";\n    PATH_STYLE_KEYS.forEach((key)=>{\n        if (path[key] !== undefined) {\n            styleParams += \"|\".concat(key, \":\").concat(path[key]);\n        }\n    });\n    return styleParams;\n}\n/**\n * Builds the coordinates portion of a path parameter string.\n * @param coordinates - Either a string or array of location objects\n * @returns A string with coordinates in the format \"|lat,lng|lat,lng\"\n */ function buildCoordinateParams(coordinates) {\n    if (typeof coordinates === \"string\") {\n        return \"|\".concat(decodeURIComponent(coordinates));\n    }\n    return coordinates.map((location)=>\"|\".concat(formatLocation(location))).join(\"\");\n}\n/**\n * Assembles path parameters for the Static Maps API from an array of paths.\n *\n * This function constructs a string of path parameters for each path. Each path parameter string\n * includes the style properties and the coordinates of the paths.\n *\n * @param {Array<StaticMapsPath>} [paths=[]] - An array of paths to be assembled into path parameters.\n * @returns {Array<string>} An array of path parameter strings.\n *\n * @example\n * ```typescript\n * const paths = [\n *   {\n *     color: 'red',\n *     weight: 5,\n *     coordinates: [\n *       { lat: 40.714728, lng: -73.998672 },\n *       { lat: 40.718217, lng: -73.998284 }\n *     ]\n *   }\n * ];\n *\n * const pathParams = assemblePathParams(paths);\n * // Output: ['color:red|weight:5|40.714728,-73.998672|40.718217,-73.998284']\n * ```\n */ function assemblePathParams() {\n    let paths = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return paths.map((path)=>{\n        const styleParams = buildStyleParams(path);\n        const coordinateParams = buildCoordinateParams(path.coordinates);\n        const pathParam = styleParams + coordinateParams;\n        return formatParam(pathParam);\n    });\n}\n/**\n * Converts an array of Google Maps style objects into an array of style strings\n * compatible with the Google Static Maps API.\n *\n * @param styles - An array of Google Maps MapTypeStyle objects that define the styling rules\n * @returns An array of formatted style strings ready to be used with the Static Maps API\n *\n * @example\n * const styles = [{\n *   featureType: \"road\",\n *   elementType: \"geometry\",\n *   stylers: [{color: \"#ff0000\"}, {weight: 1}]\n * }];\n *\n * const styleStrings = assembleMapTypeStyles(styles);\n * // Returns: [\"|feature:road|element:geometry|color:0xff0000|weight:1\"]\n *\n * Each style string follows the format:\n * \"feature:{featureType}|element:{elementType}|{stylerName}:{stylerValue}\"\n *\n * Note: Color values with hexadecimal notation (#) are automatically converted\n * to the required 0x format for the Static Maps API.\n */ function assembleMapTypeStyles(styles) {\n    return styles.map((mapTypeStyle)=>{\n        const { featureType, elementType, stylers = [] } = mapTypeStyle;\n        let styleString = \"\";\n        if (featureType) {\n            styleString += \"|feature:\".concat(featureType);\n        }\n        if (elementType) {\n            styleString += \"|element:\".concat(elementType);\n        }\n        for (const styler of stylers){\n            Object.entries(styler).forEach((param)=>{\n                let [name, value] = param;\n                styleString += \"|\".concat(name, \":\").concat(String(value).replace(\"#\", \"0x\"));\n            });\n        }\n        return styleString;\n    }).map(formatParam);\n}\nconst STATIC_MAPS_BASE = \"https://maps.googleapis.com/maps/api/staticmap\";\n/**\n * Creates a URL for the Google Static Maps API with the specified parameters.\n *\n * @param {Object} options - The configuration options for the static map\n * @param {string} options.apiKey - Your Google Maps API key (required)\n * @param {number} options.width - The width of the map image in pixels (required)\n * @param {number} options.height - The height of the map image in pixels (required)\n * @param {StaticMapsLocation} [options.center] - The center point of the map (lat/lng or address).\n *  Required if no markers or paths or \"visible locations\" are provided.\n * @param {number} [options.zoom] - The zoom level of the map. Required if no markers or paths or \"visible locations\" are provided.\n * @param {1|2|4} [options.scale] - The resolution of the map (1, 2, or 4)\n * @param {string} [options.format] - The image format (png, png8, png32, gif, jpg, jpg-baseline)\n * @param {string} [options.mapType] - The type of map (roadmap, satellite, terrain, hybrid)\n * @param {string} [options.language] - The language of the map labels\n * @param {string} [options.region] - The region code for the map\n * @param {string} [options.map_id] - The Cloud-based map style ID\n * @param {StaticMapsMarker[]} [options.markers=[]] - Array of markers to display on the map\n * @param {StaticMapsPath[]} [options.paths=[]] - Array of paths to display on the map\n * @param {StaticMapsLocation[]} [options.visible=[]] - Array of locations that should be visible on the map\n * @param {MapTypeStyle[]} [options.style=[]] - Array of style objects to customize the map appearance\n *\n * @returns {string} The complete Google Static Maps API URL\n *\n * @throws {Error} If API key is not provided\n * @throws {Error} If width or height is not provided\n *\n * @example\n * const url = createStaticMapsUrl({\n *   apiKey: 'YOUR_API_KEY',\n *   width: 600,\n *   height: 400,\n *   center: { lat: 40.714728, lng: -73.998672 },\n *   zoom: 12,\n *   markers: [\n *     {\n *       location: { lat: 40.714728, lng: -73.998672 },\n *       color: 'red',\n *       label: 'A'\n *     }\n *   ],\n *   paths: [\n *     {\n *       coordinates: [\n *         { lat: 40.714728, lng: -73.998672 },\n *         { lat: 40.719728, lng: -73.991672 }\n *       ],\n *       color: '0x0000ff',\n *       weight: 5\n *     }\n *   ],\n *   style: [\n *     {\n *       featureType: 'road',\n *       elementType: 'geometry',\n *       stylers: [{color: '#00ff00'}]\n *     }\n *   ]\n * });\n *\n * // Results in URL similar to:\n * // https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY\n * // &size=600x400\n * // &center=40.714728,-73.998672&zoom=12\n * // &markers=color:red|label:A|40.714728,-73.998672\n * // &path=color:0x0000ff|weight:5|40.714728,-73.998672|40.719728,-73.991672\n * // &style=feature:road|element:geometry|color:0x00ff00\n */ function createStaticMapsUrl(param) {\n    let { apiKey, width, height, center, zoom, scale, format, mapType, language, region, mapId, markers = [], paths = [], visible = [], style = [] } = param;\n    if (!apiKey) {\n        console.warn(\"API key is required\");\n    }\n    if (!width || !height) {\n        console.warn(\"Width and height are required\");\n    }\n    const params = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        key: apiKey,\n        size: \"\".concat(width, \"x\").concat(height)\n    }, center && {\n        center: formatLocation(center)\n    }), zoom && {\n        zoom\n    }), scale && {\n        scale\n    }), format && {\n        format\n    }), mapType && {\n        maptype: mapType\n    }), language && {\n        language\n    }), region && {\n        region\n    }), mapId && {\n        map_id: mapId\n    });\n    const url = new URL(STATIC_MAPS_BASE);\n    // Params that don't need special handling\n    Object.entries(params).forEach((param)=>{\n        let [key, value] = param;\n        url.searchParams.append(key, String(value));\n    });\n    // Assemble Markers\n    for (const markerParam of assembleMarkerParams(markers)){\n        url.searchParams.append(\"markers\", markerParam);\n    }\n    // Assemble Paths\n    for (const pathParam of assemblePathParams(paths)){\n        url.searchParams.append(\"path\", pathParam);\n    }\n    // Assemble visible locations\n    if (visible.length) {\n        url.searchParams.append(\"visible\", visible.map((location)=>formatLocation(location)).join(\"|\"));\n    }\n    // Assemble Map Type Styles\n    for (const styleString of assembleMapTypeStyles(style)){\n        url.searchParams.append(\"style\", styleString);\n    }\n    return url.toString();\n}\nconst StaticMap = (props)=>{\n    const { url, className } = props;\n    if (!url) throw new Error(\"URL is required\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        className: className,\n        src: url,\n        width: \"100%\"\n    });\n};\n_c7 = StaticMap;\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */ const ControlPosition = {\n    TOP_LEFT: 1,\n    TOP_CENTER: 2,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    LEFT_CENTER: 4,\n    LEFT_TOP: 5,\n    LEFT: 5,\n    LEFT_BOTTOM: 6,\n    RIGHT_TOP: 7,\n    RIGHT: 7,\n    RIGHT_CENTER: 8,\n    RIGHT_BOTTOM: 9,\n    BOTTOM_LEFT: 10,\n    BOTTOM_CENTER: 11,\n    BOTTOM: 11,\n    BOTTOM_RIGHT: 12,\n    CENTER: 13,\n    BLOCK_START_INLINE_START: 14,\n    BLOCK_START_INLINE_CENTER: 15,\n    BLOCK_START_INLINE_END: 16,\n    INLINE_START_BLOCK_CENTER: 17,\n    INLINE_START_BLOCK_START: 18,\n    INLINE_START_BLOCK_END: 19,\n    INLINE_END_BLOCK_START: 20,\n    INLINE_END_BLOCK_CENTER: 21,\n    INLINE_END_BLOCK_END: 22,\n    BLOCK_END_INLINE_START: 23,\n    BLOCK_END_INLINE_CENTER: 24,\n    BLOCK_END_INLINE_END: 25\n};\nconst MapControl = (param)=>{\n    let { children, position } = param;\n    _s28();\n    const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const controls = map.controls[position];\n        controls.push(controlContainer);\n        return ()=>{\n            const controlsArray = controls.getArray();\n            // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n            if (!controlsArray) return;\n            const index = controlsArray.indexOf(controlContainer);\n            controls.removeAt(index);\n        };\n    }, [\n        controlContainer,\n        map,\n        position\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\n_s28(MapControl, \"GWhrPCjHyQkJZ2cqIea0Zsdo0OI=\", false, function() {\n    return [\n        useMap\n    ];\n});\n_c8 = MapControl;\nfunction useMarker(props) {\n    _s29();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const { onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut } = props, markerOptions = __rest(props, [\n        \"onClick\",\n        \"onDrag\",\n        \"onDragStart\",\n        \"onDragEnd\",\n        \"onMouseOver\",\n        \"onMouseOut\"\n    ]);\n    const { position, draggable } = markerOptions;\n    // create marker instance and add to the map once the map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) {\n            if (map === undefined) console.error(\"<Marker> has to be inside a Map component.\");\n            return;\n        }\n        const newMarker = new google.maps.Marker(markerOptions);\n        newMarker.setMap(map);\n        setMarker(newMarker);\n        return ()=>{\n            newMarker.setMap(null);\n            setMarker(null);\n        };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map\n    ]);\n    // attach and re-attach event-handlers when any of the properties change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const m = marker;\n        // Add event listeners\n        const gme = google.maps.event;\n        if (onClick) gme.addListener(m, \"click\", onClick);\n        if (onDrag) gme.addListener(m, \"drag\", onDrag);\n        if (onDragStart) gme.addListener(m, \"dragstart\", onDragStart);\n        if (onDragEnd) gme.addListener(m, \"dragend\", onDragEnd);\n        if (onMouseOver) gme.addListener(m, \"mouseover\", onMouseOver);\n        if (onMouseOut) gme.addListener(m, \"mouseout\", onMouseOut);\n        marker.setDraggable(Boolean(draggable));\n        return ()=>{\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDrag,\n        onDragStart,\n        onDragEnd,\n        onMouseOver,\n        onMouseOut\n    ]);\n    // update markerOptions (note the dependencies aren't properly checked\n    // here, we just assume that setOptions is smart enough to not waste a\n    // lot of time updating values that didn't change)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (markerOptions) marker.setOptions(markerOptions);\n    }, [\n        marker,\n        markerOptions\n    ]);\n    // update position when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Should not update position when draggable\n        if (draggable || !position || !marker) return;\n        marker.setPosition(position);\n    }, [\n        draggable,\n        position,\n        marker\n    ]);\n    return marker;\n}\n_s29(useMarker, \"4XdkpqW0TK7CEh7g7xo7x5bHhRU=\", false, function() {\n    return [\n        useMap\n    ];\n});\n/**\n * Component to render a marker on a map\n */ const Marker = /*#__PURE__*/ _s30((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c9 = _s30((props, ref)=>{\n    _s30();\n    const marker = useMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n}, \"X8uSd1rl6ws6EwUC+zm+JeM+A3k=\", false, function() {\n    return [\n        useMarker\n    ];\n})), \"X8uSd1rl6ws6EwUC+zm+JeM+A3k=\", false, function() {\n    return [\n        useMarker\n    ];\n});\n_c10 = Marker;\nMarker.displayName = \"Marker\";\nfunction useMarkerRef() {\n    _s31();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\n_s31(useMarkerRef, \"FBQ4v4HcC4JdZrPyl/BGQ2M+tPY=\");\n/**\n * Component to configure the appearance of an AdvancedMarker\n */ const Pin = (props)=>{\n    _s32();\n    var _a;\n    const advancedMarker = (_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) === null || _a === void 0 ? void 0 : _a.marker;\n    const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    // Create Pin View instance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!advancedMarker) {\n            if (advancedMarker === undefined) {\n                console.error(\"The <Pin> component can only be used inside <AdvancedMarker>.\");\n            }\n            return;\n        }\n        if (props.glyph && props.children) {\n            logErrorOnce(\"The <Pin> component only uses children to render the glyph if both the glyph property and children are present.\");\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n            logErrorOnce(\"Passing multiple children to the <Pin> component might lead to unexpected results.\");\n        }\n        const pinViewOptions = Object.assign({}, props);\n        const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n        // Set glyph to glyph container if children are present (rendered via portal).\n        // If both props.glyph and props.children are present, props.children takes priority.\n        if (props.children) {\n            pinElement.glyph = glyphContainer;\n        }\n        // Set content of Advanced Marker View to the Pin View element\n        // Here we are selecting the anchor container.\n        // The hierarchy is as follows:\n        // \"advancedMarker.content\" (from google) -> \"anchor container\"\n        const markerContent = (_a = advancedMarker.content) === null || _a === void 0 ? void 0 : _a.firstChild;\n        while(markerContent === null || markerContent === void 0 ? void 0 : markerContent.firstChild){\n            markerContent.removeChild(markerContent.firstChild);\n        }\n        if (markerContent) {\n            markerContent.appendChild(pinElement.element);\n        }\n    }, [\n        advancedMarker,\n        glyphContainer,\n        props\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\n_s32(Pin, \"USBKEQcWQZODuZ3cwquju/JeJfU=\");\n_c11 = Pin;\nconst mapLinear = (x, a1, a2, b1, b2)=>b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = (zoom)=>{\n    if (zoom <= 10) {\n        return 30;\n    }\n    if (zoom >= 15.5) {\n        return 67.5;\n    }\n    // range [10...14]\n    if (zoom <= 14) {\n        return mapLinear(zoom, 10, 14, 30, 45);\n    }\n    // range [14...15.5]\n    return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the Google map when updating the view state\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = (param)=>{\n    let { viewState } = param;\n    const pitch = viewState.pitch;\n    const gmZoom = viewState.zoom + 1;\n    const maxTilt = getMapMaxTilt(gmZoom);\n    return Object.assign(Object.assign({}, viewState), {\n        fovy: 25,\n        pitch: Math.min(maxTilt, pitch)\n    });\n};\n //# sourceMappingURL=index.modern.mjs.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;\n$RefreshReg$(_c, \"APIProvider\");\n$RefreshReg$(_c1, \"AuthFailureMessage\");\n$RefreshReg$(_c2, \"Map\");\n$RefreshReg$(_c3, \"AdvancedMarker$forwardRef\");\n$RefreshReg$(_c4, \"AdvancedMarker\");\n$RefreshReg$(_c5, \"MarkerContent\");\n$RefreshReg$(_c6, \"InfoWindow\");\n$RefreshReg$(_c7, \"StaticMap\");\n$RefreshReg$(_c8, \"MapControl\");\n$RefreshReg$(_c9, \"Marker$forwardRef\");\n$RefreshReg$(_c10, \"Marker\");\n$RefreshReg$(_c11, \"Pin\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzL2Rpc3QvaW5kZXgubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFLO0FBQzVIO0FBQ0M7QUFFMUMsMkRBQTJEO0FBQzNELE1BQU1jLFVBQVU7QUFFaEI7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDhEQUE4RCxHQUc5RCxTQUFTQyxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUlDLElBQUksR0FBR1AsSUFBSUMsT0FBT0sscUJBQXFCLENBQUNULElBQUlVLElBQUlQLEVBQUVRLE1BQU0sRUFBRUQsSUFBSztRQUNwRSxJQUFJVCxFQUFFTyxPQUFPLENBQUNMLENBQUMsQ0FBQ08sRUFBRSxJQUFJLEtBQUtOLE9BQU9DLFNBQVMsQ0FBQ08sb0JBQW9CLENBQUNMLElBQUksQ0FBQ1AsR0FBR0csQ0FBQyxDQUFDTyxFQUFFLEdBQ3pFUixDQUFDLENBQUNDLENBQUMsQ0FBQ08sRUFBRSxDQUFDLEdBQUdWLENBQUMsQ0FBQ0csQ0FBQyxDQUFDTyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPUjtBQUNYO0FBRUEsU0FBU1csVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxR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O0lBQ0osR0FBRztRQUFDa0k7UUFBZ0JDO1FBQWdCMWI7S0FBTTtJQUMxQyxxQkFBT3pILHVEQUFZQSxDQUFDeUgsTUFBTXFCLFFBQVEsRUFBRXFhO0FBQ3hDO0tBdkNNRjtPQUFBQTtBQXlDTixNQUFNVSxZQUFZLENBQUN6UyxHQUFHMFMsSUFBSUMsSUFBSUMsSUFBSUMsS0FBT0QsS0FBSyxDQUFFNVMsSUFBSTBTLEVBQUMsSUFBTUcsQ0FBQUEsS0FBS0QsRUFBQyxJQUFPRCxDQUFBQSxLQUFLRCxFQUFDO0FBQzlFLE1BQU1JLGdCQUFnQixDQUFDeFo7SUFDbkIsSUFBSUEsUUFBUSxJQUFJO1FBQ1osT0FBTztJQUNYO0lBQ0EsSUFBSUEsUUFBUSxNQUFNO1FBQ2QsT0FBTztJQUNYO0lBQ0Esa0JBQWtCO0lBQ2xCLElBQUlBLFFBQVEsSUFBSTtRQUNaLE9BQU9tWixVQUFVblosTUFBTSxJQUFJLElBQUksSUFBSTtJQUN2QztJQUNBLG9CQUFvQjtJQUNwQixPQUFPbVosVUFBVW5aLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDekM7QUFDQTs7Q0FFQyxHQUNELDhEQUE4RDtBQUM5RCxNQUFNeVosaUJBQWlCO1FBQUMsRUFBRXhWLFNBQVMsRUFBRTtJQUNqQyxNQUFNSyxRQUFRTCxVQUFVSyxLQUFLO0lBQzdCLE1BQU1vVixTQUFTelYsVUFBVWpFLElBQUksR0FBRztJQUNoQyxNQUFNMlosVUFBVUgsY0FBY0U7SUFDOUIsT0FBTzFqQixPQUFPNEcsTUFBTSxDQUFDNUcsT0FBTzRHLE1BQU0sQ0FBQyxDQUFDLEdBQUdxSCxZQUFZO1FBQUUyVixNQUFNO1FBQUl0VixPQUFPdVYsS0FBS0MsR0FBRyxDQUFDSCxTQUFTclY7SUFBTztBQUNuRztBQUV3ZCxDQUN4ZCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2aXMuZ2wvcmVhY3QtZ29vZ2xlLW1hcHMvZGlzdC9pbmRleC5tb2Rlcm4ubWpzP2U3YzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VSZWR1Y2VyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNvbnRleHQsIHVzZUxheW91dEVmZmVjdCwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGlzRGVlcEVxdWFsIGZyb20gJ2Zhc3QtZGVlcC1lcXVhbCc7XG5cbi8vIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYnkgdGhlIGJ1aWxkIHByb2Nlc3MuXG5jb25zdCBWRVJTSU9OID0gJzEuNy4xJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jb25zdCBBUElMb2FkaW5nU3RhdHVzID0ge1xuICAgIE5PVF9MT0FERUQ6ICdOT1RfTE9BREVEJyxcbiAgICBMT0FESU5HOiAnTE9BRElORycsXG4gICAgTE9BREVEOiAnTE9BREVEJyxcbiAgICBGQUlMRUQ6ICdGQUlMRUQnLFxuICAgIEFVVEhfRkFJTFVSRTogJ0FVVEhfRkFJTFVSRSdcbn07XG5cbmNvbnN0IE1BUFNfQVBJX0JBU0VfVVJMID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcyc7XG4vKipcbiAqIEEgR29vZ2xlTWFwc0FwaUxvYWRlciB0byByZWxpYWJseSBsb2FkIGFuZCB1bmxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJLlxuICpcbiAqIFRoZSBhY3R1YWwgbG9hZGluZyBhbmQgdW5sb2FkaW5nIGlzIGRlbGF5ZWQgaW50byB0aGUgbWljcm90YXNrIHF1ZXVlLCB0b1xuICogYWxsb3cgdXNpbmcgdGhlIEFQSSBpbiBhbiB1c2VFZmZlY3QgaG9vaywgd2l0aG91dCB3b3JyeWluZyBhYm91dCBtdWx0aXBsZSBBUEkgbG9hZHMuXG4gKi9cbmNsYXNzIEdvb2dsZU1hcHNBcGlMb2FkZXIge1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBNYXBzIEphdmFTY3JpcHQgQVBJIHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICAgICAqIFNpbmNlIHRoZSBNYXBzIGxpYnJhcnkgY2FuIG9ubHkgYmUgbG9hZGVkIG9uY2UgcGVyIHBhZ2UsIHRoaXMgd2lsbFxuICAgICAqIHByb2R1Y2UgYSB3YXJuaW5nIHdoZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50XG4gICAgICogcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHdoZW4gbG9hZGluZyBjb21wbGV0ZXNcbiAgICAgKiBhbmQgcmVqZWN0cyBpbiBjYXNlIG9mIGFuIGVycm9yIG9yIHdoZW4gdGhlIGxvYWRpbmcgd2FzIGFib3J0ZWQuXG4gICAgICovXG4gICAgc3RhdGljIGxvYWQocGFyYW1zLCBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBsaWJyYXJpZXMgPSBwYXJhbXMubGlicmFyaWVzID8gcGFyYW1zLmxpYnJhcmllcy5zcGxpdCgnLCcpIDogW107XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gdGhpcy5zZXJpYWxpemVQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gob25Mb2FkaW5nU3RhdHVzQ2hhbmdlKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IGlmIGBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5YCBoYXMgYmVlbiBkZWZpbmVkIGV4dGVybmFsbHksIHdlXG4gICAgICAgICAgICAvLyAgIGFzc3VtZSB0aGF0IGxvYWRpbmcgaXMgY29tcGxldGUgYW5kIHN1Y2Nlc3NmdWwuXG4gICAgICAgICAgICAvLyAgIElmIGl0IHdhcyBkZWZpbmVkIGJ5IGEgcHJldmlvdXMgY2FsbCB0byB0aGlzIG1ldGhvZCwgYSB3YXJuaW5nXG4gICAgICAgICAgICAvLyAgIG1lc3NhZ2UgaXMgbG9nZ2VkIGlmIHRoZXJlIGFyZSBkaWZmZXJlbmNlcyBpbiBhcGktcGFyYW1ldGVycyB1c2VkXG4gICAgICAgICAgICAvLyAgIGZvciBib3RoIGNhbGxzLlxuICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IHdpbmRvdy5nb29nbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXBzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW1wb3J0TGlicmFyeSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIHNlcmlhbGl6ZWQgcGFyYW1ldGVycyBtZWFucyBpdCB3YXMgbG9hZGVkIGV4dGVybmFsbHlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgPSBzZXJpYWxpemVkUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEltcG9ydExpYnJhcnkocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgIT09IHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtnb29nbGUtbWFwcy1hcGktbG9hZGVyXSBUaGUgbWFwcyBBUEkgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgYCArXG4gICAgICAgICAgICAgICAgICAgIGB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXJzIGFuZCB3aWxsIG5vdCBiZSBsb2FkZWQgYWdhaW4uIFJlZnJlc2ggdGhlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgcGFnZSBmb3IgbmV3IHZhbHVlcyB0byBoYXZlIGVmZmVjdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpYnJhcmllc1RvTG9hZCA9IFsnbWFwcycsIC4uLmxpYnJhcmllc107XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChsaWJyYXJpZXNUb0xvYWQubWFwKG5hbWUgPT4gZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShuYW1lKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBwYXJhbWV0ZXJzIHVzZWQgdG8gbG9hZCB0aGUgbGlicmFyeSBmb3IgZWFzaWVyIGNvbXBhcmlzb24uXG4gICAgICovXG4gICAgc3RhdGljIHNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBhcmFtcy52LFxuICAgICAgICAgICAgcGFyYW1zLmtleSxcbiAgICAgICAgICAgIHBhcmFtcy5sYW5ndWFnZSxcbiAgICAgICAgICAgIHBhcmFtcy5yZWdpb24sXG4gICAgICAgICAgICBwYXJhbXMuYXV0aFJlZmVycmVyUG9saWN5LFxuICAgICAgICAgICAgcGFyYW1zLnNvbHV0aW9uQ2hhbm5lbFxuICAgICAgICBdLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZ2xvYmFsIGBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5YCBmdW5jdGlvbiBmb3IgYm9vdHN0cmFwcGluZy5cbiAgICAgKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIGR5bmFtaWMgbG9hZGluZyBzY3JpcHRcbiAgICAgKiBmcm9tIHRoZSBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIHdpdGggc29tZSBtaW5vciBhZGp1c3RtZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBjcmVhdGVkIGltcG9ydExpYnJhcnkgZnVuY3Rpb24gd2lsbCBsb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSxcbiAgICAgKiB3aGljaCB3aWxsIHRoZW4gcmVwbGFjZSB0aGUgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGZ1bmN0aW9uIHdpdGggdGhlIGZ1bGxcbiAgICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvbG9hZC1tYXBzLWpzLWFwaSNkeW5hbWljLWxpYnJhcnktaW1wb3J0XG4gICAgICovXG4gICAgc3RhdGljIGluaXRJbXBvcnRMaWJyYXJ5KHBhcmFtcykge1xuICAgICAgICBpZiAoIXdpbmRvdy5nb29nbGUpXG4gICAgICAgICAgICB3aW5kb3cuZ29vZ2xlID0ge307XG4gICAgICAgIGlmICghd2luZG93Lmdvb2dsZS5tYXBzKVxuICAgICAgICAgICAgd2luZG93Lmdvb2dsZS5tYXBzID0ge307XG4gICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlLm1hcHNbJ2ltcG9ydExpYnJhcnknXSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2dvb2dsZS1tYXBzLWFwaS1sb2FkZXItaW50ZXJuYWxdOiBpbml0SW1wb3J0TGlicmFyeSBtdXN0IG9ubHkgYmUgY2FsbGVkIG9uY2UnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXBpUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGxvYWRBcGkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXBpUHJvbWlzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpUHJvbWlzZTtcbiAgICAgICAgICAgIGFwaVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxQYXJhbU5hbWUgPSBrZXkucmVwbGFjZSgvW0EtWl0vZywgdCA9PiAnXycgKyB0WzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB1cmxQYXJhbXMuc2V0KHVybFBhcmFtTmFtZSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQoJ2xvYWRpbmcnLCAnYXN5bmMnKTtcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXMuc2V0KCdjYWxsYmFjaycsICdfX2dvb2dsZU1hcHNDYWxsYmFja19fJyk7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5zcmMgPSBNQVBTX0FQSV9CQVNFX1VSTCArIGA/YCArIHVybFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsZW1lbnQubm9uY2UgPVxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W25vbmNlXScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9uY2UpIHx8ICcnO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsZW1lbnQub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgY291bGQgbm90IGxvYWQuJykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2luZG93Ll9fZ29vZ2xlTWFwc0NhbGxiYWNrX18gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2luZG93LmdtX2F1dGhGYWlsdXJlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURJTkc7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0RWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcGlQcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBmb3IgdGhlIGZpcnN0IGxvYWQsIHdlIGRlY2xhcmUgYW4gaW1wb3J0TGlicmFyeSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAgICAgICAgLy8gYmUgb3ZlcndyaXR0ZW4gb25jZSB0aGUgYXBpIGlzIGxvYWRlZC5cbiAgICAgICAgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSA9IGxpYnJhcnlOYW1lID0+IGxvYWRBcGkoKS50aGVuKCgpID0+IGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobGlicmFyeU5hbWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYWxsIHJlZ2lzdGVyZWQgbG9hZGluZ1N0YXR1c0xpc3RlbmVycyBhZnRlciBhIHN0YXR1cyB1cGRhdGUuXG4gICAgICovXG4gICAgc3RhdGljIG5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGZuKHRoaXMubG9hZGluZ1N0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBjdXJyZW50IGxvYWRpbmdTdGF0dXMgb2YgdGhlIEFQSS5cbiAqL1xuR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5OT1RfTE9BREVEO1xuLyoqXG4gKiBBIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGxvYWRpbmcgc3RhdHVzIGNoYW5nZXMuXG4gKi9cbkdvb2dsZU1hcHNBcGlMb2FkZXIubGlzdGVuZXJzID0gW107XG5cbmNvbnN0IERFRkFVTFRfU09MVVRJT05fQ0hBTk5FTCA9ICdHTVBfdmlzZ2xfcmdtbGlicmFyeV92MV9kZWZhdWx0JztcbmNvbnN0IERFRkFVTFRfSU5URVJOQUxfVVNBR0VfQVRUUklCVVRJT05fSURTID0gW1xuICAgIGBnbXBfdmlzZ2xfcmVhY3Rnb29nbGVtYXBzX3Yke1ZFUlNJT059YFxuXTtcbmNvbnN0IEFQSVByb3ZpZGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIGxvY2FsIGhvb2sgdG8gc2V0IHVwIHRoZSBtYXAtaW5zdGFuY2UgbWFuYWdlbWVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiB1c2VNYXBJbnN0YW5jZXMoKSB7XG4gICAgY29uc3QgW21hcEluc3RhbmNlcywgc2V0TWFwSW5zdGFuY2VzXSA9IHVzZVN0YXRlKHt9KTtcbiAgICBjb25zdCBhZGRNYXBJbnN0YW5jZSA9IChtYXBJbnN0YW5jZSwgaWQgPSAnZGVmYXVsdCcpID0+IHtcbiAgICAgICAgc2V0TWFwSW5zdGFuY2VzKGluc3RhbmNlcyA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZXMpLCB7IFtpZF06IG1hcEluc3RhbmNlIH0pKSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVNYXBJbnN0YW5jZSA9IChpZCA9ICdkZWZhdWx0JykgPT4ge1xuICAgICAgICBzZXRNYXBJbnN0YW5jZXMoKF9hKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2IgPSBpZDsgX2FbX2JdOyB2YXIgcmVtYWluaW5nID0gX19yZXN0KF9hLCBbdHlwZW9mIF9iID09PSBcInN5bWJvbFwiID8gX2IgOiBfYiArIFwiXCJdKTtcbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2xlYXJNYXBJbnN0YW5jZXMgPSAoKSA9PiB7XG4gICAgICAgIHNldE1hcEluc3RhbmNlcyh7fSk7XG4gICAgfTtcbiAgICByZXR1cm4geyBtYXBJbnN0YW5jZXMsIGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSwgY2xlYXJNYXBJbnN0YW5jZXMgfTtcbn1cbi8qKlxuICogbG9jYWwgaG9vayB0byBoYW5kbGUgdGhlIGxvYWRpbmcgb2YgdGhlIG1hcHMgQVBJLCByZXR1cm5zIHRoZSBjdXJyZW50IGxvYWRpbmcgc3RhdHVzXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gdXNlR29vZ2xlTWFwc0FwaUxvYWRlcihwcm9wcykge1xuICAgIGNvbnN0IHsgb25Mb2FkLCBvbkVycm9yLCBhcGlLZXksIHZlcnNpb24sIGxpYnJhcmllcyA9IFtdIH0gPSBwcm9wcywgb3RoZXJBcGlQYXJhbXMgPSBfX3Jlc3QocHJvcHMsIFtcIm9uTG9hZFwiLCBcIm9uRXJyb3JcIiwgXCJhcGlLZXlcIiwgXCJ2ZXJzaW9uXCIsIFwibGlicmFyaWVzXCJdKTtcbiAgICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUoR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkaW5nU3RhdHVzKTtcbiAgICBjb25zdCBbbG9hZGVkTGlicmFyaWVzLCBhZGRMb2FkZWRMaWJyYXJ5XSA9IHVzZVJlZHVjZXIoKGxvYWRlZExpYnJhcmllcywgYWN0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2FkZWRMaWJyYXJpZXNbYWN0aW9uLm5hbWVdXG4gICAgICAgICAgICA/IGxvYWRlZExpYnJhcmllc1xuICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvYWRlZExpYnJhcmllcyksIHsgW2FjdGlvbi5uYW1lXTogYWN0aW9uLnZhbHVlIH0pO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBsaWJyYXJpZXNTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGxpYnJhcmllcyA9PT0gbnVsbCB8fCBsaWJyYXJpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpYnJhcmllcy5qb2luKCcsJyksIFtsaWJyYXJpZXNdKTtcbiAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gdXNlTWVtbygoKSA9PiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgYXBpS2V5LCB2ZXJzaW9uIH0sIG90aGVyQXBpUGFyYW1zKSksIFthcGlLZXksIHZlcnNpb24sIG90aGVyQXBpUGFyYW1zXSk7XG4gICAgY29uc3QgaW1wb3J0TGlicmFyeSA9IHVzZUNhbGxiYWNrKChuYW1lKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGxvYWRlZExpYnJhcmllc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlZExpYnJhcmllc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoX2EgPSBnb29nbGUgPT09IG51bGwgfHwgZ29vZ2xlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnb29nbGUubWFwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmltcG9ydExpYnJhcnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1thcGktcHJvdmlkZXItaW50ZXJuYWxdIGltcG9ydExpYnJhcnkgd2FzIGNhbGxlZCBiZWZvcmUgJyArXG4gICAgICAgICAgICAgICAgJ2dvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkgd2FzIGRlZmluZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0geWllbGQgd2luZG93Lmdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgICAgIGFkZExvYWRlZExpYnJhcnkoeyBuYW1lLCB2YWx1ZTogcmVzIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pLCBbbG9hZGVkTGlicmFyaWVzXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7IGtleTogYXBpS2V5IH0sIG90aGVyQXBpUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbilcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnYgPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGlmICgobGlicmFyaWVzU3RyaW5nID09PSBudWxsIHx8IGxpYnJhcmllc1N0cmluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlicmFyaWVzU3RyaW5nLmxlbmd0aCkgPiAwKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGlicmFyaWVzID0gbGlicmFyaWVzU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY2hhbm5lbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jaGFubmVsIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2hhbm5lbCA+IDk5OSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5jaGFubmVsO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc29sdXRpb25DaGFubmVsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zb2x1dGlvbkNoYW5uZWwgPSBERUZBVUxUX1NPTFVUSU9OX0NIQU5ORUw7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zLnNvbHV0aW9uQ2hhbm5lbCA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuc29sdXRpb25DaGFubmVsO1xuICAgICAgICAgICAgICAgIHlpZWxkIEdvb2dsZU1hcHNBcGlMb2FkZXIubG9hZChwYXJhbXMsIHN0YXR1cyA9PiBzZXRTdGF0dXMoc3RhdHVzKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFsnY29yZScsICdtYXBzJywgLi4ubGlicmFyaWVzXSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpbXBvcnRMaWJyYXJ5KG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignPEFwaVByb3ZpZGVyPiBmYWlsZWQgdG8gbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEknLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSkoKTtcbiAgICB9LCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2FwaUtleSwgbGlicmFyaWVzU3RyaW5nLCBzZXJpYWxpemVkUGFyYW1zXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgICAgIGltcG9ydExpYnJhcnlcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlSW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzKHByb3BzKSB7XG4gICAgY29uc3QgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzID0gdXNlTWVtbygoKSA9PiBwcm9wcy5kaXNhYmxlVXNhZ2VBdHRyaWJ1dGlvblxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBERUZBVUxUX0lOVEVSTkFMX1VTQUdFX0FUVFJJQlVUSU9OX0lEUywgW3Byb3BzLmRpc2FibGVVc2FnZUF0dHJpYnV0aW9uXSk7XG4gICAgcmV0dXJuIGludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHdyYXAgdGhlIGNvbXBvbmVudHMgZnJvbSB0aGlzIGxpYnJhcnkgYW5kIGxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJXG4gKi9cbmNvbnN0IEFQSVByb3ZpZGVyID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHByb3BzLCBsb2FkZXJQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wiY2hpbGRyZW5cIl0pO1xuICAgIGNvbnN0IHsgbWFwSW5zdGFuY2VzLCBhZGRNYXBJbnN0YW5jZSwgcmVtb3ZlTWFwSW5zdGFuY2UsIGNsZWFyTWFwSW5zdGFuY2VzIH0gPSB1c2VNYXBJbnN0YW5jZXMoKTtcbiAgICBjb25zdCB7IHN0YXR1cywgbG9hZGVkTGlicmFyaWVzLCBpbXBvcnRMaWJyYXJ5IH0gPSB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKGxvYWRlclByb3BzKTtcbiAgICBjb25zdCBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgPSB1c2VJbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMobG9hZGVyUHJvcHMpO1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgbWFwSW5zdGFuY2VzLFxuICAgICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgICAgIGNsZWFyTWFwSW5zdGFuY2VzLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICAgICAgaW1wb3J0TGlicmFyeSxcbiAgICAgICAgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzXG4gICAgfSksIFtcbiAgICAgICAgbWFwSW5zdGFuY2VzLFxuICAgICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgICAgIGNsZWFyTWFwSW5zdGFuY2VzLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICAgICAgaW1wb3J0TGlicmFyeSxcbiAgICAgICAgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzXG4gICAgXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEFQSVByb3ZpZGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKSk7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgZWZmZWN0cyB0byBiaW5kIGV2ZW50LWhhbmRsZXJzIGZvciBhbGwgZXZlbnQtcHJvcHMgaW4gTWFwRXZlbnRQcm9wcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBFdmVudHMobWFwLCBwcm9wcykge1xuICAgIC8vIG5vdGU6IGNhbGxpbmcgYSB1c2VFZmZlY3QgaG9vayBmcm9tIHdpdGhpbiBhIGxvb3AgaXMgcHJvaGliaXRlZCBieSB0aGVcbiAgICAvLyBydWxlcyBvZiBob29rcywgYnV0IGl0J3Mgb2sgaGVyZSBzaW5jZSBpdCdzIHVuY29uZGl0aW9uYWwgYW5kIHRoZSBudW1iZXJcbiAgICAvLyBhbmQgb3JkZXIgb2YgaXRlcmF0aW9ucyBpcyBhbHdheXMgc3RyaWN0bHkgdGhlIHNhbWUuXG4gICAgLy8gKHNlZSBodHRwczovL2xlZ2FjeS5yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJ1bGVzLmh0bWwpXG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBldmVudFByb3BOYW1lcykge1xuICAgICAgICAvLyBmaXhtZTogdGhpcyBjYXN0IGlzIGVzc2VudGlhbGx5IGEgJ3RydXN0IG1lLCBicm8nIGZvciB0eXBlc2NyaXB0LCBidXRcbiAgICAgICAgLy8gICBhIHByb3BlciBzb2x1dGlvbiBzZWVtcyB3YXkgdG9vIGNvbXBsaWNhdGVkIHJpZ2h0IG5vd1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBjb25zdCBldmVudFR5cGUgPSBwcm9wTmFtZVRvRXZlbnRUeXBlW3Byb3BOYW1lXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsIGV2ZW50VHlwZSwgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihjcmVhdGVNYXBFdmVudChldmVudFR5cGUsIG1hcCwgZXYpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgICB9LCBbbWFwLCBldmVudFR5cGUsIGhhbmRsZXJdKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgd3JhcHBlZCBtYXAtZXZlbnRzIHVzZWQgZm9yIHRoZSBldmVudC1wcm9wcy5cbiAqIEBwYXJhbSB0eXBlIHRoZSBldmVudCB0eXBlIGFzIGl0IGlzIHNwZWNpZmllZCB0byB0aGUgbWFwcyBhcGlcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tXG4gKiBAcGFyYW0gc3JjRXZlbnQgdGhlIHNvdXJjZS1ldmVudCBpZiB0aGVyZSBpcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hcEV2ZW50KHR5cGUsIG1hcCwgc3JjRXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXYgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIG1hcCxcbiAgICAgICAgZGV0YWlsOiB7fSxcbiAgICAgICAgc3RvcHBhYmxlOiBmYWxzZSxcbiAgICAgICAgc3RvcDogKCkgPT4geyB9XG4gICAgfTtcbiAgICBpZiAoY2FtZXJhRXZlbnRUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICBjb25zdCBjYW1FdmVudCA9IGV2O1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICBjb25zdCBoZWFkaW5nID0gbWFwLmdldEhlYWRpbmcoKSB8fCAwO1xuICAgICAgICBjb25zdCB0aWx0ID0gbWFwLmdldFRpbHQoKSB8fCAwO1xuICAgICAgICBjb25zdCBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgIGlmICghY2VudGVyIHx8ICFib3VuZHMgfHwgIU51bWJlci5pc0Zpbml0ZSh6b29tKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbY3JlYXRlRXZlbnRdIGF0IGxlYXN0IG9uZSBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIG1hcCAnICtcbiAgICAgICAgICAgICAgICAncmV0dXJuZWQgdW5kZWZpbmVkLiBUaGlzIGlzIG5vdCBleHBlY3RlZCB0byBoYXBwZW4uIFBsZWFzZSAnICtcbiAgICAgICAgICAgICAgICAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FtRXZlbnQuZGV0YWlsID0ge1xuICAgICAgICAgICAgY2VudGVyOiAoY2VudGVyID09PSBudWxsIHx8IGNlbnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7IGxhdDogMCwgbG5nOiAwIH0sXG4gICAgICAgICAgICB6b29tOiB6b29tIHx8IDAsXG4gICAgICAgICAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgICAgICAgICAgdGlsdDogdGlsdCxcbiAgICAgICAgICAgIGJvdW5kczogKGJvdW5kcyA9PT0gbnVsbCB8fCBib3VuZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvdW5kcy50b0pTT04oKSkgfHwge1xuICAgICAgICAgICAgICAgIG5vcnRoOiA5MCxcbiAgICAgICAgICAgICAgICBlYXN0OiAxODAsXG4gICAgICAgICAgICAgICAgc291dGg6IC05MCxcbiAgICAgICAgICAgICAgICB3ZXN0OiAtMTgwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYW1FdmVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAobW91c2VFdmVudFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGlmICghc3JjRXZlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjcmVhdGVFdmVudF0gbW91c2UgZXZlbnRzIG11c3QgcHJvdmlkZSBhIHNyY0V2ZW50Jyk7XG4gICAgICAgIGNvbnN0IG1vdXNlRXZlbnQgPSBldjtcbiAgICAgICAgbW91c2VFdmVudC5kb21FdmVudCA9IHNyY0V2ZW50LmRvbUV2ZW50O1xuICAgICAgICBtb3VzZUV2ZW50LnN0b3BwYWJsZSA9IHRydWU7XG4gICAgICAgIG1vdXNlRXZlbnQuc3RvcCA9ICgpID0+IHNyY0V2ZW50LnN0b3AoKTtcbiAgICAgICAgbW91c2VFdmVudC5kZXRhaWwgPSB7XG4gICAgICAgICAgICBsYXRMbmc6ICgoX2EgPSBzcmNFdmVudC5sYXRMbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHBsYWNlSWQ6IHNyY0V2ZW50LnBsYWNlSWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBldjtcbn1cbi8qKlxuICogbWFwcyB0aGUgY2FtZWxDYXNlZCBuYW1lcyBvZiBldmVudC1wcm9wcyB0byB0aGUgY29ycmVzcG9uZGluZyBldmVudC10eXBlc1xuICogdXNlZCBpbiB0aGUgbWFwcyBBUEkuXG4gKi9cbmNvbnN0IHByb3BOYW1lVG9FdmVudFR5cGUgPSB7XG4gICAgb25Cb3VuZHNDaGFuZ2VkOiAnYm91bmRzX2NoYW5nZWQnLFxuICAgIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxuICAgIG9uQ29udGV4dG1lbnU6ICdjb250ZXh0bWVudScsXG4gICAgb25EYmxjbGljazogJ2RibGNsaWNrJyxcbiAgICBvbkRyYWc6ICdkcmFnJyxcbiAgICBvbkRyYWdlbmQ6ICdkcmFnZW5kJyxcbiAgICBvbkRyYWdzdGFydDogJ2RyYWdzdGFydCcsXG4gICAgb25IZWFkaW5nQ2hhbmdlZDogJ2hlYWRpbmdfY2hhbmdlZCcsXG4gICAgb25JZGxlOiAnaWRsZScsXG4gICAgb25Jc0ZyYWN0aW9uYWxab29tRW5hYmxlZENoYW5nZWQ6ICdpc2ZyYWN0aW9uYWx6b29tZW5hYmxlZF9jaGFuZ2VkJyxcbiAgICBvbk1hcENhcGFiaWxpdGllc0NoYW5nZWQ6ICdtYXBjYXBhYmlsaXRpZXNfY2hhbmdlZCcsXG4gICAgb25NYXBUeXBlSWRDaGFuZ2VkOiAnbWFwdHlwZWlkX2NoYW5nZWQnLFxuICAgIG9uTW91c2Vtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICBvbk1vdXNlb3V0OiAnbW91c2VvdXQnLFxuICAgIG9uTW91c2VvdmVyOiAnbW91c2VvdmVyJyxcbiAgICBvblByb2plY3Rpb25DaGFuZ2VkOiAncHJvamVjdGlvbl9jaGFuZ2VkJyxcbiAgICBvblJlbmRlcmluZ1R5cGVDaGFuZ2VkOiAncmVuZGVyaW5ndHlwZV9jaGFuZ2VkJyxcbiAgICBvblRpbGVzTG9hZGVkOiAndGlsZXNsb2FkZWQnLFxuICAgIG9uVGlsdENoYW5nZWQ6ICd0aWx0X2NoYW5nZWQnLFxuICAgIG9uWm9vbUNoYW5nZWQ6ICd6b29tX2NoYW5nZWQnLFxuICAgIC8vIG5vdGU6IG9uQ2FtZXJhQ2hhbmdlZCBpcyBhbiBhbGlhcyBmb3IgdGhlIGJvdW5kc19jaGFuZ2VkIGV2ZW50LFxuICAgIC8vIHNpbmNlIHRoYXQgaXMgZ29pbmcgdG8gYmUgZmlyZWQgaW4gZXZlcnkgc2l0dWF0aW9uIHdoZXJlIHRoZSBjYW1lcmEgaXNcbiAgICAvLyB1cGRhdGVkLlxuICAgIG9uQ2FtZXJhQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJ1xufTtcbmNvbnN0IGNhbWVyYUV2ZW50VHlwZXMgPSBbXG4gICAgJ2JvdW5kc19jaGFuZ2VkJyxcbiAgICAnY2VudGVyX2NoYW5nZWQnLFxuICAgICdoZWFkaW5nX2NoYW5nZWQnLFxuICAgICd0aWx0X2NoYW5nZWQnLFxuICAgICd6b29tX2NoYW5nZWQnXG5dO1xuY29uc3QgbW91c2VFdmVudFR5cGVzID0gW1xuICAgICdjbGljaycsXG4gICAgJ2NvbnRleHRtZW51JyxcbiAgICAnZGJsY2xpY2snLFxuICAgICdtb3VzZW1vdmUnLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ21vdXNlb3Zlcidcbl07XG5jb25zdCBldmVudFByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BOYW1lVG9FdmVudFR5cGUpO1xuXG4vKipcbiAqIEEgaG9vayB0byBzdG9yZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYSB2YXJpYWJsZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RvcmVcbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyB2YWx1ZVxuICovXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZih1bmRlZmluZWQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3JlZnNcbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9pemVkKHZhbHVlLCBpc0VxdWFsKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSB1c2VQcmV2aW91cyh2YWx1ZSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAocHJldmlvdXMgJiYgaXNFcXVhbChwcmV2aW91cywgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIFt2YWx1ZSwgcHJldmlvdXMsIGlzRXF1YWxdKTtcbn1cblxuZnVuY3Rpb24gdXNlQ3VzdG9tQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcGVuZGVuY2llcywgaXNFcXVhbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB1c2VFZmZlY3QoZWZmZWN0LCBbdXNlTWVtb2l6ZWQoZGVwZW5kZW5jaWVzLCBpc0VxdWFsKV0pO1xufVxuXG5mdW5jdGlvbiB1c2VEZWVwQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcGVuZGVuY2llcykge1xuICAgIHVzZUN1c3RvbUNvbXBhcmVFZmZlY3QoZWZmZWN0LCBkZXBlbmRlbmNpZXMsIGlzRGVlcEVxdWFsKTtcbn1cblxuY29uc3QgbWFwT3B0aW9uS2V5cyA9IG5ldyBTZXQoW1xuICAgICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICdjbGlja2FibGVJY29ucycsXG4gICAgJ2NvbnRyb2xTaXplJyxcbiAgICAnZGlzYWJsZURlZmF1bHRVSScsXG4gICAgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLFxuICAgICdkcmFnZ2FibGUnLFxuICAgICdkcmFnZ2FibGVDdXJzb3InLFxuICAgICdkcmFnZ2luZ0N1cnNvcicsXG4gICAgJ2Z1bGxzY3JlZW5Db250cm9sJyxcbiAgICAnZnVsbHNjcmVlbkNvbnRyb2xPcHRpb25zJyxcbiAgICAnZ2VzdHVyZUhhbmRsaW5nJyxcbiAgICAnaGVhZGluZ0ludGVyYWN0aW9uRW5hYmxlZCcsXG4gICAgJ2lzRnJhY3Rpb25hbFpvb21FbmFibGVkJyxcbiAgICAna2V5Ym9hcmRTaG9ydGN1dHMnLFxuICAgICdtYXBUeXBlQ29udHJvbCcsXG4gICAgJ21hcFR5cGVDb250cm9sT3B0aW9ucycsXG4gICAgJ21hcFR5cGVJZCcsXG4gICAgJ21heFpvb20nLFxuICAgICdtaW5ab29tJyxcbiAgICAnbm9DbGVhcicsXG4gICAgJ3BhbkNvbnRyb2wnLFxuICAgICdwYW5Db250cm9sT3B0aW9ucycsXG4gICAgJ3Jlc3RyaWN0aW9uJyxcbiAgICAncm90YXRlQ29udHJvbCcsXG4gICAgJ3JvdGF0ZUNvbnRyb2xPcHRpb25zJyxcbiAgICAnc2NhbGVDb250cm9sJyxcbiAgICAnc2NhbGVDb250cm9sT3B0aW9ucycsXG4gICAgJ3Njcm9sbHdoZWVsJyxcbiAgICAnc3RyZWV0VmlldycsXG4gICAgJ3N0cmVldFZpZXdDb250cm9sJyxcbiAgICAnc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zJyxcbiAgICAnc3R5bGVzJyxcbiAgICAndGlsdEludGVyYWN0aW9uRW5hYmxlZCcsXG4gICAgJ3pvb21Db250cm9sJyxcbiAgICAnem9vbUNvbnRyb2xPcHRpb25zJ1xuXSk7XG4vKipcbiAqIEludGVybmFsIGhvb2sgdG8gdXBkYXRlIHRoZSBtYXAtb3B0aW9ucyB3aGVuIHByb3BzIGFyZSBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZVxuICogQHBhcmFtIG1hcFByb3BzIHRoZSBwcm9wcyB0byB1cGRhdGUgdGhlIG1hcC1pbnN0YW5jZSB3aXRoXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwT3B0aW9ucyhtYXAsIG1hcFByb3BzKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGVmZmVjdHMgYXJlbid0IHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgY2hhbmdlZC5cbiAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSB2YWx1ZXMgd2lsbCBiZSBvciBoYXZlIGJlZW4gcGFzc2VkIHRvIHRoZSBtYXBcbiAgICAgKiBjb25zdHJ1Y3RvciB2aWEgbWFwT3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdCBtYXBPcHRpb25zID0ge307XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1hcFByb3BzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghbWFwT3B0aW9uS2V5cy5oYXMoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBtYXBPcHRpb25zW2tleV0gPSBtYXBQcm9wc1trZXldO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgdGhlIG1hcCBvcHRpb25zIHdoZW4gbWFwT3B0aW9ucyBpcyBjaGFuZ2VkXG4gICAgLy8gTm90ZTogZHVlIHRvIHRoZSBkZXN0cnVjdHVyaW5nIGFib3ZlLCBtYXBPcHRpb25zIHdpbGwgYmUgc2VlbiBhcyBjaGFuZ2VkXG4gICAgLy8gICB3aXRoIGV2ZXJ5IHJlLXJlbmRlciwgc28gd2UncmUgYXNzdW1pbmcgdGhlIG1hcHMtYXBpIHdpbGwgcHJvcGVybHlcbiAgICAvLyAgIGRlYWwgd2l0aCB1bmNoYW5nZWQgb3B0aW9uLXZhbHVlcyBwYXNzZWQgaW50byBzZXRPcHRpb25zLlxuICAgIHVzZURlZXBDb21wYXJlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hcC5zZXRPcHRpb25zKG1hcE9wdGlvbnMpO1xuICAgIH0sIFttYXBPcHRpb25zXSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbn1cblxuZnVuY3Rpb24gdXNlQXBpTG9hZGluZ1N0YXR1cygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpIHx8IEFQSUxvYWRpbmdTdGF0dXMuTk9UX0xPQURFRDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBob29rIHRoYXQgdXBkYXRlcyB0aGUgY2FtZXJhIHdoZW4gZGVjay5nbCB2aWV3U3RhdGUgY2hhbmdlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcykge1xuICAgIGNvbnN0IHsgdmlld3BvcnQsIHZpZXdTdGF0ZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNEZWNrR2xDb250cm9sbGVkID0gISF2aWV3cG9ydDtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcCB8fCAhdmlld1N0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUsIGJlYXJpbmc6IGhlYWRpbmcsIHBpdGNoOiB0aWx0LCB6b29tIH0gPSB2aWV3U3RhdGU7XG4gICAgICAgIG1hcC5tb3ZlQ2FtZXJhKHtcbiAgICAgICAgICAgIGNlbnRlcjogeyBsYXQ6IGxhdGl0dWRlLCBsbmc6IGxvbmdpdHVkZSB9LFxuICAgICAgICAgICAgaGVhZGluZyxcbiAgICAgICAgICAgIHRpbHQsXG4gICAgICAgICAgICB6b29tOiB6b29tICsgMVxuICAgICAgICB9KTtcbiAgICB9LCBbbWFwLCB2aWV3U3RhdGVdKTtcbiAgICByZXR1cm4gaXNEZWNrR2xDb250cm9sbGVkO1xufVxuXG5mdW5jdGlvbiBpc0xhdExuZ0xpdGVyYWwob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoISgnbGF0JyBpbiBvYmogJiYgJ2xuZycgaW4gb2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUob2JqLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKG9iai5sbmcpO1xufVxuZnVuY3Rpb24gbGF0TG5nRXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoIWEgfHwgIWIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBBID0gdG9MYXRMbmdMaXRlcmFsKGEpO1xuICAgIGNvbnN0IEIgPSB0b0xhdExuZ0xpdGVyYWwoYik7XG4gICAgaWYgKEEubGF0ICE9PSBCLmxhdCB8fCBBLmxuZyAhPT0gQi5sbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvTGF0TG5nTGl0ZXJhbChvYmopIHtcbiAgICBpZiAoaXNMYXRMbmdMaXRlcmFsKG9iaikpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIG9iai50b0pTT04oKTtcbn1cblxuZnVuY3Rpb24gdXNlTWFwQ2FtZXJhUGFyYW1zKG1hcCwgY2FtZXJhU3RhdGVSZWYsIG1hcFByb3BzKSB7XG4gICAgY29uc3QgY2VudGVyID0gbWFwUHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKG1hcFByb3BzLmNlbnRlcikgOiBudWxsO1xuICAgIGxldCBsYXQgPSBudWxsO1xuICAgIGxldCBsbmcgPSBudWxsO1xuICAgIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgICAgICBsYXQgPSBjZW50ZXIubGF0O1xuICAgICAgICBsbmcgPSBjZW50ZXIubG5nO1xuICAgIH1cbiAgICBjb25zdCB6b29tID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLnpvb20pXG4gICAgICAgID8gbWFwUHJvcHMuem9vbVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgaGVhZGluZyA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy5oZWFkaW5nKVxuICAgICAgICA/IG1hcFByb3BzLmhlYWRpbmdcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHRpbHQgPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMudGlsdClcbiAgICAgICAgPyBtYXBQcm9wcy50aWx0XG4gICAgICAgIDogbnVsbDtcbiAgICAvLyB0aGUgZm9sbG93aW5nIGVmZmVjdCBydW5zIGZvciBldmVyeSByZW5kZXIgb2YgdGhlIG1hcCBjb21wb25lbnQgYW5kIGNoZWNrc1xuICAgIC8vIGlmIHRoZXJlIGFyZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBrbm93biBzdGF0ZSBvZiB0aGUgbWFwIGluc3RhbmNlXG4gICAgLy8gKGNhbWVyYVN0YXRlUmVmLCB3aGljaCBpcyB1cGRhdGVkIGJ5IGFsbCBib3VuZHNfY2hhbmdlZCBldmVudHMpIGFuZCB0aGVcbiAgICAvLyBkZXNpcmVkIHN0YXRlIGluIHRoZSBwcm9wcy5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV4dENhbWVyYSA9IHt9O1xuICAgICAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxhdCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgbG5nICE9PSBudWxsICYmXG4gICAgICAgICAgICAoY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubGF0ICE9PSBsYXQgfHxcbiAgICAgICAgICAgICAgICBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmNlbnRlci5sbmcgIT09IGxuZykpIHtcbiAgICAgICAgICAgIG5leHRDYW1lcmEuY2VudGVyID0geyBsYXQsIGxuZyB9O1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b29tICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuem9vbSAhPT0gem9vbSkge1xuICAgICAgICAgICAgbmV4dENhbWVyYS56b29tID0gem9vbTtcbiAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGluZyAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmhlYWRpbmcgIT09IGhlYWRpbmcpIHtcbiAgICAgICAgICAgIG5leHRDYW1lcmEuaGVhZGluZyA9IGhlYWRpbmc7XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbHQgIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC50aWx0ICE9PSB0aWx0KSB7XG4gICAgICAgICAgICBuZXh0Q2FtZXJhLnRpbHQgPSB0aWx0O1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgbWFwLm1vdmVDYW1lcmEobmV4dENhbWVyYSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuY29uc3QgQXV0aEZhaWx1cmVNZXNzYWdlID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB6SW5kZXg6IDk5OSxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RmxvdzogJ2NvbHVtbiBub3dyYXAnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgIGZvbnRTaXplOiAnLjhyZW0nLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC42KScsXG4gICAgICAgIGJhY2tncm91bmQ6ICcjZGRkZGRkJyxcbiAgICAgICAgcGFkZGluZzogJzFyZW0gMS41cmVtJ1xuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHN0eWxlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIkVycm9yOiBBdXRoRmFpbHVyZVwiKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCxcbiAgICAgICAgICAgIFwiQSBwcm9ibGVtIHdpdGggeW91ciBBUEkga2V5IHByZXZlbnRzIHRoZSBtYXAgZnJvbSByZW5kZXJpbmcgY29ycmVjdGx5LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSB2YWx1ZSBvZiB0aGUgXCIsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBcIkFQSVByb3ZpZGVyLmFwaUtleVwiKSxcbiAgICAgICAgICAgIFwiIHByb3AgaXMgY29ycmVjdC4gQ2hlY2sgdGhlIGVycm9yLW1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgZm9yIGZ1cnRoZXIgZGV0YWlscy5cIikpKTtcbn07XG5cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrUmVmKCkge1xuICAgIGNvbnN0IFtlbCwgc2V0RWxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgcmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiBzZXRFbCh2YWx1ZSksIFtzZXRFbF0pO1xuICAgIHJldHVybiBbZWwsIHJlZl07XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiB0aGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBpcyBsb2FkZWRcbiAqL1xuZnVuY3Rpb24gdXNlQXBpSXNMb2FkZWQoKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICAgIHJldHVybiBzdGF0dXMgPT09IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xufVxuXG5mdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcbiAgICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VSZWR1Y2VyKHggPT4geCArIDEsIDApO1xuICAgIHJldHVybiBmb3JjZVVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQm91bmRzQ2hhbmdlKG1hcCwgcmVmKSB7XG4gICAgY29uc3QgY2VudGVyID0gbWFwLmdldENlbnRlcigpO1xuICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gICAgY29uc3QgdGlsdCA9IG1hcC5nZXRUaWx0KCkgfHwgMDtcbiAgICBjb25zdCBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3VzZVRyYWNrZWRDYW1lcmFTdGF0ZV0gYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgbWFwICcgK1xuICAgICAgICAgICAgJ3JldHVybmVkIHVuZGVmaW5lZC4gVGhpcyBpcyBub3QgZXhwZWN0ZWQgdG8gaGFwcGVuLiBQbGVhc2UgJyArXG4gICAgICAgICAgICAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gICAgfVxuICAgIC8vIGZpeG1lOiBkbyB3ZSBuZWVkIHRoZSBgdW5kZWZpbmVkYCBjYXNlcyBmb3IgdGhlIGNhbWVyYS1wYXJhbXM/IFdoZW4gYXJlIHRoZXkgdXNlZCBpbiB0aGUgbWFwcyBBUEk/XG4gICAgT2JqZWN0LmFzc2lnbihyZWYuY3VycmVudCwge1xuICAgICAgICBjZW50ZXI6IChjZW50ZXIgPT09IG51bGwgfHwgY2VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZW50ZXIudG9KU09OKCkpIHx8IHsgbGF0OiAwLCBsbmc6IDAgfSxcbiAgICAgICAgem9vbTogem9vbSB8fCAwLFxuICAgICAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgICAgICB0aWx0OiB0aWx0XG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QgdG8gdHJhY2sgdGhlIGxhc3Qga25vd24gc3RhdGUgb2YgdGhlIG1hcCBjYW1lcmEuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYHVzZU1hcENhbWVyYVBhcmFtc2AgdG8gcmVkdWNlIHN0dXR0ZXJpbmcgaW4gbm9ybWFsIG9wZXJhdGlvblxuICogYnkgYXZvaWRpbmcgdXBkYXRlcyBvZiB0aGUgbWFwIGNhbWVyYSB3aXRoIHZhbHVlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCkge1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoe1xuICAgICAgICBjZW50ZXI6IHsgbGF0OiAwLCBsbmc6IDAgfSxcbiAgICAgICAgaGVhZGluZzogMCxcbiAgICAgICAgdGlsdDogMCxcbiAgICAgICAgem9vbTogMFxuICAgIH0pO1xuICAgIC8vIFJlY29yZCBjYW1lcmEgc3RhdGUgd2l0aCBldmVyeSBib3VuZHNfY2hhbmdlZCBldmVudCBkaXNwYXRjaGVkIGJ5IHRoZSBtYXAuXG4gICAgLy8gVGhpcyBkYXRhIGlzIHVzZWQgdG8gcHJldmVudCBmZWVkaW5nIHRoZXNlIHZhbHVlcyBiYWNrIHRvIHRoZVxuICAgIC8vIG1hcC1pbnN0YW5jZSB3aGVuIGEgdHlwaWNhbCBcImNvbnRyb2xsZWQgY29tcG9uZW50XCIgc2V0dXAgKHN0YXRlIHZhcmlhYmxlIGlzXG4gICAgLy8gZmVkIGludG8gYW5kIHVwZGF0ZWQgYnkgdGhlIG1hcCkuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnYm91bmRzX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVCb3VuZHNDaGFuZ2UobWFwLCByZWYpO1xuICAgICAgICAgICAgLy8gV2hlbiBhbiBldmVudCBpcyBvY2N1cmVkLCB3ZSBoYXZlIHRvIHVwZGF0ZSBkdXJpbmcgdGhlIG5leHQgY3ljbGUuXG4gICAgICAgICAgICAvLyBUaGUgYXBwbGljYXRpb24gY291bGQgZGVjaWRlIHRvIGlnbm9yZSB0aGUgZXZlbnQgYW5kIG5vdCB1cGRhdGUgYW55XG4gICAgICAgICAgICAvLyBjYW1lcmEgcHJvcHMgb2YgdGhlIG1hcCwgbWVhbmluZyB0aGF0IGluIHRoYXQgY2FzZSB3ZSB3aWxsIGhhdmUgdG9cbiAgICAgICAgICAgIC8vICd1bmRvJyB0aGUgY2hhbmdlIHRvIHRoZSBjYW1lcmEuXG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgIH0sIFttYXAsIGZvcmNlVXBkYXRlXSk7XG4gICAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBTdG9yZXMgYSBzdGFjayBvZiBtYXAtaW5zdGFuY2VzIGZvciBlYWNoIG1hcElkLiBXaGVuZXZlciBhblxuICogaW5zdGFuY2UgaXMgdXNlZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjayB3aGlsZSBpbiB1c2UsXG4gKiBhbmQgcmV0dXJuZWQgdG8gdGhlIHN0YWNrIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50cy5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIGNvcnJlY3RseSBpbXBsZW1lbnQgY2FjaGluZyBmb3IgbXVsdGlwbGVcbiAqIG1hcHMgb20gdGhlIHNhbWUgcGFnZSwgd2hpbGUgcmV1c2luZyBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICpcbiAqIEZJWE1FOiB3aGlsZSBpdCBzaG91bGQgaW4gdGhlb3J5IGJlIHBvc3NpYmxlIHRvIHJldXNlIG1hcHMgc29sZWx5XG4gKiAgIGJhc2VkIG9uIHRoZSBtYXBJZCAoYXMgYWxsIG90aGVyIHBhcmFtZXRlcnMgY2FuIGJlIGNoYW5nZWQgYXRcbiAqICAgcnVudGltZSksIHdlIGRvbid0IHlldCBoYXZlIGdvb2QgZW5vdWdoIHRyYWNraW5nIG9mIG9wdGlvbnMgdG9cbiAqICAgcmVsaWFibHkgdW5zZXQgYWxsIHRoZSBvcHRpb25zIHRoYXQgaGF2ZSBiZWVuIHNldC5cbiAqL1xuY2xhc3MgQ2FjaGVkTWFwU3RhY2sge1xuICAgIHN0YXRpYyBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNba2V5XSAmJiB0aGlzLmVudHJpZXNba2V5XS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBzdGF0aWMgcG9wKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuZW50cmllc1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNba2V5XS5wb3AoKSB8fCBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgcHVzaChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyaWVzW2tleV0pXG4gICAgICAgICAgICB0aGlzLmVudHJpZXNba2V5XSA9IFtdO1xuICAgICAgICB0aGlzLmVudHJpZXNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5DYWNoZWRNYXBTdGFjay5lbnRyaWVzID0ge307XG4vKipcbiAqIFRoZSBtYWluIGhvb2sgdGFrZXMgY2FyZSBvZiBjcmVhdGluZyBtYXAtaW5zdGFuY2VzIGFuZCByZWdpc3RlcmluZyB0aGVtIGluXG4gKiB0aGUgYXBpLXByb3ZpZGVyIGNvbnRleHQuXG4gKiBAcmV0dXJuIGEgdHVwbGUgb2YgdGhlIG1hcC1pbnN0YW5jZSBjcmVhdGVkIChvciBudWxsKSBhbmQgdGhlIGNhbGxiYWNrXG4gKiAgIHJlZiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXNzIHRoZSBtYXAtY29udGFpbmVyIGludG8gdGhpcyBob29rLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYXBpSXNMb2FkZWQgPSB1c2VBcGlJc0xvYWRlZCgpO1xuICAgIGNvbnN0IFttYXAsIHNldE1hcF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY29udGFpbmVyLCBjb250YWluZXJSZWZdID0gdXNlQ2FsbGJhY2tSZWYoKTtcbiAgICBjb25zdCBjYW1lcmFTdGF0ZVJlZiA9IHVzZVRyYWNrZWRDYW1lcmFTdGF0ZVJlZihtYXApO1xuICAgIGNvbnN0IHsgaWQsIGRlZmF1bHRCb3VuZHMsIGRlZmF1bHRDZW50ZXIsIGRlZmF1bHRab29tLCBkZWZhdWx0SGVhZGluZywgZGVmYXVsdFRpbHQsIHJldXNlTWFwcywgcmVuZGVyaW5nVHlwZSwgY29sb3JTY2hlbWUgfSA9IHByb3BzLCBtYXBPcHRpb25zID0gX19yZXN0KHByb3BzLCBbXCJpZFwiLCBcImRlZmF1bHRCb3VuZHNcIiwgXCJkZWZhdWx0Q2VudGVyXCIsIFwiZGVmYXVsdFpvb21cIiwgXCJkZWZhdWx0SGVhZGluZ1wiLCBcImRlZmF1bHRUaWx0XCIsIFwicmV1c2VNYXBzXCIsIFwicmVuZGVyaW5nVHlwZVwiLCBcImNvbG9yU2NoZW1lXCJdKTtcbiAgICBjb25zdCBoYXNab29tID0gcHJvcHMuem9vbSAhPT0gdW5kZWZpbmVkIHx8IHByb3BzLmRlZmF1bHRab29tICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzQ2VudGVyID0gcHJvcHMuY2VudGVyICE9PSB1bmRlZmluZWQgfHwgcHJvcHMuZGVmYXVsdENlbnRlciAhPT0gdW5kZWZpbmVkO1xuICAgIGlmICghZGVmYXVsdEJvdW5kcyAmJiAoIWhhc1pvb20gfHwgIWhhc0NlbnRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCc8TWFwPiBjb21wb25lbnQgaXMgbWlzc2luZyBjb25maWd1cmF0aW9uLiAnICtcbiAgICAgICAgICAgICdZb3UgaGF2ZSB0byBwcm92aWRlIHpvb20gYW5kIGNlbnRlciAodmlhIHRoZSBgem9vbWAvYGRlZmF1bHRab29tYCBhbmQgJyArXG4gICAgICAgICAgICAnYGNlbnRlcmAvYGRlZmF1bHRDZW50ZXJgIHByb3BzKSBvciBzcGVjaWZ5IHRoZSByZWdpb24gdG8gc2hvdyB1c2luZyAnICtcbiAgICAgICAgICAgICdgZGVmYXVsdEJvdW5kc2AuIFNlZSAnICtcbiAgICAgICAgICAgICdodHRwczovL3Zpc2dsLmdpdGh1Yi5pby9yZWFjdC1nb29nbGUtbWFwcy9kb2NzL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9tYXAjcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gYXBwbHkgZGVmYXVsdCBjYW1lcmEgcHJvcHMgaWYgYXZhaWxhYmxlIGFuZCBub3Qgb3ZlcndyaXR0ZW4gYnkgY29udHJvbGxlZCBwcm9wc1xuICAgIGlmICghbWFwT3B0aW9ucy5jZW50ZXIgJiYgZGVmYXVsdENlbnRlcilcbiAgICAgICAgbWFwT3B0aW9ucy5jZW50ZXIgPSBkZWZhdWx0Q2VudGVyO1xuICAgIGlmICghbWFwT3B0aW9ucy56b29tICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0Wm9vbSkpXG4gICAgICAgIG1hcE9wdGlvbnMuem9vbSA9IGRlZmF1bHRab29tO1xuICAgIGlmICghbWFwT3B0aW9ucy5oZWFkaW5nICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0SGVhZGluZykpXG4gICAgICAgIG1hcE9wdGlvbnMuaGVhZGluZyA9IGRlZmF1bHRIZWFkaW5nO1xuICAgIGlmICghbWFwT3B0aW9ucy50aWx0ICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0VGlsdCkpXG4gICAgICAgIG1hcE9wdGlvbnMudGlsdCA9IGRlZmF1bHRUaWx0O1xuICAgIC8vIEhhbmRsZSBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHNcbiAgICBjb25zdCBjdXN0b21JZHMgPSBtYXBPcHRpb25zLmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbiAgICBpZiAoY3VzdG9tSWRzID09IG51bGwpIHtcbiAgICAgICAgLy8gTm90IHNwZWNpZmllZCAtIHVzZSBjb250ZXh0IGRlZmF1bHQgKHdoaWNoIG1heSBiZSBudWxsIGlmIGRpc2FibGVkKVxuICAgICAgICBtYXBPcHRpb25zLmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyA9XG4gICAgICAgICAgICBjb250ZXh0LmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIGNvbnRleHQgZGVmYXVsdHMgd2l0aCBjdXN0b20gSURzXG4gICAgICAgIG1hcE9wdGlvbnMuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzID0gW1xuICAgICAgICAgICAgLi4uKGNvbnRleHQuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzIHx8IFtdKSxcbiAgICAgICAgICAgIC4uLmN1c3RvbUlkc1xuICAgICAgICBdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXBPcHRpb25zKSlcbiAgICAgICAgaWYgKG1hcE9wdGlvbnNba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGVsZXRlIG1hcE9wdGlvbnNba2V5XTtcbiAgICBjb25zdCBzYXZlZE1hcFN0YXRlUmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgLy8gY3JlYXRlIHRoZSBtYXAgaW5zdGFuY2UgYW5kIHJlZ2lzdGVyIGl0IGluIHRoZSBjb250ZXh0XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWFwaUlzTG9hZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSB9ID0gY29udGV4dDtcbiAgICAgICAgLy8gbm90ZTogY29sb3JTY2hlbWUgKHVwY29taW5nIGZlYXR1cmUpIGlzbid0IHlldCBpbiB0aGUgdHlwaW5ncywgcmVtb3ZlIG9uY2UgdGhhdCBpcyBmaXhlZDpcbiAgICAgICAgY29uc3QgeyBtYXBJZCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7bWFwSWQgfHwgJ2RlZmF1bHQnfToke3JlbmRlcmluZ1R5cGUgfHwgJ2RlZmF1bHQnfToke2NvbG9yU2NoZW1lIHx8ICdMSUdIVCd9YDtcbiAgICAgICAgbGV0IG1hcERpdjtcbiAgICAgICAgbGV0IG1hcDtcbiAgICAgICAgaWYgKHJldXNlTWFwcyAmJiBDYWNoZWRNYXBTdGFjay5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICBtYXAgPSBDYWNoZWRNYXBTdGFjay5wb3AoY2FjaGVLZXkpO1xuICAgICAgICAgICAgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcERpdik7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyhtYXBPcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGRldGFjaGluZyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00gbGV0cyB0aGUgbWFwIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdFxuICAgICAgICAgICAgLy8gc2l6ZSwgc2V0dGluZyB0aGUgY2VudGVyIHdpbGwgdHJpZ2dlciByZWxvYWRpbmcgdGhlIG1hcC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbWFwLnNldENlbnRlcihtYXAuZ2V0Q2VudGVyKCkpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWFwRGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtYXBEaXYpO1xuICAgICAgICAgICAgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChtYXBEaXYsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYXBPcHRpb25zKSwgKHJlbmRlcmluZ1R5cGVcbiAgICAgICAgICAgICAgICA/IHsgcmVuZGVyaW5nVHlwZTogcmVuZGVyaW5nVHlwZSB9XG4gICAgICAgICAgICAgICAgOiB7fSkpLCAoY29sb3JTY2hlbWVcbiAgICAgICAgICAgICAgICA/IHsgY29sb3JTY2hlbWU6IGNvbG9yU2NoZW1lIH1cbiAgICAgICAgICAgICAgICA6IHt9KSkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE1hcChtYXApO1xuICAgICAgICBhZGRNYXBJbnN0YW5jZShtYXAsIGlkKTtcbiAgICAgICAgaWYgKGRlZmF1bHRCb3VuZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFkZGluZyB9ID0gZGVmYXVsdEJvdW5kcywgZGVmQm91bmRzID0gX19yZXN0KGRlZmF1bHRCb3VuZHMsIFtcInBhZGRpbmdcIl0pO1xuICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhkZWZCb3VuZHMsIHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgbWFwIG5vdCByZW5kZXJpbmcgZHVlIHRvIG1pc3NpbmcgY29uZmlndXJhdGlvblxuICAgICAgICBlbHNlIGlmICghaGFzWm9vbSB8fCAhaGFzQ2VudGVyKSB7XG4gICAgICAgICAgICBtYXAuZml0Qm91bmRzKHsgZWFzdDogMTgwLCB3ZXN0OiAtMTgwLCBzb3V0aDogLTkwLCBub3J0aDogOTAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHNhdmVkTWFwU3RhdGUgaXMgdXNlZCB0byByZXN0b3JlIHRoZSBjYW1lcmEgcGFyYW1ldGVycyB3aGVuIHRoZSBtYXBJZCBpcyBjaGFuZ2VkXG4gICAgICAgIGlmIChzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWFwSWQ6IHNhdmVkTWFwSWQsIGNhbWVyYVN0YXRlOiBzYXZlZENhbWVyYVN0YXRlIH0gPSBzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoc2F2ZWRNYXBJZCAhPT0gbWFwSWQpIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyhzYXZlZENhbWVyYVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIG1hcElkLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgICAgICAgICBjYW1lcmFTdGF0ZTogY2FtZXJhU3RhdGVSZWYuY3VycmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGRldGFjaCB0aGUgbWFwLWRpdiBmcm9tIHRoZSBkb21cbiAgICAgICAgICAgIG1hcERpdi5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmIChyZXVzZU1hcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGJhY2sgb24gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgQ2FjaGVkTWFwU3RhY2sucHVzaChjYWNoZUtleSwgbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnQtbGlzdGVuZXJzIHRvIG1pbmltaXplIHRoZSBwb3NzaWJpbGl0eSBvZiBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNYXAobnVsbCk7XG4gICAgICAgICAgICByZW1vdmVNYXBJbnN0YW5jZShpZCk7XG4gICAgICAgIH07XG4gICAgfSwgXG4gICAgLy8gc29tZSBkZXBlbmRlbmNpZXMgYXJlIGlnbm9yZWQgaW4gdGhlIGxpc3QgYmVsb3c6XG4gICAgLy8gIC0gZGVmYXVsdEJvdW5kcyBhbmQgdGhlIGRlZmF1bHQqIGNhbWVyYSBwcm9wcyB3aWxsIG9ubHkgYmUgdXNlZCBvbmNlLCBhbmRcbiAgICAvLyAgICBjaGFuZ2VzIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgLy8gIC0gbWFwT3B0aW9ucyBoYXMgc3BlY2lhbCBob29rcyB0aGF0IHRha2UgY2FyZSBvZiB1cGRhdGluZyB0aGUgb3B0aW9uc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYXBpSXNMb2FkZWQsXG4gICAgICAgIGlkLFxuICAgICAgICAvLyB0aGVzZSBwcm9wcyBjYW4ndCBiZSBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIGFuZCByZXF1aXJlIGEgbmV3XG4gICAgICAgIC8vIGluc3RhbmNlIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgcHJvcHMubWFwSWQsXG4gICAgICAgIHByb3BzLnJlbmRlcmluZ1R5cGUsXG4gICAgICAgIHByb3BzLmNvbG9yU2NoZW1lXG4gICAgXSk7XG4gICAgcmV0dXJuIFttYXAsIGNvbnRhaW5lclJlZiwgY2FtZXJhU3RhdGVSZWZdO1xufVxuXG5jb25zdCBHb29nbGVNYXBzQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vLyBDb2xvclNjaGVtZSBhbmQgUmVuZGVyaW5nVHlwZSBhcmUgcmVkZWZpbmVkIGhlcmUgdG8gbWFrZSB0aGVtIHVzYWJsZSBiZWZvcmUgdGhlXG4vLyBtYXBzIEFQSSBoYXMgYmVlbiBmdWxseSBsb2FkZWQuXG5jb25zdCBDb2xvclNjaGVtZSA9IHtcbiAgICBEQVJLOiAnREFSSycsXG4gICAgTElHSFQ6ICdMSUdIVCcsXG4gICAgRk9MTE9XX1NZU1RFTTogJ0ZPTExPV19TWVNURU0nXG59O1xuY29uc3QgUmVuZGVyaW5nVHlwZSA9IHtcbiAgICBWRUNUT1I6ICdWRUNUT1InLFxuICAgIFJBU1RFUjogJ1JBU1RFUicsXG4gICAgVU5JTklUSUFMSVpFRDogJ1VOSU5JVElBTElaRUQnXG59O1xuY29uc3QgTWFwID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaWQsIGNsYXNzTmFtZSwgc3R5bGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gICAgY29uc3QgbG9hZGluZ1N0YXR1cyA9IHVzZUFwaUxvYWRpbmdTdGF0dXMoKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8TWFwPiBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiA8QXBpUHJvdmlkZXI+IGNvbXBvbmVudC4nKTtcbiAgICB9XG4gICAgY29uc3QgW21hcCwgbWFwUmVmLCBjYW1lcmFTdGF0ZVJlZl0gPSB1c2VNYXBJbnN0YW5jZShwcm9wcywgY29udGV4dCk7XG4gICAgdXNlTWFwQ2FtZXJhUGFyYW1zKG1hcCwgY2FtZXJhU3RhdGVSZWYsIHByb3BzKTtcbiAgICB1c2VNYXBFdmVudHMobWFwLCBwcm9wcyk7XG4gICAgdXNlTWFwT3B0aW9ucyhtYXAsIHByb3BzKTtcbiAgICBjb25zdCBpc0RlY2tHbENvbnRyb2xsZWQgPSB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcyk7XG4gICAgY29uc3QgaXNDb250cm9sbGVkRXh0ZXJuYWxseSA9ICEhcHJvcHMuY29udHJvbGxlZDtcbiAgICAvLyBkaXNhYmxlIGludGVyYWN0aW9ucyB3aXRoIHRoZSBtYXAgZm9yIGV4dGVybmFsbHkgY29udHJvbGxlZCBtYXBzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGZpeG1lOiB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZWxvbmcgaGVyZSAoYW5kIGl0J3MgbW9zdGx5IHRoZXJlIGZvciBjb252ZW5pZW5jZSBhbnl3YXkpLlxuICAgICAgICAvLyAgIFRoZSByZWFzb25pbmcgaXMgdGhhdCBhIGRlY2suZ2wgY2FudmFzIHdpbGwgYmUgcHV0IG9uIHRvcCBvZiB0aGUgbWFwLCByZW5kZXJpbmdcbiAgICAgICAgLy8gICBhbnkgZGVmYXVsdCBtYXAgY29udHJvbHMgcHJldHR5IG11Y2ggdXNlbGVzc1xuICAgICAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkKSB7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyh7IGRpc2FibGVEZWZhdWx0VUk6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzYWJsZSBhbGwgY29udHJvbC1pbnB1dHMgd2hlbiB0aGUgbWFwIGlzIGNvbnRyb2xsZWQgZXh0ZXJuYWxseVxuICAgICAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkIHx8IGlzQ29udHJvbGxlZEV4dGVybmFsbHkpIHtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlSGFuZGxpbmc6ICdub25lJyxcbiAgICAgICAgICAgICAgICBrZXlib2FyZFNob3J0Y3V0czogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZUhhbmRsaW5nOiBwcm9wcy5nZXN0dXJlSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG1hcCxcbiAgICAgICAgaXNEZWNrR2xDb250cm9sbGVkLFxuICAgICAgICBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5LFxuICAgICAgICBwcm9wcy5nZXN0dXJlSGFuZGxpbmcsXG4gICAgICAgIHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXG4gICAgXSk7XG4gICAgLy8gc2V0dXAgYSBzdGFibGUgY2FtZXJhT3B0aW9ucyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBkZXBlbmRlbmN5XG4gICAgY29uc3QgY2VudGVyID0gcHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKHByb3BzLmNlbnRlcikgOiBudWxsO1xuICAgIGxldCBsYXQgPSBudWxsO1xuICAgIGxldCBsbmcgPSBudWxsO1xuICAgIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgICAgICBsYXQgPSBjZW50ZXIubGF0O1xuICAgICAgICBsbmcgPSBjZW50ZXIubG5nO1xuICAgIH1cbiAgICBjb25zdCBjYW1lcmFPcHRpb25zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogbGF0ICE9PSBudWxsICYmIGxhdCAhPT0gdm9pZCAwID8gbGF0IDogMCwgbG5nOiBsbmcgIT09IG51bGwgJiYgbG5nICE9PSB2b2lkIDAgPyBsbmcgOiAwIH0sXG4gICAgICAgICAgICB6b29tOiAoX2EgPSBwcm9wcy56b29tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgICAgICAgaGVhZGluZzogKF9iID0gcHJvcHMuaGVhZGluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCxcbiAgICAgICAgICAgIHRpbHQ6IChfYyA9IHByb3BzLnRpbHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDBcbiAgICAgICAgfTtcbiAgICB9LCBbbGF0LCBsbmcsIHByb3BzLnpvb20sIHByb3BzLmhlYWRpbmcsIHByb3BzLnRpbHRdKTtcbiAgICAvLyBleHRlcm5hbGx5IGNvbnRyb2xsZWQgbW9kZTogcmVqZWN0IGFsbCBjYW1lcmEgY2hhbmdlcyB0aGF0IGRvbid0IGNvcnJlc3BvbmQgdG8gY2hhbmdlcyBpbiBwcm9wc1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwIHx8ICFpc0NvbnRyb2xsZWRFeHRlcm5hbGx5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYXAubW92ZUNhbWVyYShjYW1lcmFPcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBtYXAuYWRkTGlzdGVuZXIoJ2JvdW5kc19jaGFuZ2VkJywgKCkgPT4ge1xuICAgICAgICAgICAgbWFwLm1vdmVDYW1lcmEoY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW21hcCwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSwgY2FtZXJhT3B0aW9uc10pO1xuICAgIGNvbnN0IGNvbWJpbmVkU3R5bGUgPSB1c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBcbiAgICAgICAgLy8gd2hlbiB1c2luZyBkZWNrZ2wsIHRoZSBtYXAgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIGJhY2tcbiAgICAgICAgekluZGV4OiBpc0RlY2tHbENvbnRyb2xsZWQgPyAtMSA6IDAgfSwgc3R5bGUpKSwgW3N0eWxlLCBpc0RlY2tHbENvbnRyb2xsZWRdKTtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7IG1hcCB9KSwgW21hcF0pO1xuICAgIGlmIChsb2FkaW5nU3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRSkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uOiAncmVsYXRpdmUnIH0sIChjbGFzc05hbWUgPyB7fSA6IGNvbWJpbmVkU3R5bGUpKSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0aEZhaWx1cmVNZXNzYWdlLCBudWxsKSkpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogbWFwUmVmLCBcImRhdGEtdGVzdGlkXCI6ICdtYXAnLCBzdHlsZTogY2xhc3NOYW1lID8gdW5kZWZpbmVkIDogY29tYmluZWRTdHlsZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgKGlkID8geyBpZCB9IDoge30pKSwgbWFwID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoR29vZ2xlTWFwc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCBjaGlsZHJlbikpIDogbnVsbCkpO1xufTtcbi8vIFRoZSBkZWNrR0xWaWV3UHJvcHMgZmxhZyBoZXJlIGluZGljYXRlcyB0byBkZWNrLmdsIHRoYXQgdGhlIE1hcCBjb21wb25lbnQgaXNcbi8vIGFibGUgdG8gaGFuZGxlIHZpZXdQcm9wcyBmcm9tIGRlY2suZ2wgd2hlbiBkZWNrLmdsIGlzIHVzZWQgdG8gY29udHJvbCB0aGUgbWFwLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbk1hcC5kZWNrR0xWaWV3UHJvcHMgPSB0cnVlO1xuXG5jb25zdCBzaG93bk1lc3NhZ2VzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gbG9nRXJyb3JPbmNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICBpZiAoIXNob3duTWVzc2FnZXMuaGFzKGtleSkpIHtcbiAgICAgICAgc2hvd25NZXNzYWdlcy5hZGQoa2V5KTtcbiAgICAgICAgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0cmlldmVzIGEgbWFwLWluc3RhbmNlIGZyb20gdGhlIGNvbnRleHQuIFRoaXMgaXMgZWl0aGVyIGFuIGluc3RhbmNlXG4gKiBpZGVudGlmaWVkIGJ5IGlkIG9yIHRoZSBwYXJlbnQgbWFwIGluc3RhbmNlIGlmIG5vIGlkIGlzIHNwZWNpZmllZC5cbiAqIFJldHVybnMgbnVsbCBpZiBuZWl0aGVyIGNhbiBiZSBmb3VuZC5cbiAqL1xuY29uc3QgdXNlTWFwID0gKGlkID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgICBjb25zdCB7IG1hcCB9ID0gdXNlQ29udGV4dChHb29nbGVNYXBzQ29udGV4dCkgfHwge307XG4gICAgaWYgKGN0eCA9PT0gbnVsbCkge1xuICAgICAgICBsb2dFcnJvck9uY2UoJ3VzZU1hcCgpOiBmYWlsZWQgdG8gcmV0cmlldmUgQVBJUHJvdmlkZXJDb250ZXh0LiAnICtcbiAgICAgICAgICAgICdNYWtlIHN1cmUgdGhhdCB0aGUgPEFQSVByb3ZpZGVyPiBjb21wb25lbnQgZXhpc3RzIGFuZCB0aGF0IHRoZSAnICtcbiAgICAgICAgICAgICdjb21wb25lbnQgeW91IGFyZSBjYWxsaW5nIGB1c2VNYXAoKWAgZnJvbSBpcyBhIHNpYmxpbmcgb2YgdGhlICcgK1xuICAgICAgICAgICAgJzxBUElQcm92aWRlcj4uJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IG1hcEluc3RhbmNlcyB9ID0gY3R4O1xuICAgIC8vIGlmIGFuIGlkIGlzIHNwZWNpZmllZCwgdGhlIGNvcnJlc3BvbmRpbmcgbWFwIG9yIG51bGwgaXMgcmV0dXJuZWRcbiAgICBpZiAoaWQgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBtYXBJbnN0YW5jZXNbaWRdIHx8IG51bGw7XG4gICAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIGNsb3Nlc3QgYW5jZXN0b3JcbiAgICBpZiAobWFwKVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIC8vIGZpbmFsbHksIHJldHVybiB0aGUgZGVmYXVsdCBtYXAgaW5zdGFuY2VcbiAgICByZXR1cm4gbWFwSW5zdGFuY2VzWydkZWZhdWx0J10gfHwgbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHVzZU1hcHNMaWJyYXJ5KG5hbWUpIHtcbiAgICBjb25zdCBhcGlJc0xvYWRlZCA9IHVzZUFwaUlzTG9hZGVkKCk7XG4gICAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghYXBpSXNMb2FkZWQgfHwgIWN0eClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVHJpZ2dlciBsb2FkaW5nIHRoZSBsaWJyYXJpZXMgdmlhIG91ciBwcm94eS1tZXRob2QuXG4gICAgICAgIC8vIFRoZSByZXR1cm5lZCBwcm9taXNlIGlzIGlnbm9yZWQsIHNpbmNlIGltcG9ydExpYnJhcnkgd2lsbCB1cGRhdGUgbG9hZGVkTGlicmFyaWVzXG4gICAgICAgIC8vIGxpc3QgaW4gdGhlIGNvbnRleHQsIHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICAgIHZvaWQgY3R4LmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgfSwgW2FwaUlzTG9hZGVkLCBjdHgsIG5hbWVdKTtcbiAgICByZXR1cm4gKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5sb2FkZWRMaWJyYXJpZXNbbmFtZV0pIHx8IG51bGw7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogSW50ZXJuYWxseSB1c2VkIHRvIGJpbmQgZXZlbnRzIHRvIE1hcHMgSmF2YVNjcmlwdCBBUEkgb2JqZWN0cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBzRXZlbnRMaXN0ZW5lcih0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIW5hbWUgfHwgIWNhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW3RhcmdldCwgbmFtZSwgY2FsbGJhY2tdKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gY29weSB2YWx1ZXMgZnJvbSBwcm9wcyBpbnRvIEFQSS1PYmplY3RzXG4gKiB3aGVuZXZlciB0aGV5IGNoYW5nZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICB1c2VQcm9wQmluZGluZyhtYXJrZXIsICdwb3NpdGlvbicsIHBvc2l0aW9uKTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlUHJvcEJpbmRpbmcob2JqZWN0LCBwcm9wLCB2YWx1ZSkge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvaW1tdXRhYmlsaXR5XG4gICAgICAgIG9iamVjdFtwcm9wXSA9IHZhbHVlO1xuICAgIH0sIFtvYmplY3QsIHByb3AsIHZhbHVlXSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogSW50ZXJuYWxseSB1c2VkIHRvIGJpbmQgZXZlbnRzIHRvIERPTSBub2Rlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEb21FdmVudExpc3RlbmVyKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhbmFtZSB8fCAhY2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LCBbdGFyZ2V0LCBuYW1lLCBjYWxsYmFja10pO1xufVxuXG4vLyBHbG9iYWwgc3R5bGUgbWFuYWdlciB0byB0cmFjayByZW5kZXJlZCBzdHlsZXMgYW5kIGF2b2lkIGR1cGxpY2F0ZXNcbmNsYXNzIEdsb2JhbFN0eWxlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRTdHlsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0U3R5bGVFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmdtLWFuY2hvci1zdHlsZXMnLCAnJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZUVsZW1lbnQ7XG4gICAgfVxuICAgIGFkZEFkdmFuY2VkTWFya2VyUG9pbnRlckV2ZW50c092ZXJ3cml0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRTdHlsZXMuaGFzKCdtYXJrZXItcG9pbnRlci1ldmVudHMnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IHRoaXMuZ2V0U3R5bGVFbGVtZW50KCk7XG4gICAgICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCArPSBgXG4gICAgICBnbXAtYWR2YW5jZWQtbWFya2VyW2RhdGEtb3JpZ2luPSdyZ20nXSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgYDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcy5hZGQoJ21hcmtlci1wb2ludGVyLWV2ZW50cycpO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZ2xvYmFsU3R5bGVNYW5hZ2VyID0gbmV3IEdsb2JhbFN0eWxlTWFuYWdlcigpO1xuXG5mdW5jdGlvbiBpc1ZlcnNpb25HcmVhdGVyRXF1YWwobWFqb3IsIG1pbm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghKChfYSA9IGdvb2dsZSA9PT0gbnVsbCB8fCBnb29nbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdvb2dsZS5tYXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmVyc2lvbikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdmVyc2lvbiA9IGdvb2dsZS5tYXBzLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICBjb25zdCBjdXJyZW50TWFqb3IgPSBwYXJzZUludCh2ZXJzaW9uWzBdLCAxMCk7XG4gICAgY29uc3QgY3VycmVudE1pbm9yID0gcGFyc2VJbnQodmVyc2lvblsxXSwgMTApO1xuICAgIHJldHVybiAoY3VycmVudE1ham9yID4gbWFqb3IgfHwgKGN1cnJlbnRNYWpvciA9PT0gbWFqb3IgJiYgY3VycmVudE1pbm9yID49IG1pbm9yKSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2ltbXV0YWJpbGl0eSAqL1xuLy8gVGhlIGByZWFjdC1ob29rcy9pbW11dGFiaWxpdHlgIHJ1bGUgaXMgZGlzYWJsZWQgaW4gdGhpcyBmaWxlIGJlY2F1c2UgdGhlXG4vLyBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50IG9iamVjdCBpcyBkZXNpZ25lZCB0byBiZSBtdXRhdGVkXG4vLyBkaXJlY3RseS4gVGhpcyBpcyBhIGNvbW1vbiBwYXR0ZXJuIHdoZW4gd29ya2luZyB3aXRoIGltcGVyYXRpdmUgQVBJcyBsaWtlXG4vLyB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkuIFdoaWxlIHRoaXMgZ29lcyBhZ2FpbnN0IHRoZSBwcmluY2lwbGVzIG9mXG4vLyBpbW11dGFibGUgc3RhdGUgaW4gUmVhY3QsIGl0IGlzIGEgbmVjZXNzYXJ5IGV2aWwgdG8gaW50ZWdyYXRlIHdpdGggdGhlXG4vLyBHb29nbGUgTWFwcyBBUEkuIFRoZSBtdXRhdGlvbnMgYXJlIGNhcmVmdWxseSBtYW5hZ2VkIHdpdGhpbiB0aGUgYHVzZUVmZmVjdGBcbi8vIGhvb2tzIHRvIGVuc3VyZSB0aGF0IHRoZXkgb25seSBoYXBwZW4gd2hlbiB0aGUgcHJvcHMgY2hhbmdlLlxuLyoqXG4gKiBDb3B5IG9mIHRoZSBgZ29vZ2xlLm1hcHMuQ29sbGlzaW9uQmVoYXZpb3JgIGNvbnN0YW50cy5cbiAqIFRoZXkgaGF2ZSB0byBiZSBkdXBsaWNhdGVkIGhlcmUgc2luY2Ugd2UgY2FuJ3Qgd2FpdCBmb3IgdGhlIG1hcHMgQVBJIHRvIGxvYWQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbS5cbiAqL1xuY29uc3QgQ29sbGlzaW9uQmVoYXZpb3IgPSB7XG4gICAgUkVRVUlSRUQ6ICdSRVFVSVJFRCcsXG4gICAgUkVRVUlSRURfQU5EX0hJREVTX09QVElPTkFMOiAnUkVRVUlSRURfQU5EX0hJREVTX09QVElPTkFMJyxcbiAgICBPUFRJT05BTF9BTkRfSElERVNfTE9XRVJfUFJJT1JJVFk6ICdPUFRJT05BTF9BTkRfSElERVNfTE9XRVJfUFJJT1JJVFknXG59O1xuY29uc3QgQWR2YW5jZWRNYXJrZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8vIFt4UG9zaXRpb24sIHlQb3NpdGlvbl0gd2hlbiB0aGUgdG9wIGxlZnQgY29ybmVyIGlzIFswLCAwXVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2luZyBgYW5jaG9yUG9zaXRpb25gIGlzIGRlcHJlY2F0ZWQuXG4gKiAgIFVzZSBgYW5jaG9yTGVmdGAgYW5kIGBhbmNob3JUb3BgIGluc3RlYWQuXG4gKi9cbmNvbnN0IEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnQgPSB7XG4gICAgVE9QX0xFRlQ6IFsnMCUnLCAnMCUnXSxcbiAgICBUT1BfQ0VOVEVSOiBbJzUwJScsICcwJSddLFxuICAgIFRPUDogWyc1MCUnLCAnMCUnXSxcbiAgICBUT1BfUklHSFQ6IFsnMTAwJScsICcwJSddLFxuICAgIExFRlRfQ0VOVEVSOiBbJzAlJywgJzUwJSddLFxuICAgIExFRlRfVE9QOiBbJzAlJywgJzAlJ10sXG4gICAgTEVGVDogWycwJScsICc1MCUnXSxcbiAgICBMRUZUX0JPVFRPTTogWycwJScsICcxMDAlJ10sXG4gICAgUklHSFRfVE9QOiBbJzEwMCUnLCAnMCUnXSxcbiAgICBSSUdIVDogWycxMDAlJywgJzUwJSddLFxuICAgIFJJR0hUX0NFTlRFUjogWycxMDAlJywgJzUwJSddLFxuICAgIFJJR0hUX0JPVFRPTTogWycxMDAlJywgJzEwMCUnXSxcbiAgICBCT1RUT01fTEVGVDogWycwJScsICcxMDAlJ10sXG4gICAgQk9UVE9NX0NFTlRFUjogWyc1MCUnLCAnMTAwJSddLFxuICAgIEJPVFRPTTogWyc1MCUnLCAnMTAwJSddLFxuICAgIEJPVFRPTV9SSUdIVDogWycxMDAlJywgJzEwMCUnXSxcbiAgICBDRU5URVI6IFsnNTAlJywgJzUwJSddXG59O1xuY29uc3QgQWR2YW5jZWRNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgc3R5bGUsIGNsYXNzTmFtZSwgYW5jaG9yUG9pbnQgfSA9IHByb3BzO1xuICAgIGNvbnN0IFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdID0gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpO1xuICAgIGNvbnN0IGFkdmFuY2VkTWFya2VyQ29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAobWFya2VyID8geyBtYXJrZXIgfSA6IG51bGwpLCBbbWFya2VyXSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IG1hcmtlciwgW21hcmtlcl0pO1xuICAgIGlmICghY29udGVudENvbnRhaW5lcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEFkdmFuY2VkTWFya2VyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogYWR2YW5jZWRNYXJrZXJDb250ZXh0VmFsdWUgfSwgY3JlYXRlUG9ydGFsKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2VyQ29udGVudCwgeyBhbmNob3JQb2ludDogYW5jaG9yUG9pbnQsIHN0eWxlczogc3R5bGUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSwgY29udGVudENvbnRhaW5lcikpKTtcbn0pO1xuQWR2YW5jZWRNYXJrZXIuZGlzcGxheU5hbWUgPSAnQWR2YW5jZWRNYXJrZXInO1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXJSZWYoKSB7XG4gICAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKG0pID0+IHtcbiAgICAgICAgc2V0TWFya2VyKG0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gW3JlZkNhbGxiYWNrLCBtYXJrZXJdO1xufVxuZnVuY3Rpb24gaXNBZHZhbmNlZE1hcmtlcihtYXJrZXIpIHtcbiAgICByZXR1cm4gKG1hcmtlci5jb250ZW50ICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuY29uc3QgTWFya2VyQ29udGVudCA9ICh7IGNoaWxkcmVuLCBzdHlsZXMsIGNsYXNzTmFtZSB9KSA9PiB7XG4gICAgLyogQWR2YW5jZWRNYXJrZXIgZGl2IHRoYXQgdXNlciBjYW4gZ2l2ZSBzdHlsZXMgYW5kIGNsYXNzZXMgKi9cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlcyB9LCBjaGlsZHJlbikpO1xufTtcbmZ1bmN0aW9uIHVzZUFkdmFuY2VkTWFya2VyKHByb3BzKSB7XG4gICAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtjb250ZW50Q29udGFpbmVyLCBzZXRDb250ZW50Q29udGFpbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICAgIGNvbnN0IG1hcmtlckxpYnJhcnkgPSB1c2VNYXBzTGlicmFyeSgnbWFya2VyJyk7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgb25DbGljaywgY2xhc3NOYW1lLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgb25EcmFnLCBvbkRyYWdTdGFydCwgb25EcmFnRW5kLCBjb2xsaXNpb25CZWhhdmlvciwgY2xpY2thYmxlLCBkcmFnZ2FibGUsIHBvc2l0aW9uLCB0aXRsZSwgekluZGV4LCBhbmNob3JQb2ludCwgYW5jaG9yTGVmdCwgYW5jaG9yVG9wIH0gPSBwcm9wcztcbiAgICBjb25zdCBudW1DaGlsZHJlbiA9IENoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgICAvLyBjcmVhdGUgYW4gQWR2YW5jZWRNYXJrZXJFbGVtZW50IGluc3RhbmNlIGFuZCBhZGQgaXQgdG8gdGhlIG1hcCBvbmNlIGF2YWlsYWJsZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwIHx8ICFtYXJrZXJMaWJyYXJ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgbWFya2VyTGlicmFyeS5BZHZhbmNlZE1hcmtlckVsZW1lbnQoKTtcbiAgICAgICAgbmV3TWFya2VyLm1hcCA9IG1hcDtcbiAgICAgICAgc2V0TWFya2VyKG5ld01hcmtlcik7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgY29udGFpbmVyIGZvciBtYXJrZXIgY29udGVudCBpZiB0aGVyZSBhcmUgY2hpbGRyZW5cbiAgICAgICAgbGV0IGNvbnRlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKG51bUNoaWxkcmVuID4gMCkge1xuICAgICAgICAgICAgY29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5ld01hcmtlci5jb250ZW50ID0gY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICBzZXRDb250ZW50Q29udGFpbmVyKGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbmV3TWFya2VyLm1hcCA9IG51bGw7XG4gICAgICAgICAgICBjb250ZW50RWxlbWVudCA9PT0gbnVsbCB8fCBjb250ZW50RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICBzZXRNYXJrZXIobnVsbCk7XG4gICAgICAgICAgICBzZXRDb250ZW50Q29udGFpbmVyKG51bGwpO1xuICAgICAgICB9O1xuICAgIH0sIFttYXAsIG1hcmtlckxpYnJhcnksIG51bUNoaWxkcmVuXSk7XG4gICAgLy8gV2hlbiBubyBjaGlsZHJlbiBhcmUgcHJlc2VudCB3ZSBkb24ndCBoYXZlIG91ciBvd24gd3JhcHBlciBkaXZcbiAgICAvLyB3aGljaCB1c3VhbGx5IGdldHMgdGhlIHVzZXIgcHJvdmlkZWQgY2xhc3NOYW1lLiBJbiB0aGlzIGNhc2VcbiAgICAvLyB3ZSBzZXQgdGhlIGNsYXNzTmFtZSBkaXJlY3RseSBvbiB0aGUgbWFya2VyLmNvbnRlbnQgZWxlbWVudCB0aGF0IGNvbWVzXG4gICAgLy8gd2l0aCB0aGUgQWR2YW5jZWRNYXJrZXIuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCEobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmNvbnRlbnQpIHx8ICFpc0VsZW1lbnROb2RlKG1hcmtlci5jb250ZW50KSB8fCBudW1DaGlsZHJlbiA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hcmtlci5jb250ZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSAhPT0gbnVsbCAmJiBjbGFzc05hbWUgIT09IHZvaWQgMCA/IGNsYXNzTmFtZSA6ICcnO1xuICAgIH0sIFttYXJrZXIsIGNsYXNzTmFtZSwgbnVtQ2hpbGRyZW5dKTtcbiAgICB1c2VBZHZhbmNlZE1hcmtlckFuY2hvcmluZyhtYXJrZXIsIGFuY2hvclBvaW50LCBhbmNob3JMZWZ0LCBhbmNob3JUb3AsIG51bUNoaWxkcmVuID4gMCk7XG4gICAgLy8gY29weSBvdGhlciBwcm9wc1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3RpdGxlJywgdGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09IHZvaWQgMCA/IHRpdGxlIDogJycpO1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3pJbmRleCcsIHpJbmRleCk7XG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAnY29sbGlzaW9uQmVoYXZpb3InLCBjb2xsaXNpb25CZWhhdmlvcik7XG4gICAgLy8gc2V0IGdtcERyYWdnYWJsZSBmcm9tIHByb3BzICh3aGVuIHVuc3BlY2lmaWVkLCBpdCdzIHRydWUgaWYgYW55IGRyYWctZXZlbnRcbiAgICAvLyBjYWxsYmFja3MgYXJlIHNwZWNpZmllZClcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGRyYWdnYWJsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbWFya2VyLmdtcERyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICAgICAgZWxzZSBpZiAob25EcmFnIHx8IG9uRHJhZ1N0YXJ0IHx8IG9uRHJhZ0VuZClcbiAgICAgICAgICAgIG1hcmtlci5nbXBEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXJrZXIuZ21wRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgfSwgW21hcmtlciwgZHJhZ2dhYmxlLCBvbkRyYWcsIG9uRHJhZ0VuZCwgb25EcmFnU3RhcnRdKTtcbiAgICAvLyBzZXQgZ21wQ2xpY2thYmxlIGZyb20gcHJvcHMgKHdoZW4gdW5zcGVjaWZpZWQsIGl0J3MgdHJ1ZSBpZiB0aGUgb25DbGljayBvciBvbmUgb2ZcbiAgICAvLyB0aGUgaG92ZXIgZXZlbnRzIGNhbGxiYWNrcyBhcmUgc3BlY2lmaWVkKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBnbXBDbGlja2FibGUgPSBjbGlja2FibGUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgQm9vbGVhbihvbkNsaWNrKSB8fFxuICAgICAgICAgICAgQm9vbGVhbihvbk1vdXNlRW50ZXIpIHx8XG4gICAgICAgICAgICBCb29sZWFuKG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIC8vIGdtcENsaWNrYWJsZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBiZXRhIHZlcnNpb24gb2YgdGhlXG4gICAgICAgIC8vIG1hcHMgYXBpIChhcyBvZiAyMDI0LTEwLTEwKVxuICAgICAgICBtYXJrZXIuZ21wQ2xpY2thYmxlID0gZ21wQ2xpY2thYmxlO1xuICAgICAgICAvLyBlbmFibGUgcG9pbnRlciBldmVudHMgZm9yIHRoZSBtYXJrZXJzIHdpdGggY3VzdG9tIGNvbnRlbnRcbiAgICAgICAgaWYgKGdtcENsaWNrYWJsZSAmJiAobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmNvbnRlbnQpICYmIGlzRWxlbWVudE5vZGUobWFya2VyLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBtYXJrZXIuY29udGVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFttYXJrZXIsIGNsaWNrYWJsZSwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmVdKTtcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2RyYWcnLCBvbkRyYWcpO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KTtcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICB1c2VEb21FdmVudExpc3RlbmVyKG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5lbGVtZW50LCAnbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgdXNlRG9tRXZlbnRMaXN0ZW5lcihtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuZWxlbWVudCwgJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgIHJldHVybiBbbWFya2VyLCBjb250ZW50Q29udGFpbmVyXTtcbn1cbmZ1bmN0aW9uIHVzZUFkdmFuY2VkTWFya2VyQW5jaG9yaW5nKG1hcmtlciwgYW5jaG9yUG9pbnQsIGFuY2hvckxlZnQsIGFuY2hvclRvcCwgaGFzQ2hpbGRyZW4pIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcmtlciB8fCAhaGFzQ2hpbGRyZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRoZSBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3Agb3B0aW9ucyBhcmUgYXZhaWxhYmxlIHNpbmNlIHZlcnNpb24gMy42Mi45Y1xuICAgICAgICAvLyBXaXRoIHRoZSByZWxlYXNlIG9mIDMuNjUgKH5NYXkgMjAyNikgdGhlcmUgd2lsbCBubyBsb25nZXIgYmUgYSB2ZXJzaW9uXG4gICAgICAgIC8vIHRoYXQgZG9lc24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBjb25zdCBhbmNob3JPcHRpb25zU3VwcG9ydGVkID0gaXNWZXJzaW9uR3JlYXRlckVxdWFsKDMsIDYyKTtcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBtYXJrZXIuY29udGVudDtcbiAgICAgICAgaWYgKCFjb250ZW50RWxlbWVudCB8fCAhaXNFbGVtZW50Tm9kZShjb250ZW50RWxlbWVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhbmNob3JMZWZ0ICE9PSB1bmRlZmluZWQgfHwgYW5jaG9yVG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghYW5jaG9yT3B0aW9uc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQWR2YW5jZWRNYXJrZXI6IFRoZSBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3AgcHJvcHMgYXJlIG9ubHkgc3VwcG9ydGVkICcgK1xuICAgICAgICAgICAgICAgICAgICAnaW4gR29vZ2xlIE1hcHMgQVBJIHZlcnNpb24gMy42MiBhbmQgYWJvdmUuICcgK1xuICAgICAgICAgICAgICAgICAgICBgVGhlIGN1cnJlbnQgdmVyc2lvbiBpcyAke2dvb2dsZS5tYXBzLnZlcnNpb259LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya2VyLmFuY2hvckxlZnQgPSBhbmNob3JMZWZ0O1xuICAgICAgICAgICAgbWFya2VyLmFuY2hvclRvcCA9IGFuY2hvclRvcDtcbiAgICAgICAgICAgIC8vIHdoZW4gYW5jaG9yTGVmdCBhbmQvb3IgYW5jaG9yVG9wIGFyZSBzZXQsIHdlJ2xsIGlnbm9yZSB0aGUgYW5jaG9yUG9pbnRcbiAgICAgICAgICAgIGlmIChhbmNob3JQb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBZHZhbmNlZE1hcmtlcjogdGhlIGFuY2hvclBvaW50IHByb3AgaXMgaWdub3JlZCB3aGVuIGFuY2hvckxlZnQgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbmQvb3IgYW5jaG9yVG9wIGFyZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvclBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZCBjb25zb2xlLndhcm4gaW4gYSBmdXR1cmUgdmVyc2lvbiB0byBpbmZvcm0gYWJvdXQgZGVwcmVjYXRpb25cbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGFuY2hvclBvaW50ICE9PSBudWxsICYmIGFuY2hvclBvaW50ICE9PSB2b2lkIDAgPyBhbmNob3JQb2ludCA6IEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnRbJ0JPVFRPTSddO1xuICAgICAgICAgICAgLy8gTk9URTogc2luY2UgeCBhbmQgeSBjYW4gYmUgYW55IHZhbGlkIENTUyBsZW5ndGgtcGVyY2VudGFnZVxuICAgICAgICAgICAgLy8gICB2YWx1ZSwgd2UgbmVlZCB0byB1c2UgY2FsYygpIHRvIG5lZ2F0ZSB0aGVtLlxuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWCA9IGBjYWxjKC0xICogJHt4fSlgO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IGBjYWxjKC0xICogJHt5fSlgO1xuICAgICAgICAgICAgaWYgKGFuY2hvck9wdGlvbnNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnQgYW5jaG9yUG9pbnQgdXNpbmcgdGhlIG5ldyBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3Agb3B0aW9uc1xuICAgICAgICAgICAgICAgIG1hcmtlci5hbmNob3JMZWZ0ID0gdHJhbnNsYXRlWDtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYW5jaG9yVG9wID0gdHJhbnNsYXRlWTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0cmFuc2Zvcm0gZnJvbSBsZWdhY3kgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcInRyYW5zbGF0ZSg1MCUsIDEwMCUpXCIgY291bnRlcnMgYW5kIHJlc2V0cyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIGFuY2hvcmluZyBvZiB0aGUgYWR2YW5jZWQgbWFya2VyIGVsZW1lbnQgZnJvbSB0aGUgYXBpXG4gICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSg1MCUsIDEwMCUpIHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVh9LCAke3RyYW5zbGF0ZVl9KWA7XG4gICAgICAgICAgICAgICAgLy8gZGF0YS1vcmlnaW4gaXMgbmVlZGVkIHRvIGlkZW50aWZ5IHRoZSBjdXN0b20gbWFya2VyIGNvbnRlbnQgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gSW5mb1dpbmRvdyBjb21wb25lbnQgYXMgd2VsbCBhcyBpbiB0aGUgZ2xvYmFsIENTUyB1c2VkIHRvIGRpc2FibGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgcG9pbnRlciBldmVudCB3aGVuIGFuY2hvciBwb2ludHMgYXJlIHVzZWQgaW4gb2xkZXIgR29vZ2xlIE1hcHNcbiAgICAgICAgICAgICAgICAvLyB2ZXJzaW9ucy5cbiAgICAgICAgICAgICAgICBtYXJrZXIuZGF0YXNldC5vcmlnaW4gPSAncmdtJztcbiAgICAgICAgICAgICAgICBnbG9iYWxTdHlsZU1hbmFnZXIuYWRkQWR2YW5jZWRNYXJrZXJQb2ludGVyRXZlbnRzT3ZlcndyaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbWFya2VyLCBhbmNob3JQb2ludCwgYW5jaG9yTGVmdCwgYW5jaG9yVG9wLCBoYXNDaGlsZHJlbl0pO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhlbGVtZW50LCBzdHlsZXMsIHByZXZTdHlsZXMpIHtcbiAgICBpZiAoc3R5bGVzICE9IG51bGwgJiYgdHlwZW9mIHN0eWxlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgK1xuICAgICAgICAgICAgXCJub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gXCIgK1xuICAgICAgICAgICAgJ3VzaW5nIEpTWC4nKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAvLyB3aXRob3V0IGBwcmV2U3R5bGVzYCwganVzdCBzZXQgYWxsIHZhbHVlc1xuICAgIGlmIChwcmV2U3R5bGVzID09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0eWxlcyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB1bnNldCBhbGwgc3R5bGVzIGluIGBwcmV2U3R5bGVzYCB0aGF0IGFyZW4ndCBpbiBgc3R5bGVzYFxuICAgIGZvciAoY29uc3Qgc3R5bGVOYW1lIGluIHByZXZTdHlsZXMpIHtcbiAgICAgICAgaWYgKHByZXZTdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJlxuICAgICAgICAgICAgKHN0eWxlcyA9PSBudWxsIHx8ICFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHN0eWxlXG4gICAgICAgICAgICBjb25zdCBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5jc3NGbG9hdCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmx5IGFzc2lnbiB2YWx1ZXMgZnJvbSBgc3R5bGVzYCB0aGF0IGFyZSBkaWZmZXJlbnQgZnJvbSBgcHJldlN0eWxlc2BcbiAgICBpZiAoc3R5bGVzID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICBwcmV2U3R5bGVzW3N0eWxlTmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAvLyBmYWxzeSB2YWx1ZXMgd2lsbCB1bnNldCB0aGUgc3R5bGUgcHJvcGVydHlcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5jc3NGbG9hdCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjdXN0b20gcHJvcGVydGllcyBjYW4ndCBiZSBkaXJlY3RseSBhc3NpZ25lZFxuICAgIGVsc2UgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBudW1lcmljIHZhbHVlcyBhcmUgdHJlYXRlZCBhcyAncHgnIHVubGVzcyB0aGUgc3R5bGUgcHJvcGVydHkgZXhwZWN0cyB1bml0bGVzcyBudW1iZXJzXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSAhPT0gMCAmJlxuICAgICAgICAhaXNVbml0bGVzc051bWJlcihzdHlsZU5hbWUpKSB7XG4gICAgICAgIGVsZW1lbnRTdHlsZVtzdHlsZU5hbWVdID0gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICAgIH1cbiAgICAvLyBldmVyeXRoaW5nIGVsc2UgY2FuIGp1c3QgYmUgYXNzaWduZWRcbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGVbc3R5bGVOYW1lXSA9ICgnJyArIHZhbHVlKS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG5jb25zdCB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFtcbiAgICAnYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLFxuICAgICdhc3BlY3RSYXRpbycsXG4gICAgJ2JvcmRlckltYWdlT3V0c2V0JyxcbiAgICAnYm9yZGVySW1hZ2VTbGljZScsXG4gICAgJ2JvcmRlckltYWdlV2lkdGgnLFxuICAgICdib3hGbGV4JyxcbiAgICAnYm94RmxleEdyb3VwJyxcbiAgICAnYm94T3JkaW5hbEdyb3VwJyxcbiAgICAnY29sdW1uQ291bnQnLFxuICAgICdjb2x1bW5zJyxcbiAgICAnZmxleCcsXG4gICAgJ2ZsZXhHcm93JyxcbiAgICAnZmxleFBvc2l0aXZlJyxcbiAgICAnZmxleFNocmluaycsXG4gICAgJ2ZsZXhOZWdhdGl2ZScsXG4gICAgJ2ZsZXhPcmRlcicsXG4gICAgJ2dyaWRBcmVhJyxcbiAgICAnZ3JpZFJvdycsXG4gICAgJ2dyaWRSb3dFbmQnLFxuICAgICdncmlkUm93U3BhbicsXG4gICAgJ2dyaWRSb3dTdGFydCcsXG4gICAgJ2dyaWRDb2x1bW4nLFxuICAgICdncmlkQ29sdW1uRW5kJyxcbiAgICAnZ3JpZENvbHVtblNwYW4nLFxuICAgICdncmlkQ29sdW1uU3RhcnQnLFxuICAgICdmb250V2VpZ2h0JyxcbiAgICAnbGluZUNsYW1wJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ29wYWNpdHknLFxuICAgICdvcmRlcicsXG4gICAgJ29ycGhhbnMnLFxuICAgICdzY2FsZScsXG4gICAgJ3RhYlNpemUnLFxuICAgICd3aWRvd3MnLFxuICAgICd6SW5kZXgnLFxuICAgICd6b29tJyxcbiAgICAnZmlsbE9wYWNpdHknLCAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gICAgJ2Zsb29kT3BhY2l0eScsXG4gICAgJ3N0b3BPcGFjaXR5JyxcbiAgICAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgICAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICAgJ3N0cm9rZU1pdGVybGltaXQnLFxuICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAnc3Ryb2tlV2lkdGgnXG5dKTtcbmZ1bmN0aW9uIGlzVW5pdGxlc3NOdW1iZXIobmFtZSkge1xuICAgIHJldHVybiB1bml0bGVzc051bWJlcnMuaGFzKG5hbWUpO1xufVxuXG4vKipcbiAqIENvbXBvbmVudCB0byByZW5kZXIgYW4gSW5mbyBXaW5kb3cgd2l0aCB0aGUgTWFwcyBKYXZhU2NyaXB0IEFQSVxuICovXG5jb25zdCBJbmZvV2luZG93ID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IHsgXG4gICAgLy8gY29udGVudCBvcHRpb25zXG4gICAgY2hpbGRyZW4sIGhlYWRlckNvbnRlbnQsIHN0eWxlLCBjbGFzc05hbWUsIHBpeGVsT2Zmc2V0LCBcbiAgICAvLyBvcGVuIG9wdGlvbnNcbiAgICBhbmNob3IsIHNob3VsZEZvY3VzLCBcbiAgICAvLyBldmVudHNcbiAgICBvbkNsb3NlLCBvbkNsb3NlQ2xpY2sgfSA9IHByb3BzLCBcbiAgICAvLyBvdGhlciBvcHRpb25zXG4gICAgdm9sYXRpbGVJbmZvV2luZG93T3B0aW9ucyA9IF9fcmVzdChwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJoZWFkZXJDb250ZW50XCIsIFwic3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJwaXhlbE9mZnNldFwiLCBcImFuY2hvclwiLCBcInNob3VsZEZvY3VzXCIsIFwib25DbG9zZVwiLCBcIm9uQ2xvc2VDbGlja1wiXSk7XG4gICAgLy8gIyMgY3JlYXRlIGluZm93aW5kb3cgaW5zdGFuY2Ugb25jZSB0aGUgbWFwc0xpYnJhcnkgaXMgYXZhaWxhYmxlLlxuICAgIGNvbnN0IG1hcHNMaWJyYXJ5ID0gdXNlTWFwc0xpYnJhcnkoJ21hcHMnKTtcbiAgICBjb25zdCBbaW5mb1dpbmRvdywgc2V0SW5mb1dpbmRvd10gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb250ZW50Q29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGhlYWRlckNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpbmZvV2luZG93T3B0aW9ucyA9IHVzZU1lbW9pemVkKHZvbGF0aWxlSW5mb1dpbmRvd09wdGlvbnMsIGlzRGVlcEVxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcHNMaWJyYXJ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGluZm9XaW5kb3dPcHRpb25zO1xuICAgICAgICBpZiAocGl4ZWxPZmZzZXQpIHtcbiAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaXhlbE9mZnNldFswXSwgcGl4ZWxPZmZzZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBpZiBoZWFkZXJDb250ZW50IGlzIHNwZWNpZmllZCBhcyBzdHJpbmcgd2UgY2FuIGRpcmVjdGx5IGZvcndhcmQgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UnbGwgcGFzcyB0aGUgZWxlbWVudCB0aGUgcG9ydGFsIHdpbGwgcmVuZGVyIGludG9cbiAgICAgICAgICAgIG9wdHMuaGVhZGVyQ29udGVudCA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGhlYWRlckNvbnRlbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gaGVhZGVyQ29udGVudFxuICAgICAgICAgICAgICAgICAgICA6IGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgc2hhZG93aW5nIHRoZSBzdGF0ZSB2YXJpYWJsZXMgaGVyZVxuICAgICAgICBjb25zdCBpbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3coaW5mb1dpbmRvd09wdGlvbnMpO1xuICAgICAgICBpbmZvV2luZG93LnNldENvbnRlbnQoY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICAgICAgc2V0SW5mb1dpbmRvdyhpbmZvV2luZG93KTtcbiAgICAgICAgLy8gdW5tb3VudDogcmVtb3ZlIGluZm9XaW5kb3cgYW5kIGNvbnRlbnQgZWxlbWVudHMgKG5vdGU6IGNsb3NlIGlzIGNhbGxlZCBpbiBhIGRpZmZlcmVudCBlZmZlY3QtY2xlYW51cClcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpbmZvV2luZG93LnNldENvbnRlbnQobnVsbCk7XG4gICAgICAgICAgICAoX2EgPSBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgICAgICAgIChfYiA9IGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlKCk7XG4gICAgICAgICAgICBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgc2V0SW5mb1dpbmRvdyhudWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBcbiAgICAvLyBgaW5mb1dpbmRvd09wdGlvbnNgIGFuZCBvdGhlciBwcm9wcyBhcmUgbWlzc2luZyBmcm9tIGRlcGVuZGVuY2llczpcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmUtY3JlYXRlIHRoZSBpbmZvd2luZG93IGluc3RhbmNlXG4gICAgLy8gd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG4gICAgLy8gVXBkYXRpbmcgdGhlIG9wdGlvbnMgaXMgaGFuZGxlZCBpbiB0aGUgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFttYXBzTGlicmFyeV0pO1xuICAgIC8vIC0tLS0gdXBkYXRlIGNsYXNzTmFtZSBhbmQgc3R5bGVzIGZvciBgY29udGVudENvbnRhaW5lcmBcbiAgICAvLyBwcmV2U3R5bGVSZWYgc3RvcmVzIHByZXZpb3VzbHkgYXBwbGllZCBzdHlsZSBwcm9wZXJ0aWVzLCBzbyB0aGV5IGNhbiBiZVxuICAgIC8vIHJlbW92ZWQgd2hlbiB1bnNldFxuICAgIGNvbnN0IHByZXZTdHlsZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWluZm9XaW5kb3cgfHwgIWNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LCBzdHlsZSB8fCBudWxsLCBwcmV2U3R5bGVSZWYuY3VycmVudCk7XG4gICAgICAgIHByZXZTdHlsZVJlZi5jdXJyZW50ID0gc3R5bGUgfHwgbnVsbDtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LmNsYXNzTmFtZSlcbiAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XG4gICAgfSwgW2luZm9XaW5kb3csIGNsYXNzTmFtZSwgc3R5bGVdKTtcbiAgICAvLyAtLS0tIHVwZGF0ZSBvcHRpb25zXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpbmZvV2luZG93KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgICAgIGlmICghcGl4ZWxPZmZzZXQpIHtcbiAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG5ldyBnb29nbGUubWFwcy5TaXplKHBpeGVsT2Zmc2V0WzBdLCBwaXhlbE9mZnNldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoZWFkZXJDb250ZW50KSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlckNvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJDb250ZW50ID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaGVhZGVyQ29udGVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBoZWFkZXJDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDogaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1dpbmRvdy5zZXRPcHRpb25zKGluZm9XaW5kb3dPcHRpb25zKTtcbiAgICB9LCBcbiAgICAvLyBkZXBlbmRlbmN5IGBpbmZvV2luZG93YCBpc24ndCBuZWVkZWQgc2luY2Ugb3B0aW9ucyBhcmUgYWxzbyBwYXNzZWRcbiAgICAvLyB0byB0aGUgY29uc3RydWN0b3Igd2hlbiBhIG5ldyBpbmZvV2luZG93IGlzIGNyZWF0ZWQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtpbmZvV2luZG93T3B0aW9ucywgcGl4ZWxPZmZzZXQsIGhlYWRlckNvbnRlbnRdKTtcbiAgICAvLyAjIyBiaW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIoaW5mb1dpbmRvdywgJ2Nsb3NlJywgb25DbG9zZSk7XG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIoaW5mb1dpbmRvdywgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spO1xuICAgIC8vIC0tLS0gb3BlbiBpbmZvIHdpbmRvdyB3aGVuIGNvbnRlbnQgYW5kIG1hcCBhcmUgYXZhaWxhYmxlXG4gICAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBgYW5jaG9yID09PSBudWxsYCBtZWFucyBhbiBhbmNob3IgaXMgZGVmaW5lZCBidXQgbm90IHJlYWR5IHlldC5cbiAgICAgICAgaWYgKCFtYXAgfHwgIWluZm9XaW5kb3cgfHwgYW5jaG9yID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpc09wZW5lZFdpdGhBbmNob3IgPSAhIWFuY2hvcjtcbiAgICAgICAgY29uc3Qgb3Blbk9wdGlvbnMgPSB7IG1hcCB9O1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICBvcGVuT3B0aW9ucy5hbmNob3IgPSBhbmNob3I7XG4gICAgICAgICAgICAvLyBPbmx5IGRvIHRoZSBpbmZvd2luZG93IGFkanVzdGluZyB3aGVuIGRlYWxpbmcgd2l0aCBhbiBBZHZhbmNlZE1hcmtlclxuICAgICAgICAgICAgaWYgKGlzQWR2YW5jZWRNYXJrZXIoYW5jaG9yKSAmJiBhbmNob3IuY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JCY3IgPSBhbmNob3IgPT09IG51bGwgfHwgYW5jaG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGFuY2hvciBoYXMgY3VzdG9tIGNvbnRlbnQgd2l0aCBvdXIgb3duXG4gICAgICAgICAgICAgICAgLy8gZGl2IHdyYXBwZXIuIElmIG5vdCwgdGhhdCBtZWFucyB3ZSBoYXZlIGEgcmVndWxhciBBZHZhbmNlZE1hcmtlciB3aXRob3V0XG4gICAgICAgICAgICAgICAgLy8gY2hpbGRyZW4sIG9yIGFuIEFkdmFuY2VkTWFya2VyIHRoYXQgdXNlcyB0aGUgYW5jaG9yTGVmdC9hbmNob3JUb3AgcHJvcHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIGFkanVzdCB0aGUgaW5mb3dpbmRvdyBzaW5jZSBpdCBpcyBhbGwgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBieSB0aGUgR29vZ2xlIE1hcHMgQVBJLlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3JCY3IgJiYgYW5jaG9yLmRhdGFzZXQub3JpZ2luID09PSAncmdtJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc2FmZWx5IHR5cGVjYXN0IGhlcmUgc2luY2Ugd2UgY29udHJvbCB0aGF0IGVsZW1lbnQgYW5kIHdlIGtub3cgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBhIGRpdlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JEb21Db250ZW50ID0gKF9hID0gYW5jaG9yLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudEJjciA9IGFuY2hvckRvbUNvbnRlbnQgPT09IG51bGwgfHwgYW5jaG9yRG9tQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5jaG9yRG9tQ29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VudGVyIGluZm93aW5kb3cgYWJvdmUgbWFya2VyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvck9mZnNldFggPSBjb250ZW50QmNyLnggLVxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yQmNyLnggK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnRCY3Iud2lkdGggLSBhbmNob3JCY3Iud2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0WSA9IGNvbnRlbnRCY3IueSAtIGFuY2hvckJjci55O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaXhlbE9mZnNldCA/IHBpeGVsT2Zmc2V0WzBdICsgYW5jaG9yT2Zmc2V0WCA6IGFuY2hvck9mZnNldFgsIHBpeGVsT2Zmc2V0ID8gcGl4ZWxPZmZzZXRbMV0gKyBhbmNob3JPZmZzZXRZIDogYW5jaG9yT2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0T3B0aW9ucyhvcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZEZvY3VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZW5PcHRpb25zLnNob3VsZEZvY3VzID0gc2hvdWxkRm9jdXM7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG9wZW5PcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHdoZW4gdGhlIGluZm93aW5kb3cgaGFzIGFuIGFuY2hvciwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHNob3cgdXAgYWdhaW4gd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGFuY2hvciB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYmVmb3JlIGluZm9XaW5kb3cuY2xvc2UoKSBpcyBjYWxsZWQgYnV0IHRoZSBpdCBnZXRzXG4gICAgICAgICAgICAvLyBhZGRlZCBiYWNrIHRvIHRoZSBtYXAgYWZ0ZXIgdGhhdC5cbiAgICAgICAgICAgIC8vIE1vcmUgaW5mb3JtYXRpb24gaGVyZTogaHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvMzQzNzUwODQ5XG4gICAgICAgICAgICBpZiAoaXNPcGVuZWRXaXRoQW5jaG9yKVxuICAgICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0KCdhbmNob3InLCBudWxsKTtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaW5mb1dpbmRvdywgYW5jaG9yLCBtYXAsIHNob3VsZEZvY3VzLCBpbmZvV2luZG93T3B0aW9ucywgcGl4ZWxPZmZzZXRdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpLFxuICAgICAgICBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgY3JlYXRlUG9ydGFsKGhlYWRlckNvbnRlbnQsIGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50KSkpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbG9jYXRpb24gaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBzdWl0YWJsZSBmb3IgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSS5cbiAqXG4gKiBAcGFyYW0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gZm9ybWF0LCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdCB3aXRoIGxhdC9sbmcgcHJvcGVydGllc1xuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxvY2F0aW9uIGluIHRoZSBmb3JtYXQgXCJsYXQsbG5nXCIgb3IgdGhlIG9yaWdpbmFsIHN0cmluZ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXR1cm5zIFwiNDAuNzE0NzI4LC03My45OTg2NzJcIlxuICogZm9ybWF0TG9jYXRpb24oeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0pXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJldHVybnMgXCJOZXcgWW9yaywgTllcIlxuICogZm9ybWF0TG9jYXRpb24oXCJOZXcgWW9yaywgTllcIilcbiAqL1xuZnVuY3Rpb24gZm9ybWF0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGxvY2F0aW9uXG4gICAgICAgIDogYCR7bG9jYXRpb24ubGF0fSwke2xvY2F0aW9uLmxuZ31gO1xufVxuLy8gVXNlZCBmb3IgcmVtb3ZpbmcgdGhlIGxlYWRpbmcgcGlwZSBmcm9tIHRoZSBwYXJhbSBzdHJpbmdcbmZ1bmN0aW9uIGZvcm1hdFBhcmFtKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQXNzZW1ibGVzIG1hcmtlciBwYXJhbWV0ZXJzIGZvciBzdGF0aWMgbWFwcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIGdyb3VwcyB0aGVtIGJ5IHRoZWlyIHN0eWxlIHByb3BlcnRpZXMuXG4gKiBJdCB0aGVuIGNyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbWFya2VycywgaW5jbHVkaW5nIHRoZWlyIHN0eWxlcyBhbmQgbG9jYXRpb25zLFxuICogd2hpY2ggY2FuIGJlIHVzZWQgYXMgcGFyYW1ldGVycyBmb3Igc3RhdGljIG1hcCBBUElzLlxuICpcbiAqIEBwYXJhbSB7U3RhdGljTWFwc01hcmtlcltdfSBbbWFya2Vycz1bXV0gLSBBbiBhcnJheSBvZiBtYXJrZXJzIHRvIGJlIHByb2Nlc3NlZC4gRWFjaCBtYXJrZXIgY2FuIGhhdmUgcHJvcGVydGllcyBzdWNoIGFzIGNvbG9yLCBsYWJlbCwgc2l6ZSwgc2NhbGUsIGljb24sIGFuY2hvciwgYW5kIGxvY2F0aW9uLlxuICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBzdHJpbmdzLCBlYWNoIHJlcHJlc2VudGluZyBhIGdyb3VwIG9mIG1hcmtlcnMgd2l0aCB0aGVpciBzdHlsZXMgYW5kIGxvY2F0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWFya2VycyA9IFtcbiAqICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ0EnLCBzaXplOiAnbWlkJywgbG9jYXRpb246ICc0MC43MTQ3MjgsLTczLjk5ODY3MicgfSxcbiAqICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ0InLCBzaXplOiAnbWlkJywgbG9jYXRpb246ICc0MC43MTQ3MjgsLTczLjk5ODY3MicgfSxcbiAqICAgeyBpY29uOiAnaHR0cDovL2V4YW1wbGUuY29tL2ljb24ucG5nJywgbG9jYXRpb246IHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9IH1cbiAqIF07XG4gKiBjb25zdCBwYXJhbXMgPSBhc3NlbWJsZU1hcmtlclBhcmFtcyhtYXJrZXJzKTtcbiAqIC8vIFBhcmFtcyB3aWxsIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBtYXJrZXIgcGFyYW1ldGVyc1xuICogRXhhbXBsZSBvdXRwdXQ6IFtcbiAqICAgXCJjb2xvcjpibHVlfGxhYmVsOkF8c2l6ZTptaWR8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE0NzI4LC03My45OTg2NzJcIixcbiAqICAgXCJjb2xvcjpibHVlfGxhYmVsOkJ8c2l6ZTptaWR8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE0NzI4LC03My45OTg2NzJcIixcbiAqICAgXCJpY29uOmh0dHA6Ly9leGFtcGxlLmNvbS9pY29uLnBuZ3w0MC43MTQ3MjgsLTczLjk5ODY3MlwiXG4gKiBdXG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlTWFya2VyUGFyYW1zKG1hcmtlcnMgPSBbXSkge1xuICAgIGNvbnN0IG1hcmtlclBhcmFtcyA9IFtdO1xuICAgIC8vIEdyb3VwIG1hcmtlcnMgYnkgc3R5bGVcbiAgICBjb25zdCBtYXJrZXJzQnlTdHlsZSA9IG1hcmtlcnMgPT09IG51bGwgfHwgbWFya2VycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2Vycy5yZWR1Y2UoKHN0eWxlcywgbWFya2VyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IgPSAncmVkJywgbGFiZWwsIHNpemUsIHNjYWxlLCBpY29uLCBhbmNob3IgfSA9IG1hcmtlcjtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIHN0eWxlIGtleSBiYXNlZCBvbiBlaXRoZXIgaWNvbiBwcm9wZXJ0aWVzIG9yIHN0YW5kYXJkIG1hcmtlciBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHJlbGV2YW50UHJvcHMgPSBpY29uID8gW2ljb24sIGFuY2hvciwgc2NhbGVdIDogW2NvbG9yLCBsYWJlbCwgc2l6ZV07XG4gICAgICAgIGNvbnN0IGtleSA9IHJlbGV2YW50UHJvcHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKTtcbiAgICAgICAgc3R5bGVzW2tleV0gPSBzdHlsZXNba2V5XSB8fCBbXTtcbiAgICAgICAgc3R5bGVzW2tleV0ucHVzaChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sIHt9KTtcbiAgICBPYmplY3QudmFsdWVzKG1hcmtlcnNCeVN0eWxlICE9PSBudWxsICYmIG1hcmtlcnNCeVN0eWxlICE9PSB2b2lkIDAgPyBtYXJrZXJzQnlTdHlsZSA6IHt9KS5mb3JFYWNoKG1hcmtlcnMgPT4ge1xuICAgICAgICBsZXQgbWFya2VyUGFyYW0gPSAnJztcbiAgICAgICAgY29uc3QgeyBpY29uIH0gPSBtYXJrZXJzWzBdO1xuICAgICAgICAvLyBDcmVhdGUgbWFya2VyIHN0eWxlIGZyb20gZmlyc3QgbWFya2VyIGluIGdyb3VwIHNpbmNlIGFsbCBtYXJrZXJzIHNoYXJlIHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICBPYmplY3QuZW50cmllcyhtYXJrZXJzWzBdKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgYmFzZWQgb24gd2hldGhlciBtYXJrZXIgdXNlcyBjdXN0b20gaWNvblxuICAgICAgICAgICAgY29uc3QgcmVsZXZhbnRLZXlzID0gaWNvblxuICAgICAgICAgICAgICAgID8gWydpY29uJywgJ2FuY2hvcicsICdzY2FsZSddXG4gICAgICAgICAgICAgICAgOiBbJ2NvbG9yJywgJ2xhYmVsJywgJ3NpemUnXTtcbiAgICAgICAgICAgIGlmIChyZWxldmFudEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlclBhcmFtICs9IGB8JHtrZXl9OiR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBsb2NhdGlvbiBjb29yZGluYXRlcyBmb3IgZWFjaCBtYXJrZXIgaW4gdGhlIHN0eWxlIGdyb3VwXG4gICAgICAgIC8vIEhhbmRsZXMgYm90aCBzdHJpbmcgbG9jYXRpb25zIGFuZCBsYXQvbG5nIG9iamVjdCBmb3JtYXRzLlxuICAgICAgICBmb3IgKGNvbnN0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHR5cGVvZiBtYXJrZXIubG9jYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBtYXJrZXIubG9jYXRpb25cbiAgICAgICAgICAgICAgICA6IGAke21hcmtlci5sb2NhdGlvbi5sYXR9LCR7bWFya2VyLmxvY2F0aW9uLmxuZ31gO1xuICAgICAgICAgICAgbWFya2VyUGFyYW0gKz0gYHwke2xvY2F0aW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyUGFyYW1zLnB1c2gobWFya2VyUGFyYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJrZXJQYXJhbXMubWFwKGZvcm1hdFBhcmFtKTtcbn1cblxuLy8gU3R5bGUgcHJvcGVydGllcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHBhdGhzIGluIHRoZSBTdGF0aWMgTWFwcyBBUElcbmNvbnN0IFBBVEhfU1RZTEVfS0VZUyA9IFsnY29sb3InLCAnd2VpZ2h0JywgJ2ZpbGxjb2xvcicsICdnZW9kZXNpYyddO1xuLyoqXG4gKiBCdWlsZHMgdGhlIHN0eWxlIHBvcnRpb24gb2YgYSBwYXRoIHBhcmFtZXRlciBzdHJpbmcuXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIG9iamVjdCBjb250YWluaW5nIHN0eWxlIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHdpdGggc3R5bGUgcGFyYW1ldGVycyBpbiB0aGUgZm9ybWF0IFwifGtleTp2YWx1ZVwiXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3R5bGVQYXJhbXMocGF0aCkge1xuICAgIGxldCBzdHlsZVBhcmFtcyA9ICcnO1xuICAgIFBBVEhfU1RZTEVfS0VZUy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChwYXRoW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVQYXJhbXMgKz0gYHwke2tleX06JHtwYXRoW2tleV19YDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZVBhcmFtcztcbn1cbi8qKlxuICogQnVpbGRzIHRoZSBjb29yZGluYXRlcyBwb3J0aW9uIG9mIGEgcGF0aCBwYXJhbWV0ZXIgc3RyaW5nLlxuICogQHBhcmFtIGNvb3JkaW5hdGVzIC0gRWl0aGVyIGEgc3RyaW5nIG9yIGFycmF5IG9mIGxvY2F0aW9uIG9iamVjdHNcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHdpdGggY29vcmRpbmF0ZXMgaW4gdGhlIGZvcm1hdCBcInxsYXQsbG5nfGxhdCxsbmdcIlxuICovXG5mdW5jdGlvbiBidWlsZENvb3JkaW5hdGVQYXJhbXMoY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGNvb3JkaW5hdGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYHwke2RlY29kZVVSSUNvbXBvbmVudChjb29yZGluYXRlcyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzLm1hcChsb2NhdGlvbiA9PiBgfCR7Zm9ybWF0TG9jYXRpb24obG9jYXRpb24pfWApLmpvaW4oJycpO1xufVxuLyoqXG4gKiBBc3NlbWJsZXMgcGF0aCBwYXJhbWV0ZXJzIGZvciB0aGUgU3RhdGljIE1hcHMgQVBJIGZyb20gYW4gYXJyYXkgb2YgcGF0aHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIGEgc3RyaW5nIG9mIHBhdGggcGFyYW1ldGVycyBmb3IgZWFjaCBwYXRoLiBFYWNoIHBhdGggcGFyYW1ldGVyIHN0cmluZ1xuICogaW5jbHVkZXMgdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcGF0aHMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdGF0aWNNYXBzUGF0aD59IFtwYXRocz1bXV0gLSBBbiBhcnJheSBvZiBwYXRocyB0byBiZSBhc3NlbWJsZWQgaW50byBwYXRoIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gQW4gYXJyYXkgb2YgcGF0aCBwYXJhbWV0ZXIgc3RyaW5ncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcGF0aHMgPSBbXG4gKiAgIHtcbiAqICAgICBjb2xvcjogJ3JlZCcsXG4gKiAgICAgd2VpZ2h0OiA1LFxuICogICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgICAgIHsgbGF0OiA0MC43MTgyMTcsIGxuZzogLTczLjk5ODI4NCB9XG4gKiAgICAgXVxuICogICB9XG4gKiBdO1xuICpcbiAqIGNvbnN0IHBhdGhQYXJhbXMgPSBhc3NlbWJsZVBhdGhQYXJhbXMocGF0aHMpO1xuICogLy8gT3V0cHV0OiBbJ2NvbG9yOnJlZHx3ZWlnaHQ6NXw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTgyMTcsLTczLjk5ODI4NCddXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVQYXRoUGFyYW1zKHBhdGhzID0gW10pIHtcbiAgICByZXR1cm4gcGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgICBjb25zdCBzdHlsZVBhcmFtcyA9IGJ1aWxkU3R5bGVQYXJhbXMocGF0aCk7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVQYXJhbXMgPSBidWlsZENvb3JkaW5hdGVQYXJhbXMocGF0aC5jb29yZGluYXRlcyk7XG4gICAgICAgIGNvbnN0IHBhdGhQYXJhbSA9IHN0eWxlUGFyYW1zICsgY29vcmRpbmF0ZVBhcmFtcztcbiAgICAgICAgcmV0dXJuIGZvcm1hdFBhcmFtKHBhdGhQYXJhbSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgR29vZ2xlIE1hcHMgc3R5bGUgb2JqZWN0cyBpbnRvIGFuIGFycmF5IG9mIHN0eWxlIHN0cmluZ3NcbiAqIGNvbXBhdGlibGUgd2l0aCB0aGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSS5cbiAqXG4gKiBAcGFyYW0gc3R5bGVzIC0gQW4gYXJyYXkgb2YgR29vZ2xlIE1hcHMgTWFwVHlwZVN0eWxlIG9iamVjdHMgdGhhdCBkZWZpbmUgdGhlIHN0eWxpbmcgcnVsZXNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGZvcm1hdHRlZCBzdHlsZSBzdHJpbmdzIHJlYWR5IHRvIGJlIHVzZWQgd2l0aCB0aGUgU3RhdGljIE1hcHMgQVBJXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0eWxlcyA9IFt7XG4gKiAgIGZlYXR1cmVUeXBlOiBcInJvYWRcIixcbiAqICAgZWxlbWVudFR5cGU6IFwiZ2VvbWV0cnlcIixcbiAqICAgc3R5bGVyczogW3tjb2xvcjogXCIjZmYwMDAwXCJ9LCB7d2VpZ2h0OiAxfV1cbiAqIH1dO1xuICpcbiAqIGNvbnN0IHN0eWxlU3RyaW5ncyA9IGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZXMpO1xuICogLy8gUmV0dXJuczogW1wifGZlYXR1cmU6cm9hZHxlbGVtZW50Omdlb21ldHJ5fGNvbG9yOjB4ZmYwMDAwfHdlaWdodDoxXCJdXG4gKlxuICogRWFjaCBzdHlsZSBzdHJpbmcgZm9sbG93cyB0aGUgZm9ybWF0OlxuICogXCJmZWF0dXJlOntmZWF0dXJlVHlwZX18ZWxlbWVudDp7ZWxlbWVudFR5cGV9fHtzdHlsZXJOYW1lfTp7c3R5bGVyVmFsdWV9XCJcbiAqXG4gKiBOb3RlOiBDb2xvciB2YWx1ZXMgd2l0aCBoZXhhZGVjaW1hbCBub3RhdGlvbiAoIykgYXJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkXG4gKiB0byB0aGUgcmVxdWlyZWQgMHggZm9ybWF0IGZvciB0aGUgU3RhdGljIE1hcHMgQVBJLlxuICovXG5mdW5jdGlvbiBhc3NlbWJsZU1hcFR5cGVTdHlsZXMoc3R5bGVzKSB7XG4gICAgcmV0dXJuIHN0eWxlc1xuICAgICAgICAubWFwKChtYXBUeXBlU3R5bGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBmZWF0dXJlVHlwZSwgZWxlbWVudFR5cGUsIHN0eWxlcnMgPSBbXSB9ID0gbWFwVHlwZVN0eWxlO1xuICAgICAgICBsZXQgc3R5bGVTdHJpbmcgPSAnJztcbiAgICAgICAgaWYgKGZlYXR1cmVUeXBlKSB7XG4gICAgICAgICAgICBzdHlsZVN0cmluZyArPSBgfGZlYXR1cmU6JHtmZWF0dXJlVHlwZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgc3R5bGVTdHJpbmcgKz0gYHxlbGVtZW50OiR7ZWxlbWVudFR5cGV9YDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlciBvZiBzdHlsZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhzdHlsZXIpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBzdHlsZVN0cmluZyArPSBgfCR7bmFtZX06JHtTdHJpbmcodmFsdWUpLnJlcGxhY2UoJyMnLCAnMHgnKX1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlU3RyaW5nO1xuICAgIH0pXG4gICAgICAgIC5tYXAoZm9ybWF0UGFyYW0pO1xufVxuXG5jb25zdCBTVEFUSUNfTUFQU19CQVNFID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9zdGF0aWNtYXAnO1xuLyoqXG4gKiBDcmVhdGVzIGEgVVJMIGZvciB0aGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSSB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBzdGF0aWMgbWFwXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hcGlLZXkgLSBZb3VyIEdvb2dsZSBNYXBzIEFQSSBrZXkgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIG1hcCBpbWFnZSBpbiBwaXhlbHMgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgbWFwIGltYWdlIGluIHBpeGVscyAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNMb2NhdGlvbn0gW29wdGlvbnMuY2VudGVyXSAtIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIG1hcCAobGF0L2xuZyBvciBhZGRyZXNzKS5cbiAqICBSZXF1aXJlZCBpZiBubyBtYXJrZXJzIG9yIHBhdGhzIG9yIFwidmlzaWJsZSBsb2NhdGlvbnNcIiBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuem9vbV0gLSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBSZXF1aXJlZCBpZiBubyBtYXJrZXJzIG9yIHBhdGhzIG9yIFwidmlzaWJsZSBsb2NhdGlvbnNcIiBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0gezF8Mnw0fSBbb3B0aW9ucy5zY2FsZV0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgbWFwICgxLCAyLCBvciA0KVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZvcm1hdF0gLSBUaGUgaW1hZ2UgZm9ybWF0IChwbmcsIHBuZzgsIHBuZzMyLCBnaWYsIGpwZywganBnLWJhc2VsaW5lKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcFR5cGVdIC0gVGhlIHR5cGUgb2YgbWFwIChyb2FkbWFwLCBzYXRlbGxpdGUsIHRlcnJhaW4sIGh5YnJpZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV0gLSBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIG1hcCBsYWJlbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWdpb25dIC0gVGhlIHJlZ2lvbiBjb2RlIGZvciB0aGUgbWFwXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFwX2lkXSAtIFRoZSBDbG91ZC1iYXNlZCBtYXAgc3R5bGUgSURcbiAqIEBwYXJhbSB7U3RhdGljTWFwc01hcmtlcltdfSBbb3B0aW9ucy5tYXJrZXJzPVtdXSAtIEFycmF5IG9mIG1hcmtlcnMgdG8gZGlzcGxheSBvbiB0aGUgbWFwXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNQYXRoW119IFtvcHRpb25zLnBhdGhzPVtdXSAtIEFycmF5IG9mIHBhdGhzIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxuICogQHBhcmFtIHtTdGF0aWNNYXBzTG9jYXRpb25bXX0gW29wdGlvbnMudmlzaWJsZT1bXV0gLSBBcnJheSBvZiBsb2NhdGlvbnMgdGhhdCBzaG91bGQgYmUgdmlzaWJsZSBvbiB0aGUgbWFwXG4gKiBAcGFyYW0ge01hcFR5cGVTdHlsZVtdfSBbb3B0aW9ucy5zdHlsZT1bXV0gLSBBcnJheSBvZiBzdHlsZSBvYmplY3RzIHRvIGN1c3RvbWl6ZSB0aGUgbWFwIGFwcGVhcmFuY2VcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tcGxldGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSSBVUkxcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgQVBJIGtleSBpcyBub3QgcHJvdmlkZWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB3aWR0aCBvciBoZWlnaHQgaXMgbm90IHByb3ZpZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHVybCA9IGNyZWF0ZVN0YXRpY01hcHNVcmwoe1xuICogICBhcGlLZXk6ICdZT1VSX0FQSV9LRVknLFxuICogICB3aWR0aDogNjAwLFxuICogICBoZWlnaHQ6IDQwMCxcbiAqICAgY2VudGVyOiB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgem9vbTogMTIsXG4gKiAgIG1hcmtlcnM6IFtcbiAqICAgICB7XG4gKiAgICAgICBsb2NhdGlvbjogeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0sXG4gKiAgICAgICBjb2xvcjogJ3JlZCcsXG4gKiAgICAgICBsYWJlbDogJ0EnXG4gKiAgICAgfVxuICogICBdLFxuICogICBwYXRoczogW1xuICogICAgIHtcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICAgIHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9LFxuICogICAgICAgICB7IGxhdDogNDAuNzE5NzI4LCBsbmc6IC03My45OTE2NzIgfVxuICogICAgICAgXSxcbiAqICAgICAgIGNvbG9yOiAnMHgwMDAwZmYnLFxuICogICAgICAgd2VpZ2h0OiA1XG4gKiAgICAgfVxuICogICBdLFxuICogICBzdHlsZTogW1xuICogICAgIHtcbiAqICAgICAgIGZlYXR1cmVUeXBlOiAncm9hZCcsXG4gKiAgICAgICBlbGVtZW50VHlwZTogJ2dlb21ldHJ5JyxcbiAqICAgICAgIHN0eWxlcnM6IFt7Y29sb3I6ICcjMDBmZjAwJ31dXG4gKiAgICAgfVxuICogICBdXG4gKiB9KTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIFVSTCBzaW1pbGFyIHRvOlxuICogLy8gaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL3N0YXRpY21hcD9rZXk9WU9VUl9BUElfS0VZXG4gKiAvLyAmc2l6ZT02MDB4NDAwXG4gKiAvLyAmY2VudGVyPTQwLjcxNDcyOCwtNzMuOTk4NjcyJnpvb209MTJcbiAqIC8vICZtYXJrZXJzPWNvbG9yOnJlZHxsYWJlbDpBfDQwLjcxNDcyOCwtNzMuOTk4NjcyXG4gKiAvLyAmcGF0aD1jb2xvcjoweDAwMDBmZnx3ZWlnaHQ6NXw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTk3MjgsLTczLjk5MTY3MlxuICogLy8gJnN0eWxlPWZlYXR1cmU6cm9hZHxlbGVtZW50Omdlb21ldHJ5fGNvbG9yOjB4MDBmZjAwXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY01hcHNVcmwoeyBhcGlLZXksIHdpZHRoLCBoZWlnaHQsIGNlbnRlciwgem9vbSwgc2NhbGUsIGZvcm1hdCwgbWFwVHlwZSwgbGFuZ3VhZ2UsIHJlZ2lvbiwgbWFwSWQsIG1hcmtlcnMgPSBbXSwgcGF0aHMgPSBbXSwgdmlzaWJsZSA9IFtdLCBzdHlsZSA9IFtdIH0pIHtcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0FQSSBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV2lkdGggYW5kIGhlaWdodCBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsga2V5OiBhcGlLZXksIHNpemU6IGAke3dpZHRofXgke2hlaWdodH1gIH0sIChjZW50ZXIgJiYgeyBjZW50ZXI6IGZvcm1hdExvY2F0aW9uKGNlbnRlcikgfSkpLCAoem9vbSAmJiB7IHpvb20gfSkpLCAoc2NhbGUgJiYgeyBzY2FsZSB9KSksIChmb3JtYXQgJiYgeyBmb3JtYXQgfSkpLCAobWFwVHlwZSAmJiB7IG1hcHR5cGU6IG1hcFR5cGUgfSkpLCAobGFuZ3VhZ2UgJiYgeyBsYW5ndWFnZSB9KSksIChyZWdpb24gJiYgeyByZWdpb24gfSkpLCAobWFwSWQgJiYgeyBtYXBfaWQ6IG1hcElkIH0pKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFNUQVRJQ19NQVBTX0JBU0UpO1xuICAgIC8vIFBhcmFtcyB0aGF0IGRvbid0IG5lZWQgc3BlY2lhbCBoYW5kbGluZ1xuICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfSk7XG4gICAgLy8gQXNzZW1ibGUgTWFya2Vyc1xuICAgIGZvciAoY29uc3QgbWFya2VyUGFyYW0gb2YgYXNzZW1ibGVNYXJrZXJQYXJhbXMobWFya2VycykpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ21hcmtlcnMnLCBtYXJrZXJQYXJhbSk7XG4gICAgfVxuICAgIC8vIEFzc2VtYmxlIFBhdGhzXG4gICAgZm9yIChjb25zdCBwYXRoUGFyYW0gb2YgYXNzZW1ibGVQYXRoUGFyYW1zKHBhdGhzKSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgncGF0aCcsIHBhdGhQYXJhbSk7XG4gICAgfVxuICAgIC8vIEFzc2VtYmxlIHZpc2libGUgbG9jYXRpb25zXG4gICAgaWYgKHZpc2libGUubGVuZ3RoKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd2aXNpYmxlJywgdmlzaWJsZS5tYXAobG9jYXRpb24gPT4gZm9ybWF0TG9jYXRpb24obG9jYXRpb24pKS5qb2luKCd8JykpO1xuICAgIH1cbiAgICAvLyBBc3NlbWJsZSBNYXAgVHlwZSBTdHlsZXNcbiAgICBmb3IgKGNvbnN0IHN0eWxlU3RyaW5nIG9mIGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZSkpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3N0eWxlJywgc3R5bGVTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG5cbmNvbnN0IFN0YXRpY01hcCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCBjbGFzc05hbWUgfSA9IHByb3BzO1xuICAgIGlmICghdXJsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBpcyByZXF1aXJlZCcpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHNyYzogdXJsLCB3aWR0aDogXCIxMDAlXCIgfSk7XG59O1xuXG4vKipcbiAqIENvcHkgb2YgdGhlIGBnb29nbGUubWFwcy5Db250cm9sUG9zaXRpb25gIGNvbnN0YW50cy5cbiAqIFRoZXkgaGF2ZSB0byBiZSBkdXBsaWNhdGVkIGhlcmUgc2luY2Ugd2UgY2FuJ3Qgd2FpdCBmb3IgdGhlIG1hcHMgQVBJIHRvIGxvYWQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbS5cbiAqL1xuY29uc3QgQ29udHJvbFBvc2l0aW9uID0ge1xuICAgIFRPUF9MRUZUOiAxLFxuICAgIFRPUF9DRU5URVI6IDIsXG4gICAgVE9QOiAyLFxuICAgIFRPUF9SSUdIVDogMyxcbiAgICBMRUZUX0NFTlRFUjogNCxcbiAgICBMRUZUX1RPUDogNSxcbiAgICBMRUZUOiA1LFxuICAgIExFRlRfQk9UVE9NOiA2LFxuICAgIFJJR0hUX1RPUDogNyxcbiAgICBSSUdIVDogNyxcbiAgICBSSUdIVF9DRU5URVI6IDgsXG4gICAgUklHSFRfQk9UVE9NOiA5LFxuICAgIEJPVFRPTV9MRUZUOiAxMCxcbiAgICBCT1RUT01fQ0VOVEVSOiAxMSxcbiAgICBCT1RUT006IDExLFxuICAgIEJPVFRPTV9SSUdIVDogMTIsXG4gICAgQ0VOVEVSOiAxMyxcbiAgICBCTE9DS19TVEFSVF9JTkxJTkVfU1RBUlQ6IDE0LFxuICAgIEJMT0NLX1NUQVJUX0lOTElORV9DRU5URVI6IDE1LFxuICAgIEJMT0NLX1NUQVJUX0lOTElORV9FTkQ6IDE2LFxuICAgIElOTElORV9TVEFSVF9CTE9DS19DRU5URVI6IDE3LFxuICAgIElOTElORV9TVEFSVF9CTE9DS19TVEFSVDogMTgsXG4gICAgSU5MSU5FX1NUQVJUX0JMT0NLX0VORDogMTksXG4gICAgSU5MSU5FX0VORF9CTE9DS19TVEFSVDogMjAsXG4gICAgSU5MSU5FX0VORF9CTE9DS19DRU5URVI6IDIxLFxuICAgIElOTElORV9FTkRfQkxPQ0tfRU5EOiAyMixcbiAgICBCTE9DS19FTkRfSU5MSU5FX1NUQVJUOiAyMyxcbiAgICBCTE9DS19FTkRfSU5MSU5FX0NFTlRFUjogMjQsXG4gICAgQkxPQ0tfRU5EX0lOTElORV9FTkQ6IDI1XG59O1xuY29uc3QgTWFwQ29udHJvbCA9ICh7IGNoaWxkcmVuLCBwb3NpdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgY29udHJvbENvbnRhaW5lciA9IHVzZU1lbW8oKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIFtdKTtcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY29udHJvbHMgPSBtYXAuY29udHJvbHNbcG9zaXRpb25dO1xuICAgICAgICBjb250cm9scy5wdXNoKGNvbnRyb2xDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbHNBcnJheSA9IGNvbnRyb2xzLmdldEFycmF5KCk7XG4gICAgICAgICAgICAvLyBjb250cm9sc0FycmF5IGNvdWxkIGJlIHVuZGVmaW5lZCBpZiB0aGUgbWFwIGlzIGluIGFuIHVuZGVmaW5lZCBzdGF0ZSAoZS5nLiBpbnZhbGlkIEFQSS1rZXksIHNlZSAjMjc2XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xzQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjb250cm9sc0FycmF5LmluZGV4T2YoY29udHJvbENvbnRhaW5lcik7XG4gICAgICAgICAgICBjb250cm9scy5yZW1vdmVBdChpbmRleCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NvbnRyb2xDb250YWluZXIsIG1hcCwgcG9zaXRpb25dKTtcbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250cm9sQ29udGFpbmVyKTtcbn07XG5cbmZ1bmN0aW9uIHVzZU1hcmtlcihwcm9wcykge1xuICAgIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICBjb25zdCB7IG9uQ2xpY2ssIG9uRHJhZywgb25EcmFnU3RhcnQsIG9uRHJhZ0VuZCwgb25Nb3VzZU92ZXIsIG9uTW91c2VPdXQgfSA9IHByb3BzLCBtYXJrZXJPcHRpb25zID0gX19yZXN0KHByb3BzLCBbXCJvbkNsaWNrXCIsIFwib25EcmFnXCIsIFwib25EcmFnU3RhcnRcIiwgXCJvbkRyYWdFbmRcIiwgXCJvbk1vdXNlT3ZlclwiLCBcIm9uTW91c2VPdXRcIl0pO1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIGRyYWdnYWJsZSB9ID0gbWFya2VyT3B0aW9ucztcbiAgICAvLyBjcmVhdGUgbWFya2VyIGluc3RhbmNlIGFuZCBhZGQgdG8gdGhlIG1hcCBvbmNlIHRoZSBtYXAgaXMgYXZhaWxhYmxlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCc8TWFya2VyPiBoYXMgdG8gYmUgaW5zaWRlIGEgTWFwIGNvbXBvbmVudC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG1hcmtlck9wdGlvbnMpO1xuICAgICAgICBuZXdNYXJrZXIuc2V0TWFwKG1hcCk7XG4gICAgICAgIHNldE1hcmtlcihuZXdNYXJrZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbmV3TWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gcmUtcmVuZGVyIHRoZSB3aG9sZSBtYXJrZXIgd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG4gICAgICAgIC8vIE1hcmtlciBvcHRpb25zIHVwZGF0ZSBpcyBoYW5kbGVkIGluIGEgdXNlRWZmZWN0IGJlbG93LlxuICAgICAgICAvLyBFeGNsdWRpbmcgbWFya2VyT3B0aW9ucyBmcm9tIGRlcGVuZGVuY3kgYXJyYXkgb24gcHVycG9zZSBoZXJlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW21hcF0pO1xuICAgIC8vIGF0dGFjaCBhbmQgcmUtYXR0YWNoIGV2ZW50LWhhbmRsZXJzIHdoZW4gYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGNoYW5nZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtID0gbWFya2VyO1xuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IGdtZSA9IGdvb2dsZS5tYXBzLmV2ZW50O1xuICAgICAgICBpZiAob25DbGljaylcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICAgICAgaWYgKG9uRHJhZylcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnZHJhZycsIG9uRHJhZyk7XG4gICAgICAgIGlmIChvbkRyYWdTdGFydClcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpO1xuICAgICAgICBpZiAob25EcmFnRW5kKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICAgICAgaWYgKG9uTW91c2VPdmVyKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdtb3VzZW91dCcsIG9uTW91c2VPdXQpO1xuICAgICAgICBtYXJrZXIuc2V0RHJhZ2dhYmxlKEJvb2xlYW4oZHJhZ2dhYmxlKSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBnbWUuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhtKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG1hcmtlcixcbiAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICBvbkNsaWNrLFxuICAgICAgICBvbkRyYWcsXG4gICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRyYWdFbmQsXG4gICAgICAgIG9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlT3V0XG4gICAgXSk7XG4gICAgLy8gdXBkYXRlIG1hcmtlck9wdGlvbnMgKG5vdGUgdGhlIGRlcGVuZGVuY2llcyBhcmVuJ3QgcHJvcGVybHkgY2hlY2tlZFxuICAgIC8vIGhlcmUsIHdlIGp1c3QgYXNzdW1lIHRoYXQgc2V0T3B0aW9ucyBpcyBzbWFydCBlbm91Z2ggdG8gbm90IHdhc3RlIGFcbiAgICAvLyBsb3Qgb2YgdGltZSB1cGRhdGluZyB2YWx1ZXMgdGhhdCBkaWRuJ3QgY2hhbmdlKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobWFya2VyT3B0aW9ucylcbiAgICAgICAgICAgIG1hcmtlci5zZXRPcHRpb25zKG1hcmtlck9wdGlvbnMpO1xuICAgIH0sIFttYXJrZXIsIG1hcmtlck9wdGlvbnNdKTtcbiAgICAvLyB1cGRhdGUgcG9zaXRpb24gd2hlbiBjaGFuZ2VkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gU2hvdWxkIG5vdCB1cGRhdGUgcG9zaXRpb24gd2hlbiBkcmFnZ2FibGVcbiAgICAgICAgaWYgKGRyYWdnYWJsZSB8fCAhcG9zaXRpb24gfHwgIW1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFya2VyLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9LCBbZHJhZ2dhYmxlLCBwb3NpdGlvbiwgbWFya2VyXSk7XG4gICAgcmV0dXJuIG1hcmtlcjtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIG1hcmtlciBvbiBhIG1hcFxuICovXG5jb25zdCBNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgbWFya2VyID0gdXNlTWFya2VyKHByb3BzKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbbWFya2VyXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpO1xufSk7XG5NYXJrZXIuZGlzcGxheU5hbWUgPSAnTWFya2VyJztcbmZ1bmN0aW9uIHVzZU1hcmtlclJlZigpIHtcbiAgICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgcmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygobSkgPT4ge1xuICAgICAgICBzZXRNYXJrZXIobSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIGNvbmZpZ3VyZSB0aGUgYXBwZWFyYW5jZSBvZiBhbiBBZHZhbmNlZE1hcmtlclxuICovXG5jb25zdCBQaW4gPSBwcm9wcyA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFkdmFuY2VkTWFya2VyID0gKF9hID0gdXNlQ29udGV4dChBZHZhbmNlZE1hcmtlckNvbnRleHQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VyO1xuICAgIGNvbnN0IGdseXBoQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICAgIC8vIENyZWF0ZSBQaW4gVmlldyBpbnN0YW5jZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFhZHZhbmNlZE1hcmtlcikge1xuICAgICAgICAgICAgaWYgKGFkdmFuY2VkTWFya2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgPFBpbj4gY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIDxBZHZhbmNlZE1hcmtlcj4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmdseXBoICYmIHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsb2dFcnJvck9uY2UoJ1RoZSA8UGluPiBjb21wb25lbnQgb25seSB1c2VzIGNoaWxkcmVuIHRvIHJlbmRlciB0aGUgZ2x5cGggaWYgYm90aCB0aGUgZ2x5cGggcHJvcGVydHkgYW5kIGNoaWxkcmVuIGFyZSBwcmVzZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbikgPiAxKSB7XG4gICAgICAgICAgICBsb2dFcnJvck9uY2UoJ1Bhc3NpbmcgbXVsdGlwbGUgY2hpbGRyZW4gdG8gdGhlIDxQaW4+IGNvbXBvbmVudCBtaWdodCBsZWFkIHRvIHVuZXhwZWN0ZWQgcmVzdWx0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaW5WaWV3T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKTtcbiAgICAgICAgY29uc3QgcGluRWxlbWVudCA9IG5ldyBnb29nbGUubWFwcy5tYXJrZXIuUGluRWxlbWVudChwaW5WaWV3T3B0aW9ucyk7XG4gICAgICAgIC8vIFNldCBnbHlwaCB0byBnbHlwaCBjb250YWluZXIgaWYgY2hpbGRyZW4gYXJlIHByZXNlbnQgKHJlbmRlcmVkIHZpYSBwb3J0YWwpLlxuICAgICAgICAvLyBJZiBib3RoIHByb3BzLmdseXBoIGFuZCBwcm9wcy5jaGlsZHJlbiBhcmUgcHJlc2VudCwgcHJvcHMuY2hpbGRyZW4gdGFrZXMgcHJpb3JpdHkuXG4gICAgICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcGluRWxlbWVudC5nbHlwaCA9IGdseXBoQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBjb250ZW50IG9mIEFkdmFuY2VkIE1hcmtlciBWaWV3IHRvIHRoZSBQaW4gVmlldyBlbGVtZW50XG4gICAgICAgIC8vIEhlcmUgd2UgYXJlIHNlbGVjdGluZyB0aGUgYW5jaG9yIGNvbnRhaW5lci5cbiAgICAgICAgLy8gVGhlIGhpZXJhcmNoeSBpcyBhcyBmb2xsb3dzOlxuICAgICAgICAvLyBcImFkdmFuY2VkTWFya2VyLmNvbnRlbnRcIiAoZnJvbSBnb29nbGUpIC0+IFwiYW5jaG9yIGNvbnRhaW5lclwiXG4gICAgICAgIGNvbnN0IG1hcmtlckNvbnRlbnQgPSAoX2EgPSBhZHZhbmNlZE1hcmtlci5jb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKG1hcmtlckNvbnRlbnQgPT09IG51bGwgfHwgbWFya2VyQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyQ29udGVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBtYXJrZXJDb250ZW50LnJlbW92ZUNoaWxkKG1hcmtlckNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlckNvbnRlbnQpIHtcbiAgICAgICAgICAgIG1hcmtlckNvbnRlbnQuYXBwZW5kQ2hpbGQocGluRWxlbWVudC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0sIFthZHZhbmNlZE1hcmtlciwgZ2x5cGhDb250YWluZXIsIHByb3BzXSk7XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChwcm9wcy5jaGlsZHJlbiwgZ2x5cGhDb250YWluZXIpO1xufTtcblxuY29uc3QgbWFwTGluZWFyID0gKHgsIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArICgoeCAtIGExKSAqIChiMiAtIGIxKSkgLyAoYTIgLSBhMSk7XG5jb25zdCBnZXRNYXBNYXhUaWx0ID0gKHpvb20pID0+IHtcbiAgICBpZiAoem9vbSA8PSAxMCkge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfVxuICAgIGlmICh6b29tID49IDE1LjUpIHtcbiAgICAgICAgcmV0dXJuIDY3LjU7XG4gICAgfVxuICAgIC8vIHJhbmdlIFsxMC4uLjE0XVxuICAgIGlmICh6b29tIDw9IDE0KSB7XG4gICAgICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTAsIDE0LCAzMCwgNDUpO1xuICAgIH1cbiAgICAvLyByYW5nZSBbMTQuLi4xNS41XVxuICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTQsIDE1LjUsIDQ1LCA2Ny41KTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHRvIGxpbWl0IHRoZSB0aWx0IHJhbmdlIG9mIHRoZSBHb29nbGUgbWFwIHdoZW4gdXBkYXRpbmcgdGhlIHZpZXcgc3RhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGxpbWl0VGlsdFJhbmdlID0gKHsgdmlld1N0YXRlIH0pID0+IHtcbiAgICBjb25zdCBwaXRjaCA9IHZpZXdTdGF0ZS5waXRjaDtcbiAgICBjb25zdCBnbVpvb20gPSB2aWV3U3RhdGUuem9vbSArIDE7XG4gICAgY29uc3QgbWF4VGlsdCA9IGdldE1hcE1heFRpbHQoZ21ab29tKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWV3U3RhdGUpLCB7IGZvdnk6IDI1LCBwaXRjaDogTWF0aC5taW4obWF4VGlsdCwgcGl0Y2gpIH0pO1xufTtcblxuZXhwb3J0IHsgQVBJTG9hZGluZ1N0YXR1cywgQVBJUHJvdmlkZXIsIEFQSVByb3ZpZGVyQ29udGV4dCwgQWR2YW5jZWRNYXJrZXIsIEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnQsIEFkdmFuY2VkTWFya2VyQ29udGV4dCwgQ29sbGlzaW9uQmVoYXZpb3IsIENvbG9yU2NoZW1lLCBDb250cm9sUG9zaXRpb24sIEdvb2dsZU1hcHNDb250ZXh0LCBJbmZvV2luZG93LCBNYXAsIE1hcENvbnRyb2wsIE1hcmtlciwgUGluLCBSZW5kZXJpbmdUeXBlLCBTdGF0aWNNYXAsIFZFUlNJT04sIGNyZWF0ZVN0YXRpY01hcHNVcmwsIGlzQWR2YW5jZWRNYXJrZXIsIGlzTGF0TG5nTGl0ZXJhbCwgbGF0TG5nRXF1YWxzLCBsaW1pdFRpbHRSYW5nZSwgdG9MYXRMbmdMaXRlcmFsLCB1c2VBZHZhbmNlZE1hcmtlclJlZiwgdXNlQXBpSXNMb2FkZWQsIHVzZUFwaUxvYWRpbmdTdGF0dXMsIHVzZU1hcCwgdXNlTWFwc0xpYnJhcnksIHVzZU1hcmtlclJlZiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubW9kZXJuLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInVzZVJlZHVjZXIiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNvbnRleHQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJmb3J3YXJkUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsIkNoaWxkcmVuIiwiY3JlYXRlUG9ydGFsIiwiaXNEZWVwRXF1YWwiLCJWRVJTSU9OIiwiX19yZXN0IiwicyIsImUiLCJ0IiwicCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpIiwibGVuZ3RoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIlN1cHByZXNzZWRFcnJvciIsImVycm9yIiwic3VwcHJlc3NlZCIsIm1lc3NhZ2UiLCJFcnJvciIsIm5hbWUiLCJBUElMb2FkaW5nU3RhdHVzIiwiTk9UX0xPQURFRCIsIkxPQURJTkciLCJMT0FERUQiLCJGQUlMRUQiLCJBVVRIX0ZBSUxVUkUiLCJNQVBTX0FQSV9CQVNFX1VSTCIsIkdvb2dsZU1hcHNBcGlMb2FkZXIiLCJsb2FkIiwicGFyYW1zIiwib25Mb2FkaW5nU3RhdHVzQ2hhbmdlIiwiX2EiLCJfYiIsImxpYnJhcmllcyIsInNwbGl0Iiwic2VyaWFsaXplZFBhcmFtcyIsInNlcmlhbGl6ZVBhcmFtcyIsImxpc3RlbmVycyIsInB1c2giLCJ3aW5kb3ciLCJnb29nbGUiLCJtYXBzIiwiaW1wb3J0TGlicmFyeSIsInNlcmlhbGl6ZWRBcGlQYXJhbXMiLCJsb2FkaW5nU3RhdHVzIiwibm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycyIsImluaXRJbXBvcnRMaWJyYXJ5IiwiY29uc29sZSIsIndhcm4iLCJsaWJyYXJpZXNUb0xvYWQiLCJhbGwiLCJtYXAiLCJ2Iiwia2V5IiwibGFuZ3VhZ2UiLCJyZWdpb24iLCJhdXRoUmVmZXJyZXJQb2xpY3kiLCJzb2x1dGlvbkNoYW5uZWwiLCJqb2luIiwiYXBpUHJvbWlzZSIsImxvYWRBcGkiLCJzY3JpcHRFbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidXJsUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiZW50cmllcyIsInVybFBhcmFtTmFtZSIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInNldCIsIlN0cmluZyIsImFzeW5jIiwic3JjIiwidG9TdHJpbmciLCJub25jZSIsInF1ZXJ5U2VsZWN0b3IiLCJvbmVycm9yIiwiX19nb29nbGVNYXBzQ2FsbGJhY2tfXyIsImdtX2F1dGhGYWlsdXJlIiwiaGVhZCIsImFwcGVuZCIsImxpYnJhcnlOYW1lIiwiZm4iLCJERUZBVUxUX1NPTFVUSU9OX0NIQU5ORUwiLCJERUZBVUxUX0lOVEVSTkFMX1VTQUdFX0FUVFJJQlVUSU9OX0lEUyIsIkFQSVByb3ZpZGVyQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VNYXBJbnN0YW5jZXMiLCJtYXBJbnN0YW5jZXMiLCJzZXRNYXBJbnN0YW5jZXMiLCJhZGRNYXBJbnN0YW5jZSIsIm1hcEluc3RhbmNlIiwiaWQiLCJpbnN0YW5jZXMiLCJhc3NpZ24iLCJyZW1vdmVNYXBJbnN0YW5jZSIsInJlbWFpbmluZyIsImNsZWFyTWFwSW5zdGFuY2VzIiwidXNlR29vZ2xlTWFwc0FwaUxvYWRlciIsInByb3BzIiwib25Mb2FkIiwib25FcnJvciIsImFwaUtleSIsInZlcnNpb24iLCJvdGhlckFwaVBhcmFtcyIsInN0YXR1cyIsInNldFN0YXR1cyIsImxvYWRlZExpYnJhcmllcyIsImFkZExvYWRlZExpYnJhcnkiLCJhY3Rpb24iLCJsaWJyYXJpZXNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicmVzIiwiY2hhbm5lbCIsInVuZGVmaW5lZCIsInVzZUludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyIsImludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyIsImRpc2FibGVVc2FnZUF0dHJpYnV0aW9uIiwiQVBJUHJvdmlkZXIiLCJjaGlsZHJlbiIsImxvYWRlclByb3BzIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ1c2VNYXBFdmVudHMiLCJwcm9wTmFtZSIsImV2ZW50UHJvcE5hbWVzIiwiaGFuZGxlciIsImV2ZW50VHlwZSIsInByb3BOYW1lVG9FdmVudFR5cGUiLCJsaXN0ZW5lciIsImV2ZW50IiwiYWRkTGlzdGVuZXIiLCJldiIsImNyZWF0ZU1hcEV2ZW50IiwicmVtb3ZlIiwidHlwZSIsInNyY0V2ZW50IiwiZGV0YWlsIiwic3RvcHBhYmxlIiwic3RvcCIsImNhbWVyYUV2ZW50VHlwZXMiLCJpbmNsdWRlcyIsImNhbUV2ZW50IiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwiem9vbSIsImdldFpvb20iLCJoZWFkaW5nIiwiZ2V0SGVhZGluZyIsInRpbHQiLCJnZXRUaWx0IiwiYm91bmRzIiwiZ2V0Qm91bmRzIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJsYXQiLCJsbmciLCJub3J0aCIsImVhc3QiLCJzb3V0aCIsIndlc3QiLCJtb3VzZUV2ZW50VHlwZXMiLCJtb3VzZUV2ZW50IiwiZG9tRXZlbnQiLCJsYXRMbmciLCJwbGFjZUlkIiwib25Cb3VuZHNDaGFuZ2VkIiwib25DZW50ZXJDaGFuZ2VkIiwib25DbGljayIsIm9uQ29udGV4dG1lbnUiLCJvbkRibGNsaWNrIiwib25EcmFnIiwib25EcmFnZW5kIiwib25EcmFnc3RhcnQiLCJvbkhlYWRpbmdDaGFuZ2VkIiwib25JZGxlIiwib25Jc0ZyYWN0aW9uYWxab29tRW5hYmxlZENoYW5nZWQiLCJvbk1hcENhcGFiaWxpdGllc0NoYW5nZWQiLCJvbk1hcFR5cGVJZENoYW5nZWQiLCJvbk1vdXNlbW92ZSIsIm9uTW91c2VvdXQiLCJvbk1vdXNlb3ZlciIsIm9uUHJvamVjdGlvbkNoYW5nZWQiLCJvblJlbmRlcmluZ1R5cGVDaGFuZ2VkIiwib25UaWxlc0xvYWRlZCIsIm9uVGlsdENoYW5nZWQiLCJvblpvb21DaGFuZ2VkIiwib25DYW1lcmFDaGFuZ2VkIiwia2V5cyIsInVzZVByZXZpb3VzIiwicmVmIiwiY3VycmVudCIsInVzZU1lbW9pemVkIiwiaXNFcXVhbCIsInByZXZpb3VzIiwidXNlQ3VzdG9tQ29tcGFyZUVmZmVjdCIsImVmZmVjdCIsImRlcGVuZGVuY2llcyIsInVzZURlZXBDb21wYXJlRWZmZWN0IiwibWFwT3B0aW9uS2V5cyIsIlNldCIsInVzZU1hcE9wdGlvbnMiLCJtYXBQcm9wcyIsIm1hcE9wdGlvbnMiLCJoYXMiLCJzZXRPcHRpb25zIiwidXNlQXBpTG9hZGluZ1N0YXR1cyIsInVzZURlY2tHTENhbWVyYVVwZGF0ZSIsInZpZXdwb3J0Iiwidmlld1N0YXRlIiwiaXNEZWNrR2xDb250cm9sbGVkIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJiZWFyaW5nIiwicGl0Y2giLCJtb3ZlQ2FtZXJhIiwiaXNMYXRMbmdMaXRlcmFsIiwib2JqIiwibGF0TG5nRXF1YWxzIiwiYSIsImIiLCJBIiwidG9MYXRMbmdMaXRlcmFsIiwiQiIsInVzZU1hcENhbWVyYVBhcmFtcyIsImNhbWVyYVN0YXRlUmVmIiwibmV4dENhbWVyYSIsIm5lZWRzVXBkYXRlIiwiQXV0aEZhaWx1cmVNZXNzYWdlIiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInpJbmRleCIsImRpc3BsYXkiLCJmbGV4RmxvdyIsInRleHRBbGlnbiIsImp1c3RpZnlDb250ZW50IiwiZm9udFNpemUiLCJjb2xvciIsImJhY2tncm91bmQiLCJwYWRkaW5nIiwidXNlQ2FsbGJhY2tSZWYiLCJlbCIsInNldEVsIiwidXNlQXBpSXNMb2FkZWQiLCJ1c2VGb3JjZVVwZGF0ZSIsImZvcmNlVXBkYXRlIiwieCIsImhhbmRsZUJvdW5kc0NoYW5nZSIsInVzZVRyYWNrZWRDYW1lcmFTdGF0ZVJlZiIsIkNhY2hlZE1hcFN0YWNrIiwicG9wIiwidXNlTWFwSW5zdGFuY2UiLCJjb250ZXh0IiwiYXBpSXNMb2FkZWQiLCJzZXRNYXAiLCJjb250YWluZXIiLCJjb250YWluZXJSZWYiLCJkZWZhdWx0Qm91bmRzIiwiZGVmYXVsdENlbnRlciIsImRlZmF1bHRab29tIiwiZGVmYXVsdEhlYWRpbmciLCJkZWZhdWx0VGlsdCIsInJldXNlTWFwcyIsInJlbmRlcmluZ1R5cGUiLCJjb2xvclNjaGVtZSIsImhhc1pvb20iLCJoYXNDZW50ZXIiLCJjdXN0b21JZHMiLCJzYXZlZE1hcFN0YXRlUmVmIiwibWFwSWQiLCJjYWNoZUtleSIsIm1hcERpdiIsImdldERpdiIsImFwcGVuZENoaWxkIiwic2V0VGltZW91dCIsInNldENlbnRlciIsImhlaWdodCIsIk1hcCIsImRlZkJvdW5kcyIsImZpdEJvdW5kcyIsInNhdmVkTWFwSWQiLCJjYW1lcmFTdGF0ZSIsInNhdmVkQ2FtZXJhU3RhdGUiLCJjbGVhckluc3RhbmNlTGlzdGVuZXJzIiwiR29vZ2xlTWFwc0NvbnRleHQiLCJDb2xvclNjaGVtZSIsIkRBUksiLCJMSUdIVCIsIkZPTExPV19TWVNURU0iLCJSZW5kZXJpbmdUeXBlIiwiVkVDVE9SIiwiUkFTVEVSIiwiVU5JTklUSUFMSVpFRCIsImNsYXNzTmFtZSIsIm1hcFJlZiIsImlzQ29udHJvbGxlZEV4dGVybmFsbHkiLCJjb250cm9sbGVkIiwiZGlzYWJsZURlZmF1bHRVSSIsImdlc3R1cmVIYW5kbGluZyIsImtleWJvYXJkU2hvcnRjdXRzIiwiY2FtZXJhT3B0aW9ucyIsIl9jIiwiY29tYmluZWRTdHlsZSIsIndpZHRoIiwiZGVja0dMVmlld1Byb3BzIiwic2hvd25NZXNzYWdlcyIsImxvZ0Vycm9yT25jZSIsImFyZ3MiLCJhZGQiLCJ1c2VNYXAiLCJjdHgiLCJ1c2VNYXBzTGlicmFyeSIsInVzZU1hcHNFdmVudExpc3RlbmVyIiwidGFyZ2V0IiwiY2FsbGJhY2siLCJ1c2VQcm9wQmluZGluZyIsIm9iamVjdCIsInByb3AiLCJ1c2VEb21FdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJHbG9iYWxTdHlsZU1hbmFnZXIiLCJnZXRTdHlsZUVsZW1lbnQiLCJzdHlsZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhZGRBZHZhbmNlZE1hcmtlclBvaW50ZXJFdmVudHNPdmVyd3JpdGUiLCJyZW5kZXJlZFN0eWxlcyIsInRleHRDb250ZW50IiwiY2xlYW51cCIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJnbG9iYWxTdHlsZU1hbmFnZXIiLCJpc1ZlcnNpb25HcmVhdGVyRXF1YWwiLCJtYWpvciIsIm1pbm9yIiwiY3VycmVudE1ham9yIiwicGFyc2VJbnQiLCJjdXJyZW50TWlub3IiLCJDb2xsaXNpb25CZWhhdmlvciIsIlJFUVVJUkVEIiwiUkVRVUlSRURfQU5EX0hJREVTX09QVElPTkFMIiwiT1BUSU9OQUxfQU5EX0hJREVTX0xPV0VSX1BSSU9SSVRZIiwiQWR2YW5jZWRNYXJrZXJDb250ZXh0IiwiQWR2YW5jZWRNYXJrZXJBbmNob3JQb2ludCIsIlRPUF9MRUZUIiwiVE9QX0NFTlRFUiIsIlRPUCIsIlRPUF9SSUdIVCIsIkxFRlRfQ0VOVEVSIiwiTEVGVF9UT1AiLCJMRUZUIiwiTEVGVF9CT1RUT00iLCJSSUdIVF9UT1AiLCJSSUdIVCIsIlJJR0hUX0NFTlRFUiIsIlJJR0hUX0JPVFRPTSIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NX0NFTlRFUiIsIkJPVFRPTSIsIkJPVFRPTV9SSUdIVCIsIkNFTlRFUiIsIkFkdmFuY2VkTWFya2VyIiwiYW5jaG9yUG9pbnQiLCJtYXJrZXIiLCJjb250ZW50Q29udGFpbmVyIiwidXNlQWR2YW5jZWRNYXJrZXIiLCJhZHZhbmNlZE1hcmtlckNvbnRleHRWYWx1ZSIsIk1hcmtlckNvbnRlbnQiLCJzdHlsZXMiLCJkaXNwbGF5TmFtZSIsInVzZUFkdmFuY2VkTWFya2VyUmVmIiwic2V0TWFya2VyIiwicmVmQ2FsbGJhY2siLCJtIiwiaXNBZHZhbmNlZE1hcmtlciIsImNvbnRlbnQiLCJpc0VsZW1lbnROb2RlIiwibm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsInNldENvbnRlbnRDb250YWluZXIiLCJtYXJrZXJMaWJyYXJ5Iiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25EcmFnU3RhcnQiLCJvbkRyYWdFbmQiLCJjb2xsaXNpb25CZWhhdmlvciIsImNsaWNrYWJsZSIsImRyYWdnYWJsZSIsInRpdGxlIiwiYW5jaG9yTGVmdCIsImFuY2hvclRvcCIsIm51bUNoaWxkcmVuIiwiY291bnQiLCJuZXdNYXJrZXIiLCJBZHZhbmNlZE1hcmtlckVsZW1lbnQiLCJjb250ZW50RWxlbWVudCIsInVzZUFkdmFuY2VkTWFya2VyQW5jaG9yaW5nIiwiZ21wRHJhZ2dhYmxlIiwiZ21wQ2xpY2thYmxlIiwiQm9vbGVhbiIsInBvaW50ZXJFdmVudHMiLCJjdXJzb3IiLCJlbGVtZW50IiwiaGFzQ2hpbGRyZW4iLCJhbmNob3JPcHRpb25zU3VwcG9ydGVkIiwieSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwidHJhbnNmb3JtIiwiZGF0YXNldCIsIm9yaWdpbiIsInNldFZhbHVlRm9yU3R5bGVzIiwicHJldlN0eWxlcyIsImVsZW1lbnRTdHlsZSIsInN0eWxlTmFtZSIsInNldFZhbHVlRm9yU3R5bGUiLCJpc0N1c3RvbVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJjc3NGbG9hdCIsImlzVW5pdGxlc3NOdW1iZXIiLCJ0cmltIiwidW5pdGxlc3NOdW1iZXJzIiwiSW5mb1dpbmRvdyIsImhlYWRlckNvbnRlbnQiLCJwaXhlbE9mZnNldCIsImFuY2hvciIsInNob3VsZEZvY3VzIiwib25DbG9zZSIsIm9uQ2xvc2VDbGljayIsInZvbGF0aWxlSW5mb1dpbmRvd09wdGlvbnMiLCJtYXBzTGlicmFyeSIsImluZm9XaW5kb3ciLCJzZXRJbmZvV2luZG93IiwiY29udGVudENvbnRhaW5lclJlZiIsImhlYWRlckNvbnRhaW5lclJlZiIsImluZm9XaW5kb3dPcHRpb25zIiwib3B0cyIsIlNpemUiLCJzZXRDb250ZW50IiwicHJldlN0eWxlUmVmIiwiaXNPcGVuZWRXaXRoQW5jaG9yIiwib3Blbk9wdGlvbnMiLCJFbGVtZW50IiwiYW5jaG9yQmNyIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYW5jaG9yRG9tQ29udGVudCIsImZpcnN0RWxlbWVudENoaWxkIiwiY29udGVudEJjciIsImFuY2hvck9mZnNldFgiLCJhbmNob3JPZmZzZXRZIiwib3BlbiIsImNsb3NlIiwiRnJhZ21lbnQiLCJmb3JtYXRMb2NhdGlvbiIsImxvY2F0aW9uIiwiZm9ybWF0UGFyYW0iLCJzdHJpbmciLCJzbGljZSIsImFzc2VtYmxlTWFya2VyUGFyYW1zIiwibWFya2VycyIsIm1hcmtlclBhcmFtcyIsIm1hcmtlcnNCeVN0eWxlIiwicmVkdWNlIiwibGFiZWwiLCJzaXplIiwic2NhbGUiLCJpY29uIiwicmVsZXZhbnRQcm9wcyIsImZpbHRlciIsInZhbHVlcyIsImZvckVhY2giLCJtYXJrZXJQYXJhbSIsInJlbGV2YW50S2V5cyIsIlBBVEhfU1RZTEVfS0VZUyIsImJ1aWxkU3R5bGVQYXJhbXMiLCJwYXRoIiwic3R5bGVQYXJhbXMiLCJidWlsZENvb3JkaW5hdGVQYXJhbXMiLCJjb29yZGluYXRlcyIsImRlY29kZVVSSUNvbXBvbmVudCIsImFzc2VtYmxlUGF0aFBhcmFtcyIsInBhdGhzIiwiY29vcmRpbmF0ZVBhcmFtcyIsInBhdGhQYXJhbSIsImFzc2VtYmxlTWFwVHlwZVN0eWxlcyIsIm1hcFR5cGVTdHlsZSIsImZlYXR1cmVUeXBlIiwiZWxlbWVudFR5cGUiLCJzdHlsZXJzIiwic3R5bGVTdHJpbmciLCJzdHlsZXIiLCJTVEFUSUNfTUFQU19CQVNFIiwiY3JlYXRlU3RhdGljTWFwc1VybCIsImZvcm1hdCIsIm1hcFR5cGUiLCJ2aXNpYmxlIiwibWFwdHlwZSIsIm1hcF9pZCIsInVybCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsIlN0YXRpY01hcCIsIkNvbnRyb2xQb3NpdGlvbiIsIkJMT0NLX1NUQVJUX0lOTElORV9TVEFSVCIsIkJMT0NLX1NUQVJUX0lOTElORV9DRU5URVIiLCJCTE9DS19TVEFSVF9JTkxJTkVfRU5EIiwiSU5MSU5FX1NUQVJUX0JMT0NLX0NFTlRFUiIsIklOTElORV9TVEFSVF9CTE9DS19TVEFSVCIsIklOTElORV9TVEFSVF9CTE9DS19FTkQiLCJJTkxJTkVfRU5EX0JMT0NLX1NUQVJUIiwiSU5MSU5FX0VORF9CTE9DS19DRU5URVIiLCJJTkxJTkVfRU5EX0JMT0NLX0VORCIsIkJMT0NLX0VORF9JTkxJTkVfU1RBUlQiLCJCTE9DS19FTkRfSU5MSU5FX0NFTlRFUiIsIkJMT0NLX0VORF9JTkxJTkVfRU5EIiwiTWFwQ29udHJvbCIsImNvbnRyb2xDb250YWluZXIiLCJjb250cm9scyIsImNvbnRyb2xzQXJyYXkiLCJnZXRBcnJheSIsImluZGV4IiwicmVtb3ZlQXQiLCJ1c2VNYXJrZXIiLCJvbk1vdXNlT3ZlciIsIm9uTW91c2VPdXQiLCJtYXJrZXJPcHRpb25zIiwiTWFya2VyIiwiZ21lIiwic2V0RHJhZ2dhYmxlIiwic2V0UG9zaXRpb24iLCJ1c2VNYXJrZXJSZWYiLCJQaW4iLCJhZHZhbmNlZE1hcmtlciIsImdseXBoQ29udGFpbmVyIiwiZ2x5cGgiLCJwaW5WaWV3T3B0aW9ucyIsInBpbkVsZW1lbnQiLCJQaW5FbGVtZW50IiwibWFya2VyQ29udGVudCIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsIm1hcExpbmVhciIsImExIiwiYTIiLCJiMSIsImIyIiwiZ2V0TWFwTWF4VGlsdCIsImxpbWl0VGlsdFJhbmdlIiwiZ21ab29tIiwibWF4VGlsdCIsImZvdnkiLCJNYXRoIiwibWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Cprojects%5Cpropmubi%5Capps%5Cweb%5Capp%5Cprojects%5C%5Bid%5D%5Ctwin%5Cpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);