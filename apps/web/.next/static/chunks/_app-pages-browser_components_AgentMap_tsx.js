/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_components_AgentMap_tsx"],{

/***/ "(app-pages-browser)/./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// do not edit .js files directly - edit src/index.jst\nmodule.exports = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for(i = length; i-- !== 0;){\n            var key = keys[i];\n            if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxzREFBc0Q7QUFJdERBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxNQUFNQyxDQUFDLEVBQUVDLENBQUM7SUFDbEMsSUFBSUQsTUFBTUMsR0FBRyxPQUFPO0lBRXBCLElBQUlELEtBQUtDLEtBQUssT0FBT0QsS0FBSyxZQUFZLE9BQU9DLEtBQUssVUFBVTtRQUMxRCxJQUFJRCxFQUFFRSxXQUFXLEtBQUtELEVBQUVDLFdBQVcsRUFBRSxPQUFPO1FBRTVDLElBQUlDLFFBQVFDLEdBQUdDO1FBQ2YsSUFBSUMsTUFBTUMsT0FBTyxDQUFDUCxJQUFJO1lBQ3BCRyxTQUFTSCxFQUFFRyxNQUFNO1lBQ2pCLElBQUlBLFVBQVVGLEVBQUVFLE1BQU0sRUFBRSxPQUFPO1lBQy9CLElBQUtDLElBQUlELFFBQVFDLFFBQVEsR0FDdkIsSUFBSSxDQUFDTCxNQUFNQyxDQUFDLENBQUNJLEVBQUUsRUFBRUgsQ0FBQyxDQUFDRyxFQUFFLEdBQUcsT0FBTztZQUNqQyxPQUFPO1FBQ1Q7UUFJQSxJQUFJSixFQUFFRSxXQUFXLEtBQUtNLFFBQVEsT0FBT1IsRUFBRVMsTUFBTSxLQUFLUixFQUFFUSxNQUFNLElBQUlULEVBQUVVLEtBQUssS0FBS1QsRUFBRVMsS0FBSztRQUNqRixJQUFJVixFQUFFVyxPQUFPLEtBQUtDLE9BQU9DLFNBQVMsQ0FBQ0YsT0FBTyxFQUFFLE9BQU9YLEVBQUVXLE9BQU8sT0FBT1YsRUFBRVUsT0FBTztRQUM1RSxJQUFJWCxFQUFFYyxRQUFRLEtBQUtGLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxFQUFFLE9BQU9kLEVBQUVjLFFBQVEsT0FBT2IsRUFBRWEsUUFBUTtRQUVoRlQsT0FBT08sT0FBT1AsSUFBSSxDQUFDTDtRQUNuQkcsU0FBU0UsS0FBS0YsTUFBTTtRQUNwQixJQUFJQSxXQUFXUyxPQUFPUCxJQUFJLENBQUNKLEdBQUdFLE1BQU0sRUFBRSxPQUFPO1FBRTdDLElBQUtDLElBQUlELFFBQVFDLFFBQVEsR0FDdkIsSUFBSSxDQUFDUSxPQUFPQyxTQUFTLENBQUNFLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDZixHQUFHSSxJQUFJLENBQUNELEVBQUUsR0FBRyxPQUFPO1FBRWhFLElBQUtBLElBQUlELFFBQVFDLFFBQVEsR0FBSTtZQUMzQixJQUFJYSxNQUFNWixJQUFJLENBQUNELEVBQUU7WUFFakIsSUFBSSxDQUFDTCxNQUFNQyxDQUFDLENBQUNpQixJQUFJLEVBQUVoQixDQUFDLENBQUNnQixJQUFJLEdBQUcsT0FBTztRQUNyQztRQUVBLE9BQU87SUFDVDtJQUVBLG9DQUFvQztJQUNwQyxPQUFPakIsTUFBSUEsS0FBS0MsTUFBSUE7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcz8wYmM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJlcXVhbCIsImEiLCJiIiwiY29uc3RydWN0b3IiLCJsZW5ndGgiLCJpIiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsIlJlZ0V4cCIsInNvdXJjZSIsImZsYWdzIiwidmFsdWVPZiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fast-deep-equal/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/client-only/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIoYXBwLXBhZ2VzLWJyb3dzZXIpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jbGllbnQtb25seS9pbmRleC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JB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c3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/AgentMap.tsx":
/*!*********************************!*\
  !*** ./components/AgentMap.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AgentMap; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(app-pages-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vis.gl/react-google-maps */ \"(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n// Hyderabad/Tellapur Region\nconst CENTER = {\n    lat: 17.46,\n    lng: 78.29\n};\nconst POLYGON_PATH = [\n    {\n        lat: 17.46,\n        lng: 78.29\n    },\n    {\n        lat: 17.465,\n        lng: 78.295\n    },\n    {\n        lat: 17.47,\n        lng: 78.29\n    },\n    {\n        lat: 17.465,\n        lng: 78.28\n    }\n];\nfunction AgentMap(param) {\n    let { leads, supply } = param;\n    var _selectedMarker_property_details, _selectedMarker_property_details_price, _selectedMarker_property_details1;\n    _s();\n    const [selectedMarker, setSelectedMarker] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const apiKey = \"AIzaSyDFsyNYExhBjsFFvVfBkWAIwdLQyZXq67w\" || 0;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\"\n        },\n        className: \"jsx-d8dad946ad24a713\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"absolute\",\n                    top: 20,\n                    left: \"50%\",\n                    transform: \"translateX(-50%)\",\n                    zIndex: 100,\n                    background: \"linear-gradient(90deg, #c0392b 0%, #e74c3c 100%)\",\n                    color: \"white\",\n                    padding: \"10px 40px\",\n                    borderRadius: 30,\n                    boxShadow: \"0 10px 20px rgba(0,0,0,0.3)\",\n                    fontWeight: \"bold\",\n                    fontSize: 18,\n                    display: \"flex\",\n                    alignItems: \"center\",\n                    gap: 10\n                },\n                className: \"jsx-d8dad946ad24a713\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"jsx-d8dad946ad24a713\" + \" \" + \"pulse-dot\",\n                        children: \"\\uD83D\\uDD34\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                        lineNumber: 39,\n                        columnNumber: 17\n                    }, this),\n                    \" LIVE INTEL: 42 New Signals in Tellapur\"\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                lineNumber: 22,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.APIProvider, {\n                apiKey: apiKey,\n                onLoad: ()=>console.log(\"Maps Loaded\"),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.Map, {\n                    defaultCenter: CENTER,\n                    defaultZoom: 13,\n                    mapId: \"DEMO_MAP_ID\" // Required for AdvancedMarker\n                    ,\n                    style: {\n                        width: \"100%\",\n                        height: \"100%\"\n                    },\n                    gestureHandling: \"greedy\",\n                    disableDefaultUI: false,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PolygonLayer, {}, void 0, false, {\n                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                            lineNumber: 51,\n                            columnNumber: 21\n                        }, this),\n                        supply.map((item, i)=>{\n                            const lat = 17.46 + (Math.random() * 0.02 - 0.01);\n                            const lng = 78.29 + (Math.random() * 0.02 - 0.01);\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.AdvancedMarker, {\n                                position: {\n                                    lat,\n                                    lng\n                                },\n                                onClick: ()=>setSelectedMarker({\n                                        ...item,\n                                        type: \"supply\",\n                                        lat,\n                                        lng\n                                    }),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.Pin, {\n                                    background: \"#2ecc71\",\n                                    borderColor: \"#27ae60\",\n                                    glyphColor: \"#fff\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                    lineNumber: 63,\n                                    columnNumber: 33\n                                }, this)\n                            }, i, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                lineNumber: 58,\n                                columnNumber: 29\n                            }, this);\n                        }),\n                        leads.map((lead, i)=>{\n                            const lat = 17.46 + (Math.random() * 0.02 - 0.01);\n                            const lng = 78.29 + (Math.random() * 0.02 - 0.01);\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.AdvancedMarker, {\n                                position: {\n                                    lat,\n                                    lng\n                                },\n                                onClick: ()=>setSelectedMarker({\n                                        ...lead,\n                                        type: \"lead\",\n                                        lat,\n                                        lng\n                                    }),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.Pin, {\n                                    background: \"#3498db\",\n                                    borderColor: \"#2980b9\",\n                                    glyphColor: \"#fff\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                    lineNumber: 78,\n                                    columnNumber: 33\n                                }, this)\n                            }, \"lead-\".concat(i), false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                lineNumber: 73,\n                                columnNumber: 29\n                            }, this);\n                        }),\n                        selectedMarker && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.InfoWindow, {\n                            position: {\n                                lat: selectedMarker.lat,\n                                lng: selectedMarker.lng\n                            },\n                            onCloseClick: ()=>setSelectedMarker(null),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    color: \"black\",\n                                    padding: 5\n                                },\n                                className: \"jsx-d8dad946ad24a713\",\n                                children: selectedMarker.type === \"supply\" ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            className: \"jsx-d8dad946ad24a713\",\n                                            children: (_selectedMarker_property_details = selectedMarker.property_details) === null || _selectedMarker_property_details === void 0 ? void 0 : _selectedMarker_property_details.property_name\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                            lineNumber: 91,\n                                            columnNumber: 41\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {\n                                            className: \"jsx-d8dad946ad24a713\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                            lineNumber: 91,\n                                            columnNumber: 106\n                                        }, this),\n                                        \"â‚¹ \",\n                                        (_selectedMarker_property_details1 = selectedMarker.property_details) === null || _selectedMarker_property_details1 === void 0 ? void 0 : (_selectedMarker_property_details_price = _selectedMarker_property_details1.price) === null || _selectedMarker_property_details_price === void 0 ? void 0 : _selectedMarker_property_details_price.toLocaleString()\n                                    ]\n                                }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            className: \"jsx-d8dad946ad24a713\",\n                                            children: [\n                                                \"Buyer: \",\n                                                selectedMarker.buyer_id\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                            lineNumber: 96,\n                                            columnNumber: 41\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {\n                                            className: \"jsx-d8dad946ad24a713\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                            lineNumber: 96,\n                                            columnNumber: 90\n                                        }, this),\n                                        \"Status: \",\n                                        selectedMarker.status\n                                    ]\n                                }, void 0, true)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                                lineNumber: 88,\n                                columnNumber: 29\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                            lineNumber: 84,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                    lineNumber: 43,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n                lineNumber: 42,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"d8dad946ad24a713\",\n                children: \"@-webkit-keyframes pulse{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}50%{-webkit-transform:scale(1.2);transform:scale(1.2);opacity:.7}100%{-webkit-transform:scale(1);transform:scale(1);opacity:1}}@-moz-keyframes pulse{0%{-moz-transform:scale(1);transform:scale(1);opacity:1}50%{-moz-transform:scale(1.2);transform:scale(1.2);opacity:.7}100%{-moz-transform:scale(1);transform:scale(1);opacity:1}}@-o-keyframes pulse{0%{-o-transform:scale(1);transform:scale(1);opacity:1}50%{-o-transform:scale(1.2);transform:scale(1.2);opacity:.7}100%{-o-transform:scale(1);transform:scale(1);opacity:1}}@keyframes pulse{0%{-webkit-transform:scale(1);-moz-transform:scale(1);-o-transform:scale(1);transform:scale(1);opacity:1}50%{-webkit-transform:scale(1.2);-moz-transform:scale(1.2);-o-transform:scale(1.2);transform:scale(1.2);opacity:.7}100%{-webkit-transform:scale(1);-moz-transform:scale(1);-o-transform:scale(1);transform:scale(1);opacity:1}}.pulse-dot{display:inline-block;-webkit-animation:pulse 1.5s infinite;-moz-animation:pulse 1.5s infinite;-o-animation:pulse 1.5s infinite;animation:pulse 1.5s infinite}\"\n            }, void 0, false, void 0, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\projects\\\\propmubi\\\\apps\\\\web\\\\components\\\\AgentMap.tsx\",\n        lineNumber: 20,\n        columnNumber: 9\n    }, this);\n}\n_s(AgentMap, \"oar+iP7gTM7tKhZHtq+2gG1qrA4=\");\n_c = AgentMap;\nfunction PolygonLayer() {\n    _s1();\n    const map = (0,_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.useMap)();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (!map) return;\n        // Create the Google Maps Polygon\n        const polygon = new google.maps.Polygon({\n            paths: POLYGON_PATH,\n            strokeColor: \"#FF0000\",\n            strokeOpacity: 0.8,\n            strokeWeight: 2,\n            fillColor: \"#FF0000\",\n            fillOpacity: 0.15,\n            editable: false,\n            draggable: false\n        });\n        polygon.setMap(map);\n        // Animation Loop (Pulse fill opacity)\n        let direction = 1;\n        let opacity = 0.15;\n        const interval = setInterval(()=>{\n            opacity += 0.02 * direction;\n            if (opacity > 0.4 || opacity < 0.1) direction *= -1;\n            polygon.setOptions({\n                fillOpacity: opacity\n            });\n        }, 100);\n        return ()=>{\n            clearInterval(interval);\n            polygon.setMap(null);\n        };\n    }, [\n        map\n    ]);\n    return null;\n}\n_s1(PolygonLayer, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function() {\n    return [\n        _vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_3__.useMap\n    ];\n});\n_c1 = PolygonLayer;\nvar _c, _c1;\n$RefreshReg$(_c, \"AgentMap\");\n$RefreshReg$(_c1, \"PolygonLayer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQWdlbnRNYXAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFZ0U7QUFDc0M7QUFFdEcsNEJBQTRCO0FBQzVCLE1BQU1TLFNBQVM7SUFBRUMsS0FBSztJQUFPQyxLQUFLO0FBQU07QUFDeEMsTUFBTUMsZUFBZTtJQUNqQjtRQUFFRixLQUFLO1FBQU9DLEtBQUs7SUFBTTtJQUN6QjtRQUFFRCxLQUFLO1FBQVFDLEtBQUs7SUFBTztJQUMzQjtRQUFFRCxLQUFLO1FBQU9DLEtBQUs7SUFBTTtJQUN6QjtRQUFFRCxLQUFLO1FBQVFDLEtBQUs7SUFBTTtDQUM3QjtBQUVjLFNBQVNFLFNBQVMsS0FBc0I7UUFBdEIsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQU8sR0FBdEI7UUE0RWdCQyxrQ0FDTkEsd0NBQUFBOztJQTVFdkMsTUFBTSxDQUFDQSxnQkFBZ0JDLGtCQUFrQixHQUFHZiwrQ0FBUUEsQ0FBTTtJQUMxRCxNQUFNZ0IsU0FBU0MseUNBQXVDLElBQUksQ0FBRTtJQUU1RCxxQkFDSSw4REFBQ0c7UUFBSUMsT0FBTztZQUFFQyxVQUFVO1lBQVlDLE9BQU87WUFBUUMsUUFBUTtRQUFPOzs7MEJBRTlELDhEQUFDSjtnQkFBSUMsT0FBTztvQkFDUkMsVUFBVTtvQkFDVkcsS0FBSztvQkFDTEMsTUFBTTtvQkFDTkMsV0FBVztvQkFDWEMsUUFBUTtvQkFDUkMsWUFBWTtvQkFDWkMsT0FBTztvQkFDUEMsU0FBUztvQkFDVEMsY0FBYztvQkFDZEMsV0FBVztvQkFDWEMsWUFBWTtvQkFDWkMsVUFBVTtvQkFDVkMsU0FBUztvQkFDVEMsWUFBWTtvQkFDWkMsS0FBSztnQkFDVDs7O2tDQUNJLDhEQUFDQztrRUFBZTtrQ0FBWTs7Ozs7O29CQUFTOzs7Ozs7OzBCQUd6Qyw4REFBQ3RDLGtFQUFXQTtnQkFBQ2UsUUFBUUE7Z0JBQVF3QixRQUFRLElBQU1DLFFBQVFDLEdBQUcsQ0FBQzswQkFDbkQsNEVBQUN4Qyww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TUFBTUMsV0FBV0MsWUFBWTtZQUN6QkYsV0FBVyxPQUFPRDtZQUNsQixJQUFJQyxVQUFVLE9BQU9BLFVBQVUsS0FBS0QsYUFBYSxDQUFDO1lBQ2xEYixRQUFRaUIsVUFBVSxDQUFDO2dCQUFFUixhQUFhSztZQUFRO1FBQzlDLEdBQUc7UUFFSCxPQUFPO1lBQ0hJLGNBQWNIO1lBQ2RmLFFBQVFZLE1BQU0sQ0FBQztRQUNuQjtJQUNKLEdBQUc7UUFBQy9CO0tBQUk7SUFFUixPQUFPO0FBQ1g7SUFwQ1NEOztRQUNPMUMsNkRBQU1BOzs7TUFEYjBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQWdlbnRNYXAudHN4P2YwODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEFQSVByb3ZpZGVyLCBNYXAsIEFkdmFuY2VkTWFya2VyLCBQaW4sIEluZm9XaW5kb3csIHVzZU1hcCB9IGZyb20gJ0B2aXMuZ2wvcmVhY3QtZ29vZ2xlLW1hcHMnO1xyXG5cclxuLy8gSHlkZXJhYmFkL1RlbGxhcHVyIFJlZ2lvblxyXG5jb25zdCBDRU5URVIgPSB7IGxhdDogMTcuNDYsIGxuZzogNzguMjkgfTtcclxuY29uc3QgUE9MWUdPTl9QQVRIID0gW1xyXG4gICAgeyBsYXQ6IDE3LjQ2LCBsbmc6IDc4LjI5IH0sXHJcbiAgICB7IGxhdDogMTcuNDY1LCBsbmc6IDc4LjI5NSB9LFxyXG4gICAgeyBsYXQ6IDE3LjQ3LCBsbmc6IDc4LjI5IH0sXHJcbiAgICB7IGxhdDogMTcuNDY1LCBsbmc6IDc4LjI4IH0sXHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBZ2VudE1hcCh7IGxlYWRzLCBzdXBwbHkgfTogYW55KSB7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRNYXJrZXIsIHNldFNlbGVjdGVkTWFya2VyXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcbiAgICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfTUFQU19LRVkgfHwgXCJcIjtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgcG9zaXRpb246ICdyZWxhdGl2ZScsIHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICB7LyogTEFSR0UgQkFOTkVSIE9WRVJMQVkgKi99XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgdG9wOiAyMCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKScsXHJcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMCxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdsaW5lYXItZ3JhZGllbnQoOTBkZWcsICNjMDM5MmIgMCUsICNlNzRjM2MgMTAwJSknLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMTBweCA0MHB4JyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMzAsXHJcbiAgICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDEwcHggMjBweCByZ2JhKDAsMCwwLDAuMyknLFxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE4LFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxyXG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICBnYXA6IDEwXHJcbiAgICAgICAgICAgIH19PlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicHVsc2UtZG90XCI+8J+UtDwvc3Bhbj4gTElWRSBJTlRFTDogNDIgTmV3IFNpZ25hbHMgaW4gVGVsbGFwdXJcclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8QVBJUHJvdmlkZXIgYXBpS2V5PXthcGlLZXl9IG9uTG9hZD17KCkgPT4gY29uc29sZS5sb2coJ01hcHMgTG9hZGVkJyl9PlxyXG4gICAgICAgICAgICAgICAgPE1hcFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDZW50ZXI9e0NFTlRFUn1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Wm9vbT17MTN9XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwSWQ9XCJERU1PX01BUF9JRFwiIC8vIFJlcXVpcmVkIGZvciBBZHZhbmNlZE1hcmtlclxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH19XHJcbiAgICAgICAgICAgICAgICAgICAgZ2VzdHVyZUhhbmRsaW5nPXsnZ3JlZWR5J31cclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlRGVmYXVsdFVJPXtmYWxzZX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8UG9seWdvbkxheWVyIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHsvKiBTdXBwbHkgTWFya2VycyAqL31cclxuICAgICAgICAgICAgICAgICAgICB7c3VwcGx5Lm1hcCgoaXRlbTogYW55LCBpOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ID0gMTcuNDYgKyAoTWF0aC5yYW5kb20oKSAqIDAuMDIgLSAwLjAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG5nID0gNzguMjkgKyAoTWF0aC5yYW5kb20oKSAqIDAuMDIgLSAwLjAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxBZHZhbmNlZE1hcmtlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbj17eyBsYXQsIGxuZyB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkTWFya2VyKHsgLi4uaXRlbSwgdHlwZTogJ3N1cHBseScsIGxhdCwgbG5nIH0pfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQaW4gYmFja2dyb3VuZD17JyMyZWNjNzEnfSBib3JkZXJDb2xvcj17JyMyN2FlNjAnfSBnbHlwaENvbG9yPXsnI2ZmZid9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0FkdmFuY2VkTWFya2VyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7LyogTGVhZCBNYXJrZXJzICovfVxyXG4gICAgICAgICAgICAgICAgICAgIHtsZWFkcy5tYXAoKGxlYWQ6IGFueSwgaTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhdCA9IDE3LjQ2ICsgKE1hdGgucmFuZG9tKCkgKiAwLjAyIC0gMC4wMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxuZyA9IDc4LjI5ICsgKE1hdGgucmFuZG9tKCkgKiAwLjAyIC0gMC4wMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QWR2YW5jZWRNYXJrZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2BsZWFkLSR7aX1gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uPXt7IGxhdCwgbG5nIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRNYXJrZXIoeyAuLi5sZWFkLCB0eXBlOiAnbGVhZCcsIGxhdCwgbG5nIH0pfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQaW4gYmFja2dyb3VuZD17JyMzNDk4ZGInfSBib3JkZXJDb2xvcj17JyMyOTgwYjknfSBnbHlwaENvbG9yPXsnI2ZmZid9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0FkdmFuY2VkTWFya2VyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7c2VsZWN0ZWRNYXJrZXIgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SW5mb1dpbmRvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb249e3sgbGF0OiBzZWxlY3RlZE1hcmtlci5sYXQsIGxuZzogc2VsZWN0ZWRNYXJrZXIubG5nIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkTWFya2VyKG51bGwpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGNvbG9yOiAnYmxhY2snLCBwYWRkaW5nOiA1IH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzZWxlY3RlZE1hcmtlci50eXBlID09PSAnc3VwcGx5JyA/IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+e3NlbGVjdGVkTWFya2VyLnByb3BlcnR5X2RldGFpbHM/LnByb3BlcnR5X25hbWV9PC9zdHJvbmc+PGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDigrkge3NlbGVjdGVkTWFya2VyLnByb3BlcnR5X2RldGFpbHM/LnByaWNlPy50b0xvY2FsZVN0cmluZygpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz5CdXllcjoge3NlbGVjdGVkTWFya2VyLmJ1eWVyX2lkfTwvc3Ryb25nPjxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RhdHVzOiB7c2VsZWN0ZWRNYXJrZXIuc3RhdHVzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvSW5mb1dpbmRvdz5cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9NYXA+XHJcbiAgICAgICAgICAgIDwvQVBJUHJvdmlkZXI+XHJcblxyXG4gICAgICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57YFxyXG4gICAgICAgICAgICAgICAgQGtleWZyYW1lcyBwdWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgMCUgeyB0cmFuc2Zvcm06IHNjYWxlKDEpOyBvcGFjaXR5OiAxOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgNTAlIHsgdHJhbnNmb3JtOiBzY2FsZSgxLjIpOyBvcGFjaXR5OiAwLjc7IH1cclxuICAgICAgICAgICAgICAgICAgICAxMDAlIHsgdHJhbnNmb3JtOiBzY2FsZSgxKTsgb3BhY2l0eTogMTsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLnB1bHNlLWRvdCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogcHVsc2UgMS41cyBpbmZpbml0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYH08L3N0eWxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gUG9seWdvbkxheWVyKCkge1xyXG4gICAgY29uc3QgbWFwID0gdXNlTWFwKCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIW1hcCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIEdvb2dsZSBNYXBzIFBvbHlnb25cclxuICAgICAgICBjb25zdCBwb2x5Z29uID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlnb24oe1xyXG4gICAgICAgICAgICBwYXRoczogUE9MWUdPTl9QQVRILFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogXCIjRkYwMDAwXCIsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuOCxcclxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IFwiI0ZGMDAwMFwiLFxyXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4xNSxcclxuICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHBvbHlnb24uc2V0TWFwKG1hcCk7XHJcblxyXG4gICAgICAgIC8vIEFuaW1hdGlvbiBMb29wIChQdWxzZSBmaWxsIG9wYWNpdHkpXHJcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgbGV0IG9wYWNpdHkgPSAwLjE1O1xyXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICBvcGFjaXR5ICs9IDAuMDIgKiBkaXJlY3Rpb247XHJcbiAgICAgICAgICAgIGlmIChvcGFjaXR5ID4gMC40IHx8IG9wYWNpdHkgPCAwLjEpIGRpcmVjdGlvbiAqPSAtMTtcclxuICAgICAgICAgICAgcG9seWdvbi5zZXRPcHRpb25zKHsgZmlsbE9wYWNpdHk6IG9wYWNpdHkgfSk7XHJcbiAgICAgICAgfSwgMTAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIHBvbHlnb24uc2V0TWFwKG51bGwpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbbWFwXSk7XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJBUElQcm92aWRlciIsIk1hcCIsIkFkdmFuY2VkTWFya2VyIiwiUGluIiwiSW5mb1dpbmRvdyIsInVzZU1hcCIsIkNFTlRFUiIsImxhdCIsImxuZyIsIlBPTFlHT05fUEFUSCIsIkFnZW50TWFwIiwibGVhZHMiLCJzdXBwbHkiLCJzZWxlY3RlZE1hcmtlciIsInNldFNlbGVjdGVkTWFya2VyIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dPT0dMRV9NQVBTX0tFWSIsImRpdiIsInN0eWxlIiwicG9zaXRpb24iLCJ3aWR0aCIsImhlaWdodCIsInRvcCIsImxlZnQiLCJ0cmFuc2Zvcm0iLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kIiwiY29sb3IiLCJwYWRkaW5nIiwiYm9yZGVyUmFkaXVzIiwiYm94U2hhZG93IiwiZm9udFdlaWdodCIsImZvbnRTaXplIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJnYXAiLCJzcGFuIiwib25Mb2FkIiwiY29uc29sZSIsImxvZyIsImRlZmF1bHRDZW50ZXIiLCJkZWZhdWx0Wm9vbSIsIm1hcElkIiwiZ2VzdHVyZUhhbmRsaW5nIiwiZGlzYWJsZURlZmF1bHRVSSIsIlBvbHlnb25MYXllciIsIm1hcCIsIml0ZW0iLCJpIiwiTWF0aCIsInJhbmRvbSIsIm9uQ2xpY2siLCJ0eXBlIiwiYm9yZGVyQ29sb3IiLCJnbHlwaENvbG9yIiwibGVhZCIsIm9uQ2xvc2VDbGljayIsInN0cm9uZyIsInByb3BlcnR5X2RldGFpbHMiLCJwcm9wZXJ0eV9uYW1lIiwiYnIiLCJwcmljZSIsInRvTG9jYWxlU3RyaW5nIiwiYnV5ZXJfaWQiLCJzdGF0dXMiLCJwb2x5Z29uIiwiZ29vZ2xlIiwibWFwcyIsIlBvbHlnb24iLCJwYXRocyIsInN0cm9rZUNvbG9yIiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdlaWdodCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiZWRpdGFibGUiLCJkcmFnZ2FibGUiLCJzZXRNYXAiLCJkaXJlY3Rpb24iLCJvcGFjaXR5IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInNldE9wdGlvbnMiLCJjbGVhckludGVydmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/AgentMap.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n__webpack_require__(/*! client-only */ \"(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\n_c = React__default;\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/ function _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar isProd = typeof process !== \"undefined\" && process.env && \"development\" === \"production\";\nvar isString = function(o) {\n    return Object.prototype.toString.call(o) === \"[object String]\";\n};\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(param) {\n        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? \"stylesheet\" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;\n        invariant$1(isString(name), \"`name` must be a string\");\n        this._name = name;\n        this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n        invariant$1(typeof optimizeForSpeed === \"boolean\", \"`optimizeForSpeed` must be a boolean\");\n        this._optimizeForSpeed = optimizeForSpeed;\n        this._serverSheet = undefined;\n        this._tags = [];\n        this._injected = false;\n        this._rulesCount = 0;\n        var node =  true && document.querySelector('meta[property=\"csp-nonce\"]');\n        this._nonce = node ? node.getAttribute(\"content\") : null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n        invariant$1(typeof bool === \"boolean\", \"`setOptimizeForSpeed` accepts a boolean\");\n        invariant$1(this._rulesCount === 0, \"optimizeForSpeed cannot be when rules have already been inserted\");\n        this.flush();\n        this._optimizeForSpeed = bool;\n        this.inject();\n    };\n    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n        return this._optimizeForSpeed;\n    };\n    _proto.inject = function inject() {\n        var _this = this;\n        invariant$1(!this._injected, \"sheet already injected\");\n        this._injected = true;\n        if ( true && this._optimizeForSpeed) {\n            this._tags[0] = this.makeStyleTag(this._name);\n            this._optimizeForSpeed = \"insertRule\" in this.getSheet();\n            if (!this._optimizeForSpeed) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.\");\n                }\n                this.flush();\n                this._injected = true;\n            }\n            return;\n        }\n        this._serverSheet = {\n            cssRules: [],\n            insertRule: function(rule, index) {\n                if (typeof index === \"number\") {\n                    _this._serverSheet.cssRules[index] = {\n                        cssText: rule\n                    };\n                } else {\n                    _this._serverSheet.cssRules.push({\n                        cssText: rule\n                    });\n                }\n                return index;\n            },\n            deleteRule: function(index) {\n                _this._serverSheet.cssRules[index] = null;\n            }\n        };\n    };\n    _proto.getSheetForTag = function getSheetForTag(tag) {\n        if (tag.sheet) {\n            return tag.sheet;\n        }\n        // this weirdness brought to you by firefox\n        for(var i = 0; i < document.styleSheets.length; i++){\n            if (document.styleSheets[i].ownerNode === tag) {\n                return document.styleSheets[i];\n            }\n        }\n    };\n    _proto.getSheet = function getSheet() {\n        return this.getSheetForTag(this._tags[this._tags.length - 1]);\n    };\n    _proto.insertRule = function insertRule(rule, index) {\n        invariant$1(isString(rule), \"`insertRule` accepts only strings\");\n        if (false) {}\n        if (this._optimizeForSpeed) {\n            var sheet = this.getSheet();\n            if (typeof index !== \"number\") {\n                index = sheet.cssRules.length;\n            }\n            // this weirdness for perf, and chrome's weird bug\n            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                return -1;\n            }\n        } else {\n            var insertionPoint = this._tags[index];\n            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n        }\n        return this._rulesCount++;\n    };\n    _proto.replaceRule = function replaceRule(index, rule) {\n        if (this._optimizeForSpeed || \"object\" === \"undefined\") {\n            var sheet =  true ? this.getSheet() : 0;\n            if (!rule.trim()) {\n                rule = this._deletedRulePlaceholder;\n            }\n            if (!sheet.cssRules[index]) {\n                // @TBD Should we throw an error?\n                return index;\n            }\n            sheet.deleteRule(index);\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                // In order to preserve the indices we insert a deleteRulePlaceholder\n                sheet.insertRule(this._deletedRulePlaceholder, index);\n            }\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"old rule at index `\" + index + \"` not found\");\n            tag.textContent = rule;\n        }\n        return index;\n    };\n    _proto.deleteRule = function deleteRule(index) {\n        if (false) {}\n        if (this._optimizeForSpeed) {\n            this.replaceRule(index, \"\");\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"rule at index `\" + index + \"` not found\");\n            tag.parentNode.removeChild(tag);\n            this._tags[index] = null;\n        }\n    };\n    _proto.flush = function flush() {\n        this._injected = false;\n        this._rulesCount = 0;\n        if (true) {\n            this._tags.forEach(function(tag) {\n                return tag && tag.parentNode.removeChild(tag);\n            });\n            this._tags = [];\n        } else {}\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        if (false) {}\n        return this._tags.reduce(function(rules, tag) {\n            if (tag) {\n                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {\n                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;\n                }));\n            } else {\n                rules.push(null);\n            }\n            return rules;\n        }, []);\n    };\n    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n        if (cssString) {\n            invariant$1(isString(cssString), \"makeStyleTag accepts only strings as second parameter\");\n        }\n        var tag = document.createElement(\"style\");\n        if (this._nonce) tag.setAttribute(\"nonce\", this._nonce);\n        tag.type = \"text/css\";\n        tag.setAttribute(\"data-\" + name, \"\");\n        if (cssString) {\n            tag.appendChild(document.createTextNode(cssString));\n        }\n        var head = document.head || document.getElementsByTagName(\"head\")[0];\n        if (relativeToTag) {\n            head.insertBefore(tag, relativeToTag);\n        } else {\n            head.appendChild(tag);\n        }\n        return tag;\n    };\n    _createClass(StyleSheet, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this._rulesCount;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\nfunction invariant$1(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheet: \" + message + \".\");\n    }\n}\nfunction hash(str) {\n    var _$hash = 5381, i = str.length;\n    while(i){\n        _$hash = _$hash * 33 ^ str.charCodeAt(--i);\n    }\n    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;\n}\nvar stringHash = hash;\nvar sanitize = function(rule) {\n    return rule.replace(/\\/style/gi, \"\\\\/style\");\n};\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */ function computeId(baseId, props) {\n    if (!props) {\n        return \"jsx-\" + baseId;\n    }\n    var propsToString = String(props);\n    var key = baseId + propsToString;\n    if (!cache[key]) {\n        cache[key] = \"jsx-\" + stringHash(baseId + \"-\" + propsToString);\n    }\n    return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */ function computeSelector(id, css) {\n    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;\n    // Sanitize SSR-ed CSS.\n    // Client side code doesn't need to be sanitized since we use\n    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n    if (false) {}\n    var idcss = id + css;\n    if (!cache[idcss]) {\n        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n    }\n    return cache[idcss];\n}\nfunction mapRulesToStyle(cssRules, options) {\n    if (options === void 0) options = {};\n    return cssRules.map(function(args) {\n        var id = args[0];\n        var css = args[1];\n        return /*#__PURE__*/ React__default[\"default\"].createElement(\"style\", {\n            id: \"__\" + id,\n            // Avoid warnings upon render with a key\n            key: \"__\" + id,\n            nonce: options.nonce ? options.nonce : undefined,\n            dangerouslySetInnerHTML: {\n                __html: css\n            }\n        });\n    });\n}\nvar StyleSheetRegistry = /*#__PURE__*/ function() {\n    function StyleSheetRegistry(param) {\n        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;\n        this._sheet = styleSheet || new StyleSheet({\n            name: \"styled-jsx\",\n            optimizeForSpeed: optimizeForSpeed\n        });\n        this._sheet.inject();\n        if (styleSheet && typeof optimizeForSpeed === \"boolean\") {\n            this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    }\n    var _proto = StyleSheetRegistry.prototype;\n    _proto.add = function add(props) {\n        var _this = this;\n        if (undefined === this._optimizeForSpeed) {\n            this._optimizeForSpeed = Array.isArray(props.children);\n            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        if ( true && !this._fromServer) {\n            this._fromServer = this.selectFromServer();\n            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {\n                acc[tagName] = 0;\n                return acc;\n            }, {});\n        }\n        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;\n        // Deduping: just increase the instances count.\n        if (styleId in this._instancesCounts) {\n            this._instancesCounts[styleId] += 1;\n            return;\n        }\n        var indices = rules.map(function(rule) {\n            return _this._sheet.insertRule(rule);\n        }) // Filter out invalid rules\n        .filter(function(index) {\n            return index !== -1;\n        });\n        this._indices[styleId] = indices;\n        this._instancesCounts[styleId] = 1;\n    };\n    _proto.remove = function remove(props) {\n        var _this = this;\n        var styleId = this.getIdAndRules(props).styleId;\n        invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n        this._instancesCounts[styleId] -= 1;\n        if (this._instancesCounts[styleId] < 1) {\n            var tagFromServer = this._fromServer && this._fromServer[styleId];\n            if (tagFromServer) {\n                tagFromServer.parentNode.removeChild(tagFromServer);\n                delete this._fromServer[styleId];\n            } else {\n                this._indices[styleId].forEach(function(index) {\n                    return _this._sheet.deleteRule(index);\n                });\n                delete this._indices[styleId];\n            }\n            delete this._instancesCounts[styleId];\n        }\n    };\n    _proto.update = function update(props, nextProps) {\n        this.add(nextProps);\n        this.remove(props);\n    };\n    _proto.flush = function flush() {\n        this._sheet.flush();\n        this._sheet.inject();\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {\n            return [\n                styleId,\n                _this._fromServer[styleId]\n            ];\n        }) : [];\n        var cssRules = this._sheet.cssRules();\n        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {\n            return [\n                styleId,\n                _this._indices[styleId].map(function(index) {\n                    return cssRules[index].cssText;\n                }).join(_this._optimizeForSpeed ? \"\" : \"\\n\")\n            ];\n        }) // filter out empty rules\n        .filter(function(rule) {\n            return Boolean(rule[1]);\n        }));\n    };\n    _proto.styles = function styles(options) {\n        return mapRulesToStyle(this.cssRules(), options);\n    };\n    _proto.getIdAndRules = function getIdAndRules(props) {\n        var css = props.children, dynamic = props.dynamic, id = props.id;\n        if (dynamic) {\n            var styleId = computeId(id, dynamic);\n            return {\n                styleId: styleId,\n                rules: Array.isArray(css) ? css.map(function(rule) {\n                    return computeSelector(styleId, rule);\n                }) : [\n                    computeSelector(styleId, css)\n                ]\n            };\n        }\n        return {\n            styleId: computeId(id),\n            rules: Array.isArray(css) ? css : [\n                css\n            ]\n        };\n    };\n    /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */ _proto.selectFromServer = function selectFromServer() {\n        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n        return elements.reduce(function(acc, element) {\n            var id = element.id.slice(2);\n            acc[id] = element;\n            return acc;\n        }, {});\n    };\n    return StyleSheetRegistry;\n}();\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n    }\n}\nvar StyleSheetContext = /*#__PURE__*/ React.createContext(null);\nStyleSheetContext.displayName = \"StyleSheetContext\";\nfunction createStyleRegistry() {\n    return new StyleSheetRegistry();\n}\nfunction StyleRegistry(param) {\n    _s();\n    var configuredRegistry = param.registry, children = param.children;\n    var rootRegistry = React.useContext(StyleSheetContext);\n    var ref = React.useState(function() {\n        return rootRegistry || configuredRegistry || createStyleRegistry();\n    }), registry = ref[0];\n    return /*#__PURE__*/ React__default[\"default\"].createElement(StyleSheetContext.Provider, {\n        value: registry\n    }, children);\n}\n_s(StyleRegistry, \"vgRS4YV7PcSMQCYHzGaNuBIBcZQ=\");\n_c1 = StyleRegistry;\nfunction useStyleRegistry() {\n    _s1();\n    return React.useContext(StyleSheetContext);\n}\n_s1(useStyleRegistry, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = React__default[\"default\"].useInsertionEffect || React__default[\"default\"].useLayoutEffect;\nvar defaultRegistry =  true ? createStyleRegistry() : 0;\nfunction JSXStyle(props) {\n    _s2();\n    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();\n    // If `registry` does not exist, we do nothing here.\n    if (!registry) {\n        return null;\n    }\n    if (false) {}\n    useInsertionEffect(function() {\n        registry.add(props);\n        return function() {\n            registry.remove(props);\n        };\n    // props.children can be string[], will be striped since id is identical\n    }, [\n        props.id,\n        String(props.dynamic)\n    ]);\n    return null;\n}\n_s2(JSXStyle, \"48Sqj1BUqkshsPdz6NEWXDn8pF4=\", false, function() {\n    return [\n        useStyleRegistry,\n        useInsertionEffect\n    ];\n});\n_c2 = JSXStyle;\nJSXStyle.dynamic = function(info) {\n    return info.map(function(tagInfo) {\n        var baseId = tagInfo[0];\n        var props = tagInfo[1];\n        return computeId(baseId, props);\n    }).join(\" \");\n};\nexports.StyleRegistry = StyleRegistry;\nexports.createStyleRegistry = createStyleRegistry;\nexports.style = JSXStyle;\nexports.useStyleRegistry = useStyleRegistry;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"React__default\");\n$RefreshReg$(_c1, \"StyleRegistry\");\n$RefreshReg$(_c2, \"JSXStyle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7QUFBQUEsbUJBQU9BLENBQUM7QUFDUixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUVwQixTQUFTRSxzQkFBdUJDLENBQUM7SUFBSSxPQUFPQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQUUsV0FBV0E7SUFBRTtBQUFHO0FBRWpILElBQUlDLGlCQUFpQixXQUFXLEdBQUVGLHNCQUFzQkQ7O0FBRXhEOzs7QUFHQSxHQUFHLFNBQVNJLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQ3ZDLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUk7UUFDakMsSUFBSUUsYUFBYUgsS0FBSyxDQUFDQyxFQUFFO1FBQ3pCRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUNqREQsV0FBV0UsWUFBWSxHQUFHO1FBQzFCLElBQUksV0FBV0YsWUFBWUEsV0FBV0csUUFBUSxHQUFHO1FBQ2pEQyxPQUFPQyxjQUFjLENBQUNULFFBQVFJLFdBQVdNLEdBQUcsRUFBRU47SUFDbEQ7QUFDSjtBQUNBLFNBQVNPLGFBQWFDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQ3RELElBQUlELFlBQVlkLGtCQUFrQmEsWUFBWUcsU0FBUyxFQUFFRjtJQUN6RCxJQUFJQyxhQUFhZixrQkFBa0JhLGFBQWFFO0lBQ2hELE9BQU9GO0FBQ1g7QUFDQSxJQUFJSSxTQUFTLE9BQU9DLE9BQU9BLEtBQUssZUFBZUEsT0FBT0EsQ0FBQ0MsR0FBRyxJQUFJRCxrQkFBeUI7QUFDdkYsSUFBSUUsV0FBVyxTQUFTQyxDQUFDO0lBQ3JCLE9BQU9aLE9BQU9PLFNBQVMsQ0FBQ00sUUFBUSxDQUFDQyxJQUFJLENBQUNGLE9BQU87QUFDakQ7QUFDQSxJQUFJRyxhQUFhLFdBQVcsR0FB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Qkcsd0JBQXdCLEdBQUdQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanM/YjAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCdjbGllbnQtb25seScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xuXG4vKlxuQmFzZWQgb24gR2xhbW9yJ3Mgc2hlZXRcbmh0dHBzOi8vZ2l0aHViLmNvbS90aHJlZXBvaW50b25lL2dsYW1vci9ibG9iLzY2N2I0ODBkMzFiMzcyMWE5MDUwMjFiMjZlMTI5MGNlOTJjYTI4Nzkvc3JjL3NoZWV0LmpzXG4qLyBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbnZhciBpc1Byb2QgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbn07XG52YXIgU3R5bGVTaGVldCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldChwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9uYW1lID0gcmVmLm5hbWUsIG5hbWUgPSBfbmFtZSA9PT0gdm9pZCAwID8gXCJzdHlsZXNoZWV0XCIgOiBfbmFtZSwgX29wdGltaXplRm9yU3BlZWQgPSByZWYub3B0aW1pemVGb3JTcGVlZCwgb3B0aW1pemVGb3JTcGVlZCA9IF9vcHRpbWl6ZUZvclNwZWVkID09PSB2b2lkIDAgPyBpc1Byb2QgOiBfb3B0aW1pemVGb3JTcGVlZDtcbiAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcobmFtZSksIFwiYG5hbWVgIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID0gXCIjXCIgKyBuYW1lICsgXCItZGVsZXRlZC1ydWxlX19fX3t9XCI7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSBcImJvb2xlYW5cIiwgXCJgb3B0aW1pemVGb3JTcGVlZGAgbXVzdCBiZSBhIGJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBvcHRpbWl6ZUZvclNwZWVkO1xuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFncyA9IFtdO1xuICAgICAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgICAgICAgdGhpcy5fbm9uY2UgPSBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRPcHRpbWl6ZUZvclNwZWVkID0gZnVuY3Rpb24gc2V0T3B0aW1pemVGb3JTcGVlZChib29sKSB7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBib29sID09PSBcImJvb2xlYW5cIiwgXCJgc2V0T3B0aW1pemVGb3JTcGVlZGAgYWNjZXB0cyBhIGJvb2xlYW5cIik7XG4gICAgICAgIGludmFyaWFudCQxKHRoaXMuX3J1bGVzQ291bnQgPT09IDAsIFwib3B0aW1pemVGb3JTcGVlZCBjYW5ub3QgYmUgd2hlbiBydWxlcyBoYXZlIGFscmVhZHkgYmVlbiBpbnNlcnRlZFwiKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gYm9vbDtcbiAgICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9O1xuICAgIF9wcm90by5pc09wdGltaXplRm9yU3BlZWQgPSBmdW5jdGlvbiBpc09wdGltaXplRm9yU3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkO1xuICAgIH07XG4gICAgX3Byb3RvLmluamVjdCA9IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaW52YXJpYW50JDEoIXRoaXMuX2luamVjdGVkLCBcInNoZWV0IGFscmVhZHkgaW5qZWN0ZWRcIik7XG4gICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGFnc1swXSA9IHRoaXMubWFrZVN0eWxlVGFnKHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IFwiaW5zZXJ0UnVsZVwiIGluIHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IG9wdGltaXplRm9yU3BlZWQgbW9kZSBub3Qgc3VwcG9ydGVkIGZhbGxpbmcgYmFjayB0byBzdGFuZGFyZCBtb2RlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHtcbiAgICAgICAgICAgIGNzc1J1bGVzOiBbXSxcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IGZ1bmN0aW9uKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXNbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogcnVsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVSdWxlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmdldFNoZWV0Rm9yVGFnID0gZnVuY3Rpb24gZ2V0U2hlZXRGb3JUYWcodGFnKSB7XG4gICAgICAgIGlmICh0YWcuc2hlZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyB3ZWlyZG5lc3MgYnJvdWdodCB0byB5b3UgYnkgZmlyZWZveFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldLm93bmVyTm9kZSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U2hlZXQgPSBmdW5jdGlvbiBnZXRTaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hlZXRGb3JUYWcodGhpcy5fdGFnc1t0aGlzLl90YWdzLmxlbmd0aCAtIDFdKTtcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCkge1xuICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhydWxlKSwgXCJgaW5zZXJ0UnVsZWAgYWNjZXB0cyBvbmx5IHN0cmluZ3NcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgICAgIHZhciBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgd2VpcmRuZXNzIGZvciBwZXJmLCBhbmQgY2hyb21lJ3Mgd2VpcmQgYnVnXG4gICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDAwNzk5Mi9jaHJvbWUtc3VkZGVubHktc3RvcHBlZC1hY2NlcHRpbmctaW5zZXJ0cnVsZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogaWxsZWdhbCBydWxlOiBcXG5cXG5cIiArIHJ1bGUgKyBcIlxcblxcblNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjAwMDc5OTIgZm9yIG1vcmUgaW5mb1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLl90YWdzLnB1c2godGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSwgcnVsZSwgaW5zZXJ0aW9uUG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZXNDb3VudCsrO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUoaW5kZXgsIHJ1bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuZ2V0U2hlZXQoKSA6IHRoaXMuX3NlcnZlclNoZWV0O1xuICAgICAgICAgICAgaWYgKCFydWxlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIHJ1bGUgPSB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGVldC5jc3NSdWxlc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBAVEJEIFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IGlsbGVnYWwgcnVsZTogXFxuXFxuXCIgKyBydWxlICsgXCJcXG5cXG5TZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzIwMDA3OTkyIGZvciBtb3JlIGluZm9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBpbmRpY2VzIHdlIGluc2VydCBhIGRlbGV0ZVJ1bGVQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUodGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgICAgICAgaW52YXJpYW50JDEodGFnLCBcIm9sZCBydWxlIGF0IGluZGV4IGBcIiArIGluZGV4ICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHRhZy50ZXh0Q29udGVudCA9IHJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUnVsZShpbmRleCwgXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSh0YWcsIFwicnVsZSBhdCBpbmRleCBgXCIgKyBpbmRleCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgdGhpcy5fdGFnc1tpbmRleF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcnVsZXNDb3VudCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl90YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZyAmJiB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90YWdzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaW1wbGVyIG9uIHNlcnZlclxuICAgICAgICAgICAgdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNzc1J1bGVzID0gZnVuY3Rpb24gY3NzUnVsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ3MucmVkdWNlKGZ1bmN0aW9uKHJ1bGVzLCB0YWcpIHtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoX3RoaXMuZ2V0U2hlZXRGb3JUYWcodGFnKS5jc3NSdWxlcywgZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS5jc3NUZXh0ID09PSBfdGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciA/IG51bGwgOiBydWxlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgX3Byb3RvLm1ha2VTdHlsZVRhZyA9IGZ1bmN0aW9uIG1ha2VTdHlsZVRhZyhuYW1lLCBjc3NTdHJpbmcsIHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgaWYgKGNzc1N0cmluZykge1xuICAgICAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcoY3NzU3RyaW5nKSwgXCJtYWtlU3R5bGVUYWcgYWNjZXB0cyBvbmx5IHN0cmluZ3MgYXMgc2Vjb25kIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAodGhpcy5fbm9uY2UpIHRhZy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0aGlzLl9ub25jZSk7XG4gICAgICAgIHRhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICB0YWcuc2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUsIFwiXCIpO1xuICAgICAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHRhZywgcmVsYXRpdmVUb1RhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhTdHlsZVNoZWV0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5mdW5jdGlvbiBpbnZhcmlhbnQkMShjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0OiBcIiArIG1lc3NhZ2UgKyBcIi5cIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIHZhciBfJGhhc2ggPSA1MzgxLCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZShpKXtcbiAgICAgICAgXyRoYXNoID0gXyRoYXNoICogMzMgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgKiBzaWduZWQgaW50IHRvIGFuIHVuc2lnbmVkIGJ5IGRvaW5nIGFuIHVuc2lnbmVkIGJpdHNoaWZ0LiAqLyByZXR1cm4gXyRoYXNoID4+PiAwO1xufVxudmFyIHN0cmluZ0hhc2ggPSBoYXNoO1xuXG52YXIgc2FuaXRpemUgPSBmdW5jdGlvbihydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUucmVwbGFjZSgvXFwvc3R5bGUvZ2ksIFwiXFxcXC9zdHlsZVwiKTtcbn07XG52YXIgY2FjaGUgPSB7fTtcbi8qKlxuICogY29tcHV0ZUlkXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBhIGpzeCBpZCBmcm9tIGEgYmFzZWRJZCBhbmQgb3B0aW9uYWxseSBwcm9wcy5cbiAqLyBmdW5jdGlvbiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIFwianN4LVwiICsgYmFzZUlkO1xuICAgIH1cbiAgICB2YXIgcHJvcHNUb1N0cmluZyA9IFN0cmluZyhwcm9wcyk7XG4gICAgdmFyIGtleSA9IGJhc2VJZCArIHByb3BzVG9TdHJpbmc7XG4gICAgaWYgKCFjYWNoZVtrZXldKSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSBcImpzeC1cIiArIHN0cmluZ0hhc2goYmFzZUlkICsgXCItXCIgKyBwcm9wc1RvU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG59XG4vKipcbiAqIGNvbXB1dGVTZWxlY3RvclxuICpcbiAqIENvbXB1dGUgYW5kIG1lbW9pemUgZHluYW1pYyBzZWxlY3RvcnMuXG4gKi8gZnVuY3Rpb24gY29tcHV0ZVNlbGVjdG9yKGlkLCBjc3MpIHtcbiAgICB2YXIgc2VsZWN0b1BsYWNlaG9sZGVyUmVnZXhwID0gL19fanN4LXN0eWxlLWR5bmFtaWMtc2VsZWN0b3IvZztcbiAgICAvLyBTYW5pdGl6ZSBTU1ItZWQgQ1NTLlxuICAgIC8vIENsaWVudCBzaWRlIGNvZGUgZG9lc24ndCBuZWVkIHRvIGJlIHNhbml0aXplZCBzaW5jZSB3ZSB1c2VcbiAgICAvLyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSAoZGV2KSBhbmQgdGhlIENTU09NIGFwaSBzaGVldC5pbnNlcnRSdWxlIChwcm9kKS5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjc3MgPSBzYW5pdGl6ZShjc3MpO1xuICAgIH1cbiAgICB2YXIgaWRjc3MgPSBpZCArIGNzcztcbiAgICBpZiAoIWNhY2hlW2lkY3NzXSkge1xuICAgICAgICBjYWNoZVtpZGNzc10gPSBjc3MucmVwbGFjZShzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAsIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2lkY3NzXTtcbn1cblxuZnVuY3Rpb24gbWFwUnVsZXNUb1N0eWxlKGNzc1J1bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHJldHVybiBjc3NSdWxlcy5tYXAoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaWQgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgY3NzID0gYXJnc1sxXTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7XG4gICAgICAgICAgICBpZDogXCJfX1wiICsgaWQsXG4gICAgICAgICAgICAvLyBBdm9pZCB3YXJuaW5ncyB1cG9uIHJlbmRlciB3aXRoIGEga2V5XG4gICAgICAgICAgICBrZXk6IFwiX19cIiArIGlkLFxuICAgICAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgICAgICBfX2h0bWw6IGNzc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbnZhciBTdHlsZVNoZWV0UmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlU2hlZXRSZWdpc3RyeShwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9zdHlsZVNoZWV0ID0gcmVmLnN0eWxlU2hlZXQsIHN0eWxlU2hlZXQgPSBfc3R5bGVTaGVldCA9PT0gdm9pZCAwID8gbnVsbCA6IF9zdHlsZVNoZWV0LCBfb3B0aW1pemVGb3JTcGVlZCA9IHJlZi5vcHRpbWl6ZUZvclNwZWVkLCBvcHRpbWl6ZUZvclNwZWVkID0gX29wdGltaXplRm9yU3BlZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGltaXplRm9yU3BlZWQ7XG4gICAgICAgIHRoaXMuX3NoZWV0ID0gc3R5bGVTaGVldCB8fCBuZXcgU3R5bGVTaGVldCh7XG4gICAgICAgICAgICBuYW1lOiBcInN0eWxlZC1qc3hcIixcbiAgICAgICAgICAgIG9wdGltaXplRm9yU3BlZWQ6IG9wdGltaXplRm9yU3BlZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuICAgICAgICBpZiAoc3R5bGVTaGVldCAmJiB0eXBlb2Ygb3B0aW1pemVGb3JTcGVlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoZWV0LnNldE9wdGltaXplRm9yU3BlZWQob3B0aW1pemVGb3JTcGVlZCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXRSZWdpc3RyeS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB0aGlzLl9zaGVldC5zZXRPcHRpbWl6ZUZvclNwZWVkKHRoaXMuX29wdGltaXplRm9yU3BlZWQpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IHRoaXMuX3NoZWV0LmlzT3B0aW1pemVGb3JTcGVlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICF0aGlzLl9mcm9tU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdGhpcy5zZWxlY3RGcm9tU2VydmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgYWNjW3RhZ05hbWVdID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSB0aGlzLmdldElkQW5kUnVsZXMocHJvcHMpLCBzdHlsZUlkID0gcmVmLnN0eWxlSWQsIHJ1bGVzID0gcmVmLnJ1bGVzO1xuICAgICAgICAvLyBEZWR1cGluZzoganVzdCBpbmNyZWFzZSB0aGUgaW5zdGFuY2VzIGNvdW50LlxuICAgICAgICBpZiAoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSArPSAxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRpY2VzID0gcnVsZXMubWFwKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hlZXQuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgICAgfSkvLyBGaWx0ZXIgb3V0IGludmFsaWQgcnVsZXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0gPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gPSAxO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3R5bGVJZCA9IHRoaXMuZ2V0SWRBbmRSdWxlcyhwcm9wcykuc3R5bGVJZDtcbiAgICAgICAgaW52YXJpYW50KHN0eWxlSWQgaW4gdGhpcy5faW5zdGFuY2VzQ291bnRzLCBcInN0eWxlSWQ6IGBcIiArIHN0eWxlSWQgKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSA8IDEpIHtcbiAgICAgICAgICAgIHZhciB0YWdGcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciAmJiB0aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdO1xuICAgICAgICAgICAgaWYgKHRhZ0Zyb21TZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0YWdGcm9tU2VydmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnRnJvbVNlcnZlcik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0uZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3NoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuYWRkKG5leHRQcm9wcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKHByb3BzKTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9zaGVldC5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9zaGVldC5pbmplY3QoKTtcbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5jc3NSdWxlcyA9IGZ1bmN0aW9uIGNzc1J1bGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJvbVNlcnZlciA9IHRoaXMuX2Zyb21TZXJ2ZXIgPyBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5tYXAoZnVuY3Rpb24oc3R5bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIF90aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLl9zaGVldC5jc3NSdWxlcygpO1xuICAgICAgICByZXR1cm4gZnJvbVNlcnZlci5jb25jYXQoT2JqZWN0LmtleXModGhpcy5faW5kaWNlcykubWFwKGZ1bmN0aW9uKHN0eWxlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5kaWNlc1tzdHlsZUlkXS5tYXAoZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzc1J1bGVzW2luZGV4XS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oX3RoaXMuX29wdGltaXplRm9yU3BlZWQgPyBcIlwiIDogXCJcXG5cIilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pLy8gZmlsdGVyIG91dCBlbXB0eSBydWxlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHJ1bGVbMV0pO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1hcFJ1bGVzVG9TdHlsZSh0aGlzLmNzc1J1bGVzKCksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkQW5kUnVsZXMgPSBmdW5jdGlvbiBnZXRJZEFuZFJ1bGVzKHByb3BzKSB7XG4gICAgICAgIHZhciBjc3MgPSBwcm9wcy5jaGlsZHJlbiwgZHluYW1pYyA9IHByb3BzLmR5bmFtaWMsIGlkID0gcHJvcHMuaWQ7XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVJZCA9IGNvbXB1dGVJZChpZCwgZHluYW1pYyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgcnVsZXM6IEFycmF5LmlzQXJyYXkoY3NzKSA/IGNzcy5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHV0ZVNlbGVjdG9yKHN0eWxlSWQsIHJ1bGUpO1xuICAgICAgICAgICAgICAgIH0pIDogW1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgY3NzKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0eWxlSWQ6IGNvbXB1dGVJZChpZCksXG4gICAgICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzIDogW1xuICAgICAgICAgICAgICAgIGNzc1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAqIHNlbGVjdEZyb21TZXJ2ZXJcbiAgICpcbiAgICogQ29sbGVjdHMgc3R5bGUgdGFncyBmcm9tIHRoZSBkb2N1bWVudCB3aXRoIGlkIF9fanN4LVhYWFxuICAgKi8gX3Byb3RvLnNlbGVjdEZyb21TZXJ2ZXIgPSBmdW5jdGlvbiBzZWxlY3RGcm9tU2VydmVyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWRePVwiX19qc3gtXCJdJykpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudC5pZC5zbGljZSgyKTtcbiAgICAgICAgICAgIGFjY1tpZF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlU2hlZXRSZWdpc3RyeTtcbn0oKTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0UmVnaXN0cnk6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgICB9XG59XG52YXIgU3R5bGVTaGVldENvbnRleHQgPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5TdHlsZVNoZWV0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiU3R5bGVTaGVldENvbnRleHRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZVNoZWV0UmVnaXN0cnkoKTtcbn1cbmZ1bmN0aW9uIFN0eWxlUmVnaXN0cnkocGFyYW0pIHtcbiAgICB2YXIgY29uZmlndXJlZFJlZ2lzdHJ5ID0gcGFyYW0ucmVnaXN0cnksIGNoaWxkcmVuID0gcGFyYW0uY2hpbGRyZW47XG4gICAgdmFyIHJvb3RSZWdpc3RyeSA9IFJlYWN0LnVzZUNvbnRleHQoU3R5bGVTaGVldENvbnRleHQpO1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RSZWdpc3RyeSB8fCBjb25maWd1cmVkUmVnaXN0cnkgfHwgY3JlYXRlU3R5bGVSZWdpc3RyeSgpO1xuICAgIH0pLCByZWdpc3RyeSA9IHJlZlswXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTdHlsZVNoZWV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcmVnaXN0cnlcbiAgICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1c2VTdHlsZVJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFN0eWxlU2hlZXRDb250ZXh0KTtcbn1cblxuLy8gT3B0LWludG8gdGhlIG5ldyBgdXNlSW5zZXJ0aW9uRWZmZWN0YCBBUEkgaW4gUmVhY3QgMTgsIGZhbGxiYWNrIHRvIGB1c2VMYXlvdXRFZmZlY3RgLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvMTEwXG52YXIgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVzZUluc2VydGlvbkVmZmVjdCB8fCBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlTGF5b3V0RWZmZWN0O1xudmFyIGRlZmF1bHRSZWdpc3RyeSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBKU1hTdHlsZShwcm9wcykge1xuICAgIHZhciByZWdpc3RyeSA9IGRlZmF1bHRSZWdpc3RyeSA/IGRlZmF1bHRSZWdpc3RyeSA6IHVzZVN0eWxlUmVnaXN0cnkoKTtcbiAgICAvLyBJZiBgcmVnaXN0cnlgIGRvZXMgbm90IGV4aXN0LCB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgaWYgKCFyZWdpc3RyeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVzZUluc2VydGlvbkVmZmVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVnaXN0cnkucmVtb3ZlKHByb3BzKTtcbiAgICAgICAgfTtcbiAgICAvLyBwcm9wcy5jaGlsZHJlbiBjYW4gYmUgc3RyaW5nW10sIHdpbGwgYmUgc3RyaXBlZCBzaW5jZSBpZCBpcyBpZGVudGljYWxcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLmlkLFxuICAgICAgICBTdHJpbmcocHJvcHMuZHluYW1pYylcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbkpTWFN0eWxlLmR5bmFtaWMgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ubWFwKGZ1bmN0aW9uKHRhZ0luZm8pIHtcbiAgICAgICAgdmFyIGJhc2VJZCA9IHRhZ0luZm9bMF07XG4gICAgICAgIHZhciBwcm9wcyA9IHRhZ0luZm9bMV07XG4gICAgICAgIHJldHVybiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcyk7XG4gICAgfSkuam9pbihcIiBcIik7XG59O1xuXG5leHBvcnRzLlN0eWxlUmVnaXN0cnkgPSBTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5jcmVhdGVTdHlsZVJlZ2lzdHJ5ID0gY3JlYXRlU3R5bGVSZWdpc3RyeTtcbmV4cG9ydHMuc3R5bGUgPSBKU1hTdHlsZTtcbmV4cG9ydHMudXNlU3R5bGVSZWdpc3RyeSA9IHVzZVN0eWxlUmVnaXN0cnk7XG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIlJlYWN0IiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIlJlYWN0X19kZWZhdWx0IiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImlzUHJvZCIsInByb2Nlc3MiLCJlbnYiLCJpc1N0cmluZyIsIm8iLCJ0b1N0cmluZyIsImNhbGwiLCJTdHlsZVNoZWV0IiwicGFyYW0iLCJyZWYiLCJfbmFtZSIsIm5hbWUiLCJfb3B0aW1pemVGb3JTcGVlZCIsIm9wdGltaXplRm9yU3BlZWQiLCJpbnZhcmlhbnQkMSIsIl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyIiwiX3NlcnZlclNoZWV0IiwidW5kZWZpbmVkIiwiX3RhZ3MiLCJfaW5qZWN0ZWQiLCJfcnVsZXNDb3VudCIsIm5vZGUiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJfbm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJfcHJvdG8iLCJzZXRPcHRpbWl6ZUZvclNwZWVkIiwiYm9vbCIsImZsdXNoIiwiaW5qZWN0IiwiaXNPcHRpbWl6ZUZvclNwZWVkIiwiX3RoaXMiLCJtYWtlU3R5bGVUYWciLCJnZXRTaGVldCIsImNvbnNvbGUiLCJ3YXJuIiwiY3NzUnVsZXMiLCJpbnNlcnRSdWxlIiwicnVsZSIsImluZGV4IiwiY3NzVGV4dCIsInB1c2giLCJkZWxldGVSdWxlIiwiZ2V0U2hlZXRGb3JUYWciLCJ0YWciLCJzaGVldCIsInN0eWxlU2hlZXRzIiwib3duZXJOb2RlIiwiZXJyb3IiLCJpbnNlcnRpb25Qb2ludCIsInJlcGxhY2VSdWxlIiwidHJpbSIsInRleHRDb250ZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZm9yRWFjaCIsInJlZHVjZSIsInJ1bGVzIiwiY29uY2F0IiwiQXJyYXkiLCJtYXAiLCJjc3NTdHJpbmciLCJyZWxhdGl2ZVRvVGFnIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInR5cGUiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiaGFzaCIsInN0ciIsIl8kaGFzaCIsImNoYXJDb2RlQXQiLCJzdHJpbmdIYXNoIiwic2FuaXRpemUiLCJyZXBsYWNlIiwiY2FjaGUiLCJjb21wdXRlSWQiLCJiYXNlSWQiLCJwcm9wc1RvU3RyaW5nIiwiU3RyaW5nIiwiY29tcHV0ZVNlbGVjdG9yIiwiaWQiLCJjc3MiLCJzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAiLCJpZGNzcyIsIm1hcFJ1bGVzVG9TdHlsZSIsIm9wdGlvbnMiLCJhcmdzIiwibm9uY2UiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsIlN0eWxlU2hlZXRSZWdpc3RyeSIsIl9zdHlsZVNoZWV0Iiwic3R5bGVTaGVldCIsIl9zaGVldCIsIl9mcm9tU2VydmVyIiwiX2luZGljZXMiLCJfaW5zdGFuY2VzQ291bnRzIiwiYWRkIiwiaXNBcnJheSIsImNoaWxkcmVuIiwic2VsZWN0RnJvbVNlcnZlciIsImtleXMiLCJhY2MiLCJ0YWdOYW1lIiwiZ2V0SWRBbmRSdWxlcyIsInN0eWxlSWQiLCJpbmRpY2VzIiwiZmlsdGVyIiwicmVtb3ZlIiwiaW52YXJpYW50IiwidGFnRnJvbVNlcnZlciIsInVwZGF0ZSIsIm5leHRQcm9wcyIsImZyb21TZXJ2ZXIiLCJqb2luIiwiQm9vbGVhbiIsInN0eWxlcyIsImR5bmFtaWMiLCJlbGVtZW50cyIsInNsaWNlIiwicXVlcnlTZWxlY3RvckFsbCIsImVsZW1lbnQiLCJTdHlsZVNoZWV0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsImNyZWF0ZVN0eWxlUmVnaXN0cnkiLCJTdHlsZVJlZ2lzdHJ5IiwiY29uZmlndXJlZFJlZ2lzdHJ5IiwicmVnaXN0cnkiLCJyb290UmVnaXN0cnkiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJQcm92aWRlciIsInZhbHVlIiwidXNlU3R5bGVSZWdpc3RyeSIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImRlZmF1bHRSZWdpc3RyeSIsIkpTWFN0eWxlIiwiaW5mbyIsInRhZ0luZm8iLCJleHBvcnRzIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./dist/index */ \"(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\").style;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsbUlBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzPzM3MGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXgnKS5zdHlsZVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/style.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APILoadingStatus: function() { return /* binding */ APILoadingStatus; },\n/* harmony export */   APIProvider: function() { return /* binding */ APIProvider; },\n/* harmony export */   APIProviderContext: function() { return /* binding */ APIProviderContext; },\n/* harmony export */   AdvancedMarker: function() { return /* binding */ AdvancedMarker; },\n/* harmony export */   AdvancedMarkerAnchorPoint: function() { return /* binding */ AdvancedMarkerAnchorPoint; },\n/* harmony export */   AdvancedMarkerContext: function() { return /* binding */ AdvancedMarkerContext; },\n/* harmony export */   CollisionBehavior: function() { return /* binding */ CollisionBehavior; },\n/* harmony export */   ColorScheme: function() { return /* binding */ ColorScheme; },\n/* harmony export */   ControlPosition: function() { return /* binding */ ControlPosition; },\n/* harmony export */   GoogleMapsContext: function() { return /* binding */ GoogleMapsContext; },\n/* harmony export */   InfoWindow: function() { return /* binding */ InfoWindow; },\n/* harmony export */   Map: function() { return /* binding */ Map; },\n/* harmony export */   MapControl: function() { return /* binding */ MapControl; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   Pin: function() { return /* binding */ Pin; },\n/* harmony export */   RenderingType: function() { return /* binding */ RenderingType; },\n/* harmony export */   StaticMap: function() { return /* binding */ StaticMap; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   createStaticMapsUrl: function() { return /* binding */ createStaticMapsUrl; },\n/* harmony export */   isAdvancedMarker: function() { return /* binding */ isAdvancedMarker; },\n/* harmony export */   isLatLngLiteral: function() { return /* binding */ isLatLngLiteral; },\n/* harmony export */   latLngEquals: function() { return /* binding */ latLngEquals; },\n/* harmony export */   limitTiltRange: function() { return /* binding */ limitTiltRange; },\n/* harmony export */   toLatLngLiteral: function() { return /* binding */ toLatLngLiteral; },\n/* harmony export */   useAdvancedMarkerRef: function() { return /* binding */ useAdvancedMarkerRef; },\n/* harmony export */   useApiIsLoaded: function() { return /* binding */ useApiIsLoaded; },\n/* harmony export */   useApiLoadingStatus: function() { return /* binding */ useApiLoadingStatus; },\n/* harmony export */   useMap: function() { return /* binding */ useMap; },\n/* harmony export */   useMapsLibrary: function() { return /* binding */ useMapsLibrary; },\n/* harmony export */   useMarkerRef: function() { return /* binding */ useMarkerRef; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(app-pages-browser)/./node_modules/fast-deep-equal/index.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$();\n\n\n\n// This file is automatically updated by the build process.\nconst VERSION = \"1.7.1\";\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst APILoadingStatus = {\n    NOT_LOADED: \"NOT_LOADED\",\n    LOADING: \"LOADING\",\n    LOADED: \"LOADED\",\n    FAILED: \"FAILED\",\n    AUTH_FAILURE: \"AUTH_FAILURE\"\n};\nconst MAPS_API_BASE_URL = \"https://maps.googleapis.com/maps/api/js\";\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */ class GoogleMapsApiLoader {\n    /**\n     * Loads the Maps JavaScript API with the specified parameters.\n     * Since the Maps library can only be loaded once per page, this will\n     * produce a warning when called multiple times with different\n     * parameters.\n     *\n     * The returned promise resolves when loading completes\n     * and rejects in case of an error or when the loading was aborted.\n     */ static load(params, onLoadingStatusChange) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const libraries = params.libraries ? params.libraries.split(\",\") : [];\n            const serializedParams = this.serializeParams(params);\n            this.listeners.push(onLoadingStatusChange);\n            // Note: if `google.maps.importLibrary` has been defined externally, we\n            //   assume that loading is complete and successful.\n            //   If it was defined by a previous call to this method, a warning\n            //   message is logged if there are differences in api-parameters used\n            //   for both calls.\n            if ((_b = (_a = window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary) {\n                // no serialized parameters means it was loaded externally\n                if (!this.serializedApiParams) {\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                }\n                this.notifyLoadingStatusListeners();\n            } else {\n                this.serializedApiParams = serializedParams;\n                this.initImportLibrary(params);\n            }\n            if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n                console.warn(\"[google-maps-api-loader] The maps API has already been loaded \" + \"with different parameters and will not be loaded again. Refresh the \" + \"page for new values to have effect.\");\n            }\n            const librariesToLoad = [\n                \"maps\",\n                ...libraries\n            ];\n            yield Promise.all(librariesToLoad.map((name)=>google.maps.importLibrary(name)));\n        });\n    }\n    /**\n     * Serialize the parameters used to load the library for easier comparison.\n     */ static serializeParams(params) {\n        return [\n            params.v,\n            params.key,\n            params.language,\n            params.region,\n            params.authReferrerPolicy,\n            params.solutionChannel\n        ].join(\"/\");\n    }\n    /**\n     * Creates the global `google.maps.importLibrary` function for bootstrapping.\n     * This is essentially a formatted version of the dynamic loading script\n     * from the official documentation with some minor adjustments.\n     *\n     * The created importLibrary function will load the Google Maps JavaScript API,\n     * which will then replace the `google.maps.importLibrary` function with the full\n     * implementation.\n     *\n     * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n     */ static initImportLibrary(params) {\n        if (!window.google) window.google = {};\n        if (!window.google.maps) window.google.maps = {};\n        if (window.google.maps[\"importLibrary\"]) {\n            console.error(\"[google-maps-api-loader-internal]: initImportLibrary must only be called once\");\n            return;\n        }\n        let apiPromise = null;\n        const loadApi = ()=>{\n            if (apiPromise) return apiPromise;\n            apiPromise = new Promise((resolve, reject)=>{\n                var _a;\n                const scriptElement = document.createElement(\"script\");\n                const urlParams = new URLSearchParams();\n                for (const [key, value] of Object.entries(params)){\n                    const urlParamName = key.replace(/[A-Z]/g, (t)=>\"_\" + t[0].toLowerCase());\n                    urlParams.set(urlParamName, String(value));\n                }\n                urlParams.set(\"loading\", \"async\");\n                urlParams.set(\"callback\", \"__googleMapsCallback__\");\n                scriptElement.async = true;\n                scriptElement.src = MAPS_API_BASE_URL + \"?\" + urlParams.toString();\n                scriptElement.nonce = ((_a = document.querySelector(\"script[nonce]\")) === null || _a === void 0 ? void 0 : _a.nonce) || \"\";\n                scriptElement.onerror = ()=>{\n                    this.loadingStatus = APILoadingStatus.FAILED;\n                    this.notifyLoadingStatusListeners();\n                    reject(new Error(\"The Google Maps JavaScript API could not load.\"));\n                };\n                window.__googleMapsCallback__ = ()=>{\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                    this.notifyLoadingStatusListeners();\n                    resolve();\n                };\n                window.gm_authFailure = ()=>{\n                    this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n                    this.notifyLoadingStatusListeners();\n                };\n                this.loadingStatus = APILoadingStatus.LOADING;\n                this.notifyLoadingStatusListeners();\n                document.head.append(scriptElement);\n            });\n            return apiPromise;\n        };\n        // for the first load, we declare an importLibrary function that will\n        // be overwritten once the api is loaded.\n        google.maps.importLibrary = (libraryName)=>loadApi().then(()=>google.maps.importLibrary(libraryName));\n    }\n    /**\n     * Calls all registered loadingStatusListeners after a status update.\n     */ static notifyLoadingStatusListeners() {\n        for (const fn of this.listeners){\n            fn(this.loadingStatus);\n        }\n    }\n}\n/**\n * The current loadingStatus of the API.\n */ GoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\n/**\n * A list of functions to be notified when the loading status changes.\n */ GoogleMapsApiLoader.listeners = [];\nconst DEFAULT_SOLUTION_CHANNEL = \"GMP_visgl_rgmlibrary_v1_default\";\nconst DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS = [\n    \"gmp_visgl_reactgooglemaps_v\".concat(VERSION)\n];\nconst APIProviderContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */ function useMapInstances() {\n    _s();\n    const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const addMapInstance = function(mapInstance) {\n        let id = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"default\";\n        setMapInstances((instances)=>Object.assign(Object.assign({}, instances), {\n                [id]: mapInstance\n            }));\n    };\n    const removeMapInstance = function() {\n        let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"default\";\n        setMapInstances((_a)=>{\n            var _b = id;\n            _a[_b];\n            var remaining = __rest(_a, [\n                typeof _b === \"symbol\" ? _b : _b + \"\"\n            ]);\n            return remaining;\n        });\n    };\n    const clearMapInstances = ()=>{\n        setMapInstances({});\n    };\n    return {\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances\n    };\n}\n_s(useMapInstances, \"hsntVWRr8sQi9gSPNtNDFGcwkPA=\");\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */ function useGoogleMapsApiLoader(props) {\n    _s1();\n    const { onLoad, onError, apiKey, version, libraries = [] } = props, otherApiParams = __rest(props, [\n        \"onLoad\",\n        \"onError\",\n        \"apiKey\",\n        \"version\",\n        \"libraries\"\n    ]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n    const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action)=>{\n        return loadedLibraries[action.name] ? loadedLibraries : Object.assign(Object.assign({}, loadedLibraries), {\n            [action.name]: action.value\n        });\n    }, {});\n    const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>libraries === null || libraries === void 0 ? void 0 : libraries.join(\",\"), [\n        libraries\n    ]);\n    const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>JSON.stringify(Object.assign({\n            apiKey,\n            version\n        }, otherApiParams)), [\n        apiKey,\n        version,\n        otherApiParams\n    ]);\n    const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name)=>__awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (loadedLibraries[name]) {\n                return loadedLibraries[name];\n            }\n            if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.importLibrary)) {\n                throw new Error(\"[api-provider-internal] importLibrary was called before \" + \"google.maps.importLibrary was defined.\");\n            }\n            const res = yield window.google.maps.importLibrary(name);\n            addLoadedLibrary({\n                name,\n                value: res\n            });\n            return res;\n        }), [\n        loadedLibraries\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        (()=>__awaiter(this, void 0, void 0, function*() {\n                try {\n                    const params = Object.assign({\n                        key: apiKey\n                    }, otherApiParams);\n                    if (version) params.v = version;\n                    if ((librariesString === null || librariesString === void 0 ? void 0 : librariesString.length) > 0) params.libraries = librariesString;\n                    if (params.channel === undefined || params.channel < 0 || params.channel > 999) delete params.channel;\n                    if (params.solutionChannel === undefined) params.solutionChannel = DEFAULT_SOLUTION_CHANNEL;\n                    else if (params.solutionChannel === \"\") delete params.solutionChannel;\n                    yield GoogleMapsApiLoader.load(params, (status)=>setStatus(status));\n                    for (const name of [\n                        \"core\",\n                        \"maps\",\n                        ...libraries\n                    ]){\n                        yield importLibrary(name);\n                    }\n                    if (onLoad) {\n                        onLoad();\n                    }\n                } catch (error) {\n                    if (onError) {\n                        onError(error);\n                    } else {\n                        console.error(\"<ApiProvider> failed to load the Google Maps JavaScript API\", error);\n                    }\n                }\n            }))();\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        apiKey,\n        librariesString,\n        serializedParams\n    ]);\n    return {\n        status,\n        loadedLibraries,\n        importLibrary\n    };\n}\n_s1(useGoogleMapsApiLoader, \"tAqGGf6QjsgSH4cSRTniCSFuVJo=\");\nfunction useInternalUsageAttributionIds(props) {\n    _s2();\n    const internalUsageAttributionIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disableUsageAttribution ? null : DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS, [\n        props.disableUsageAttribution\n    ]);\n    return internalUsageAttributionIds;\n}\n_s2(useInternalUsageAttributionIds, \"j25p1744kcrJvSmGtAPEaHx3Hhg=\");\n/**\n * Component to wrap the components from this library and load the Google Maps JavaScript API\n */ const APIProvider = (props)=>{\n    _s3();\n    const { children } = props, loaderProps = __rest(props, [\n        \"children\"\n    ]);\n    const { mapInstances, addMapInstance, removeMapInstance, clearMapInstances } = useMapInstances();\n    const { status, loadedLibraries, importLibrary } = useGoogleMapsApiLoader(loaderProps);\n    const internalUsageAttributionIds = useInternalUsageAttributionIds(loaderProps);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            mapInstances,\n            addMapInstance,\n            removeMapInstance,\n            clearMapInstances,\n            status,\n            loadedLibraries,\n            importLibrary,\n            internalUsageAttributionIds\n        }), [\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary,\n        internalUsageAttributionIds\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, {\n        value: contextValue\n    }, children);\n};\n_s3(APIProvider, \"S6wcp3Dcoe9TGIgaE2N+QRV0JO0=\", false, function() {\n    return [\n        useMapInstances,\n        useGoogleMapsApiLoader,\n        useInternalUsageAttributionIds\n    ];\n});\n_c = APIProvider;\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */ function useMapEvents(map, props) {\n    // note: calling a useEffect hook from within a loop is prohibited by the\n    // rules of hooks, but it's ok here since it's unconditional and the number\n    // and order of iterations is always strictly the same.\n    // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n    for (const propName of eventPropNames){\n        // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n        //   a proper solution seems way too complicated right now\n        const handler = props[propName];\n        const eventType = propNameToEventType[propName];\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            if (!map) return;\n            if (!handler) return;\n            const listener = google.maps.event.addListener(map, eventType, (ev)=>{\n                handler(createMapEvent(eventType, map, ev));\n            });\n            return ()=>listener.remove();\n        }, [\n            map,\n            eventType,\n            handler\n        ]);\n    }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */ function createMapEvent(type, map, srcEvent) {\n    var _a;\n    const ev = {\n        type,\n        map,\n        detail: {},\n        stoppable: false,\n        stop: ()=>{}\n    };\n    if (cameraEventTypes.includes(type)) {\n        const camEvent = ev;\n        const center = map.getCenter();\n        const zoom = map.getZoom();\n        const heading = map.getHeading() || 0;\n        const tilt = map.getTilt() || 0;\n        const bounds = map.getBounds();\n        if (!center || !bounds || !Number.isFinite(zoom)) {\n            console.warn(\"[createEvent] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n        }\n        camEvent.detail = {\n            center: (center === null || center === void 0 ? void 0 : center.toJSON()) || {\n                lat: 0,\n                lng: 0\n            },\n            zoom: zoom || 0,\n            heading: heading,\n            tilt: tilt,\n            bounds: (bounds === null || bounds === void 0 ? void 0 : bounds.toJSON()) || {\n                north: 90,\n                east: 180,\n                south: -90,\n                west: -180\n            }\n        };\n        return camEvent;\n    } else if (mouseEventTypes.includes(type)) {\n        if (!srcEvent) throw new Error(\"[createEvent] mouse events must provide a srcEvent\");\n        const mouseEvent = ev;\n        mouseEvent.domEvent = srcEvent.domEvent;\n        mouseEvent.stoppable = true;\n        mouseEvent.stop = ()=>srcEvent.stop();\n        mouseEvent.detail = {\n            latLng: ((_a = srcEvent.latLng) === null || _a === void 0 ? void 0 : _a.toJSON()) || null,\n            placeId: srcEvent.placeId\n        };\n        return mouseEvent;\n    }\n    return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */ const propNameToEventType = {\n    onBoundsChanged: \"bounds_changed\",\n    onCenterChanged: \"center_changed\",\n    onClick: \"click\",\n    onContextmenu: \"contextmenu\",\n    onDblclick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragend: \"dragend\",\n    onDragstart: \"dragstart\",\n    onHeadingChanged: \"heading_changed\",\n    onIdle: \"idle\",\n    onIsFractionalZoomEnabledChanged: \"isfractionalzoomenabled_changed\",\n    onMapCapabilitiesChanged: \"mapcapabilities_changed\",\n    onMapTypeIdChanged: \"maptypeid_changed\",\n    onMousemove: \"mousemove\",\n    onMouseout: \"mouseout\",\n    onMouseover: \"mouseover\",\n    onProjectionChanged: \"projection_changed\",\n    onRenderingTypeChanged: \"renderingtype_changed\",\n    onTilesLoaded: \"tilesloaded\",\n    onTiltChanged: \"tilt_changed\",\n    onZoomChanged: \"zoom_changed\",\n    // note: onCameraChanged is an alias for the bounds_changed event,\n    // since that is going to be fired in every situation where the camera is\n    // updated.\n    onCameraChanged: \"bounds_changed\"\n};\nconst cameraEventTypes = [\n    \"bounds_changed\",\n    \"center_changed\",\n    \"heading_changed\",\n    \"tilt_changed\",\n    \"zoom_changed\"\n];\nconst mouseEventTypes = [\n    \"click\",\n    \"contextmenu\",\n    \"dblclick\",\n    \"mousemove\",\n    \"mouseout\",\n    \"mouseover\"\n];\nconst eventPropNames = Object.keys(propNameToEventType);\n/**\n * A hook to store the previous value of a variable.\n * @param value The value to store\n * @returns The previous value\n */ function usePrevious(value) {\n    _s4();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    });\n    // eslint-disable-next-line react-hooks/refs\n    return ref.current;\n}\n_s4(usePrevious, \"8uVE59eA/r6b92xF80p7sH8rXLk=\");\nfunction useMemoized(value, isEqual) {\n    _s5();\n    const previous = usePrevious(value);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (previous && isEqual(previous, value)) {\n            return previous;\n        }\n        return value;\n    }, [\n        value,\n        previous,\n        isEqual\n    ]);\n}\n_s5(useMemoized, \"W2ZjP41u9xKWAlx4QuRg5jjNbZI=\", false, function() {\n    return [\n        usePrevious\n    ];\n});\nfunction useCustomCompareEffect(effect, dependencies, isEqual) {\n    _s6();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, [\n        useMemoized(dependencies, isEqual)\n    ]);\n}\n_s6(useCustomCompareEffect, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nfunction useDeepCompareEffect(effect, dependencies) {\n    _s7();\n    useCustomCompareEffect(effect, dependencies, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n}\n_s7(useDeepCompareEffect, \"mylLLUfHnSoueBnkTkWWeM9ilrA=\", false, function() {\n    return [\n        useCustomCompareEffect\n    ];\n});\nconst mapOptionKeys = new Set([\n    \"backgroundColor\",\n    \"clickableIcons\",\n    \"controlSize\",\n    \"disableDefaultUI\",\n    \"disableDoubleClickZoom\",\n    \"draggable\",\n    \"draggableCursor\",\n    \"draggingCursor\",\n    \"fullscreenControl\",\n    \"fullscreenControlOptions\",\n    \"gestureHandling\",\n    \"headingInteractionEnabled\",\n    \"isFractionalZoomEnabled\",\n    \"keyboardShortcuts\",\n    \"mapTypeControl\",\n    \"mapTypeControlOptions\",\n    \"mapTypeId\",\n    \"maxZoom\",\n    \"minZoom\",\n    \"noClear\",\n    \"panControl\",\n    \"panControlOptions\",\n    \"restriction\",\n    \"rotateControl\",\n    \"rotateControlOptions\",\n    \"scaleControl\",\n    \"scaleControlOptions\",\n    \"scrollwheel\",\n    \"streetView\",\n    \"streetViewControl\",\n    \"streetViewControlOptions\",\n    \"styles\",\n    \"tiltInteractionEnabled\",\n    \"zoomControl\",\n    \"zoomControlOptions\"\n]);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */ function useMapOptions(map, mapProps) {\n    _s8();\n    /* eslint-disable react-hooks/exhaustive-deps --\n     *\n     * The following effects aren't triggered when the map is changed.\n     * In that case, the values will be or have been passed to the map\n     * constructor via mapOptions.\n     */ const mapOptions = {};\n    const keys = Object.keys(mapProps);\n    for (const key of keys){\n        if (!mapOptionKeys.has(key)) continue;\n        mapOptions[key] = mapProps[key];\n    }\n    // update the map options when mapOptions is changed\n    // Note: due to the destructuring above, mapOptions will be seen as changed\n    //   with every re-render, so we're assuming the maps-api will properly\n    //   deal with unchanged option-values passed into setOptions.\n    useDeepCompareEffect(()=>{\n        if (!map) return;\n        map.setOptions(mapOptions);\n    }, [\n        mapOptions\n    ]);\n/* eslint-enable react-hooks/exhaustive-deps */ }\n_s8(useMapOptions, \"9P7jum8Mqo4RIt9ebKErbOvo2AQ=\", false, function() {\n    return [\n        useDeepCompareEffect\n    ];\n});\nfunction useApiLoadingStatus() {\n    _s9();\n    var _a;\n    return ((_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) === null || _a === void 0 ? void 0 : _a.status) || APILoadingStatus.NOT_LOADED;\n}\n_s9(useApiLoadingStatus, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */ function useDeckGLCameraUpdate(map, props) {\n    _s10();\n    const { viewport, viewState } = props;\n    const isDeckGlControlled = !!viewport;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !viewState) return;\n        const { latitude, longitude, bearing: heading, pitch: tilt, zoom } = viewState;\n        map.moveCamera({\n            center: {\n                lat: latitude,\n                lng: longitude\n            },\n            heading,\n            tilt,\n            zoom: zoom + 1\n        });\n    }, [\n        map,\n        viewState\n    ]);\n    return isDeckGlControlled;\n}\n_s10(useDeckGLCameraUpdate, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\nfunction isLatLngLiteral(obj) {\n    if (!obj || typeof obj !== \"object\") return false;\n    if (!(\"lat\" in obj && \"lng\" in obj)) return false;\n    return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n    if (!a || !b) return false;\n    const A = toLatLngLiteral(a);\n    const B = toLatLngLiteral(b);\n    if (A.lat !== B.lat || A.lng !== B.lng) return false;\n    return true;\n}\nfunction toLatLngLiteral(obj) {\n    if (isLatLngLiteral(obj)) return obj;\n    return obj.toJSON();\n}\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n    _s11();\n    const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const zoom = Number.isFinite(mapProps.zoom) ? mapProps.zoom : null;\n    const heading = Number.isFinite(mapProps.heading) ? mapProps.heading : null;\n    const tilt = Number.isFinite(mapProps.tilt) ? mapProps.tilt : null;\n    // the following effect runs for every render of the map component and checks\n    // if there are differences between the known state of the map instance\n    // (cameraStateRef, which is updated by all bounds_changed events) and the\n    // desired state in the props.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map) return;\n        const nextCamera = {};\n        let needsUpdate = false;\n        if (lat !== null && lng !== null && (cameraStateRef.current.center.lat !== lat || cameraStateRef.current.center.lng !== lng)) {\n            nextCamera.center = {\n                lat,\n                lng\n            };\n            needsUpdate = true;\n        }\n        if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n            nextCamera.zoom = zoom;\n            needsUpdate = true;\n        }\n        if (heading !== null && cameraStateRef.current.heading !== heading) {\n            nextCamera.heading = heading;\n            needsUpdate = true;\n        }\n        if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n            nextCamera.tilt = tilt;\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            map.moveCamera(nextCamera);\n        }\n    });\n}\n_s11(useMapCameraParams, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\nconst AuthFailureMessage = ()=>{\n    const style = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        zIndex: 999,\n        display: \"flex\",\n        flexFlow: \"column nowrap\",\n        textAlign: \"center\",\n        justifyContent: \"center\",\n        fontSize: \".8rem\",\n        color: \"rgba(0,0,0,0.6)\",\n        background: \"#dddddd\",\n        padding: \"1rem 1.5rem\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: style\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\n_c1 = AuthFailureMessage;\nfunction useCallbackRef() {\n    _s12();\n    const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>setEl(value), [\n        setEl\n    ]);\n    return [\n        el,\n        ref\n    ];\n}\n_s12(useCallbackRef, \"VloTnEpYwfVP5sjWXc1w8xQWZ+Q=\");\n/**\n * Hook to check if the Maps JavaScript API is loaded\n */ function useApiIsLoaded() {\n    _s13();\n    const status = useApiLoadingStatus();\n    return status === APILoadingStatus.LOADED;\n}\n_s13(useApiIsLoaded, \"SdrWm+4Nu53O23DKCYwlLCyijMQ=\", false, function() {\n    return [\n        useApiLoadingStatus\n    ];\n});\nfunction useForceUpdate() {\n    _s14();\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((x)=>x + 1, 0);\n    return forceUpdate;\n}\n_s14(useForceUpdate, \"OYvExaf+rzzVf06crq8byWAi7Rk=\");\nfunction handleBoundsChange(map, ref) {\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n        console.warn(\"[useTrackedCameraState] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n    }\n    // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n    Object.assign(ref.current, {\n        center: (center === null || center === void 0 ? void 0 : center.toJSON()) || {\n            lat: 0,\n            lng: 0\n        },\n        zoom: zoom || 0,\n        heading: heading,\n        tilt: tilt\n    });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */ function useTrackedCameraStateRef(map) {\n    _s15();\n    const forceUpdate = useForceUpdate();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        center: {\n            lat: 0,\n            lng: 0\n        },\n        heading: 0,\n        tilt: 0,\n        zoom: 0\n    });\n    // Record camera state with every bounds_changed event dispatched by the map.\n    // This data is used to prevent feeding these values back to the\n    // map-instance when a typical \"controlled component\" setup (state variable is\n    // fed into and updated by the map).\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const listener = google.maps.event.addListener(map, \"bounds_changed\", ()=>{\n            handleBoundsChange(map, ref);\n            // When an event is occured, we have to update during the next cycle.\n            // The application could decide to ignore the event and not update any\n            // camera props of the map, meaning that in that case we will have to\n            // 'undo' the change to the camera.\n            forceUpdate();\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        forceUpdate\n    ]);\n    return ref;\n}\n_s15(useTrackedCameraStateRef, \"ZmjndRMGldGtdD0sNNTfC29J5s8=\", false, function() {\n    return [\n        useForceUpdate\n    ];\n});\n/**\n * Stores a stack of map-instances for each mapId. Whenever an\n * instance is used, it is removed from the stack while in use,\n * and returned to the stack when the component unmounts.\n * This allows us to correctly implement caching for multiple\n * maps om the same page, while reusing as much as possible.\n *\n * FIXME: while it should in theory be possible to reuse maps solely\n *   based on the mapId (as all other parameters can be changed at\n *   runtime), we don't yet have good enough tracking of options to\n *   reliably unset all the options that have been set.\n */ class CachedMapStack {\n    static has(key) {\n        return this.entries[key] && this.entries[key].length > 0;\n    }\n    static pop(key) {\n        if (!this.entries[key]) return null;\n        return this.entries[key].pop() || null;\n    }\n    static push(key, value) {\n        if (!this.entries[key]) this.entries[key] = [];\n        this.entries[key].push(value);\n    }\n}\nCachedMapStack.entries = {};\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */ function useMapInstance(props, context) {\n    _s16();\n    const apiIsLoaded = useApiIsLoaded();\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [container, containerRef] = useCallbackRef();\n    const cameraStateRef = useTrackedCameraStateRef(map);\n    const { id, defaultBounds, defaultCenter, defaultZoom, defaultHeading, defaultTilt, reuseMaps, renderingType, colorScheme } = props, mapOptions = __rest(props, [\n        \"id\",\n        \"defaultBounds\",\n        \"defaultCenter\",\n        \"defaultZoom\",\n        \"defaultHeading\",\n        \"defaultTilt\",\n        \"reuseMaps\",\n        \"renderingType\",\n        \"colorScheme\"\n    ]);\n    const hasZoom = props.zoom !== undefined || props.defaultZoom !== undefined;\n    const hasCenter = props.center !== undefined || props.defaultCenter !== undefined;\n    if (!defaultBounds && (!hasZoom || !hasCenter)) {\n        console.warn(\"<Map> component is missing configuration. \" + \"You have to provide zoom and center (via the `zoom`/`defaultZoom` and \" + \"`center`/`defaultCenter` props) or specify the region to show using \" + \"`defaultBounds`. See \" + \"https://visgl.github.io/react-google-maps/docs/api-reference/components/map#required\");\n    }\n    // apply default camera props if available and not overwritten by controlled props\n    if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n    if (!mapOptions.zoom && Number.isFinite(defaultZoom)) mapOptions.zoom = defaultZoom;\n    if (!mapOptions.heading && Number.isFinite(defaultHeading)) mapOptions.heading = defaultHeading;\n    if (!mapOptions.tilt && Number.isFinite(defaultTilt)) mapOptions.tilt = defaultTilt;\n    // Handle internalUsageAttributionIds\n    const customIds = mapOptions.internalUsageAttributionIds;\n    if (customIds == null) {\n        // Not specified - use context default (which may be null if disabled)\n        mapOptions.internalUsageAttributionIds = context.internalUsageAttributionIds;\n    } else {\n        // Merge context defaults with custom IDs\n        mapOptions.internalUsageAttributionIds = [\n            ...context.internalUsageAttributionIds || [],\n            ...customIds\n        ];\n    }\n    for (const key of Object.keys(mapOptions))if (mapOptions[key] === undefined) delete mapOptions[key];\n    const savedMapStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    // create the map instance and register it in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!container || !apiIsLoaded) return;\n        const { addMapInstance, removeMapInstance } = context;\n        // note: colorScheme (upcoming feature) isn't yet in the typings, remove once that is fixed:\n        const { mapId } = props;\n        const cacheKey = \"\".concat(mapId || \"default\", \":\").concat(renderingType || \"default\", \":\").concat(colorScheme || \"LIGHT\");\n        let mapDiv;\n        let map;\n        if (reuseMaps && CachedMapStack.has(cacheKey)) {\n            map = CachedMapStack.pop(cacheKey);\n            mapDiv = map.getDiv();\n            container.appendChild(mapDiv);\n            map.setOptions(mapOptions);\n            // detaching the element from the DOM lets the map fall back to its default\n            // size, setting the center will trigger reloading the map.\n            setTimeout(()=>map.setCenter(map.getCenter()), 0);\n        } else {\n            mapDiv = document.createElement(\"div\");\n            mapDiv.style.height = \"100%\";\n            container.appendChild(mapDiv);\n            map = new google.maps.Map(mapDiv, Object.assign(Object.assign(Object.assign({}, mapOptions), renderingType ? {\n                renderingType: renderingType\n            } : {}), colorScheme ? {\n                colorScheme: colorScheme\n            } : {}));\n        }\n        setMap(map);\n        addMapInstance(map, id);\n        if (defaultBounds) {\n            const { padding } = defaultBounds, defBounds = __rest(defaultBounds, [\n                \"padding\"\n            ]);\n            map.fitBounds(defBounds, padding);\n        } else if (!hasZoom || !hasCenter) {\n            map.fitBounds({\n                east: 180,\n                west: -180,\n                south: -90,\n                north: 90\n            });\n        }\n        // the savedMapState is used to restore the camera parameters when the mapId is changed\n        if (savedMapStateRef.current) {\n            const { mapId: savedMapId, cameraState: savedCameraState } = savedMapStateRef.current;\n            if (savedMapId !== mapId) {\n                map.setOptions(savedCameraState);\n            }\n        }\n        return ()=>{\n            savedMapStateRef.current = {\n                mapId,\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                cameraState: cameraStateRef.current\n            };\n            // detach the map-div from the dom\n            mapDiv.remove();\n            if (reuseMaps) {\n                // push back on the stack\n                CachedMapStack.push(cacheKey, map);\n            } else {\n                // remove all event-listeners to minimize the possibility of memory-leaks\n                google.maps.event.clearInstanceListeners(map);\n            }\n            setMap(null);\n            removeMapInstance(id);\n        };\n    }, // some dependencies are ignored in the list below:\n    //  - defaultBounds and the default* camera props will only be used once, and\n    //    changes should be ignored\n    //  - mapOptions has special hooks that take care of updating the options\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        container,\n        apiIsLoaded,\n        id,\n        // these props can't be changed after initialization and require a new\n        // instance to be created\n        props.mapId,\n        props.renderingType,\n        props.colorScheme\n    ]);\n    return [\n        map,\n        containerRef,\n        cameraStateRef\n    ];\n}\n_s16(useMapInstance, \"DZMQ8Zdrmcxeq6bZUR6EMFctnC8=\", false, function() {\n    return [\n        useApiIsLoaded,\n        useCallbackRef,\n        useTrackedCameraStateRef\n    ];\n});\nconst GoogleMapsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// ColorScheme and RenderingType are redefined here to make them usable before the\n// maps API has been fully loaded.\nconst ColorScheme = {\n    DARK: \"DARK\",\n    LIGHT: \"LIGHT\",\n    FOLLOW_SYSTEM: \"FOLLOW_SYSTEM\"\n};\nconst RenderingType = {\n    VECTOR: \"VECTOR\",\n    RASTER: \"RASTER\",\n    UNINITIALIZED: \"UNINITIALIZED\"\n};\nconst Map = (props)=>{\n    _s17();\n    const { children, id, className, style } = props;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const loadingStatus = useApiLoadingStatus();\n    if (!context) {\n        throw new Error(\"<Map> can only be used inside an <ApiProvider> component.\");\n    }\n    const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n    useMapCameraParams(map, cameraStateRef, props);\n    useMapEvents(map, props);\n    useMapOptions(map, props);\n    const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n    const isControlledExternally = !!props.controlled;\n    // disable interactions with the map for externally controlled maps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n        //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n        //   any default map controls pretty much useless\n        if (isDeckGlControlled) {\n            map.setOptions({\n                disableDefaultUI: true\n            });\n        }\n        // disable all control-inputs when the map is controlled externally\n        if (isDeckGlControlled || isControlledExternally) {\n            map.setOptions({\n                gestureHandling: \"none\",\n                keyboardShortcuts: false\n            });\n        }\n        return ()=>{\n            map.setOptions({\n                gestureHandling: props.gestureHandling,\n                keyboardShortcuts: props.keyboardShortcuts\n            });\n        };\n    }, [\n        map,\n        isDeckGlControlled,\n        isControlledExternally,\n        props.gestureHandling,\n        props.keyboardShortcuts\n    ]);\n    // setup a stable cameraOptions object that can be used as dependency\n    const center = props.center ? toLatLngLiteral(props.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _a, _b, _c;\n        return {\n            center: {\n                lat: lat !== null && lat !== void 0 ? lat : 0,\n                lng: lng !== null && lng !== void 0 ? lng : 0\n            },\n            zoom: (_a = props.zoom) !== null && _a !== void 0 ? _a : 0,\n            heading: (_b = props.heading) !== null && _b !== void 0 ? _b : 0,\n            tilt: (_c = props.tilt) !== null && _c !== void 0 ? _c : 0\n        };\n    }, [\n        lat,\n        lng,\n        props.zoom,\n        props.heading,\n        props.tilt\n    ]);\n    // externally controlled mode: reject all camera changes that don't correspond to changes in props\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !isControlledExternally) return;\n        map.moveCamera(cameraOptions);\n        const listener = map.addListener(\"bounds_changed\", ()=>{\n            map.moveCamera(cameraOptions);\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        isControlledExternally,\n        cameraOptions\n    ]);\n    const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>Object.assign({\n            width: \"100%\",\n            height: \"100%\",\n            position: \"relative\",\n            // when using deckgl, the map should be sent to the back\n            zIndex: isDeckGlControlled ? -1 : 0\n        }, style), [\n        style,\n        isDeckGlControlled\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            map\n        }), [\n        map\n    ]);\n    if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            style: Object.assign({\n                position: \"relative\"\n            }, className ? {} : combinedStyle),\n            className: className\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({\n        ref: mapRef,\n        \"data-testid\": \"map\",\n        style: className ? undefined : combinedStyle,\n        className: className\n    }, id ? {\n        id\n    } : {}), map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, {\n        value: contextValue\n    }, children) : null);\n};\n_s17(Map, \"AWqdKwgFin3XaAkt73rOuEv5ICk=\", false, function() {\n    return [\n        useApiLoadingStatus,\n        useMapInstance,\n        useMapCameraParams,\n        useMapEvents,\n        useMapOptions,\n        useDeckGLCameraUpdate\n    ];\n});\n_c2 = Map;\n// The deckGLViewProps flag here indicates to deck.gl that the Map component is\n// able to handle viewProps from deck.gl when deck.gl is used to control the map.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nMap.deckGLViewProps = true;\nconst shownMessages = new Set();\nfunction logErrorOnce() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    const key = JSON.stringify(args);\n    if (!shownMessages.has(key)) {\n        shownMessages.add(key);\n        console.error(...args);\n    }\n}\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */ const useMap = function() {\n    let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    _s18();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const { map } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n    if (ctx === null) {\n        logErrorOnce(\"useMap(): failed to retrieve APIProviderContext. \" + \"Make sure that the <APIProvider> component exists and that the \" + \"component you are calling `useMap()` from is a sibling of the \" + \"<APIProvider>.\");\n        return null;\n    }\n    const { mapInstances } = ctx;\n    // if an id is specified, the corresponding map or null is returned\n    if (id !== null) return mapInstances[id] || null;\n    // otherwise, return the closest ancestor\n    if (map) return map;\n    // finally, return the default map instance\n    return mapInstances[\"default\"] || null;\n};\n_s18(useMap, \"02oyNIqv7n0uhMRysGwaojH8Xj0=\");\nfunction useMapsLibrary(name) {\n    _s19();\n    const apiIsLoaded = useApiIsLoaded();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!apiIsLoaded || !ctx) return;\n        // Trigger loading the libraries via our proxy-method.\n        // The returned promise is ignored, since importLibrary will update loadedLibraries\n        // list in the context, triggering a re-render.\n        void ctx.importLibrary(name);\n    }, [\n        apiIsLoaded,\n        ctx,\n        name\n    ]);\n    return (ctx === null || ctx === void 0 ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n_s19(useMapsLibrary, \"E3X53atPXTwKH7JamUeR87Uqn9c=\", false, function() {\n    return [\n        useApiIsLoaded\n    ];\n});\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Internally used to bind events to Maps JavaScript API objects.\n * @internal\n */ function useMapsEventListener(target, name, callback) {\n    _s20();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!target || !name || !callback) return;\n        const listener = google.maps.event.addListener(target, name, callback);\n        return ()=>listener.remove();\n    }, [\n        target,\n        name,\n        callback\n    ]);\n}\n_s20(useMapsEventListener, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n/**\n * Internally used to copy values from props into API-Objects\n * whenever they change.\n *\n * @example\n *   usePropBinding(marker, 'position', position);\n *\n * @internal\n */ function usePropBinding(object, prop, value) {\n    _s21();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!object) return;\n        // eslint-disable-next-line react-hooks/immutability\n        object[prop] = value;\n    }, [\n        object,\n        prop,\n        value\n    ]);\n}\n_s21(usePropBinding, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Internally used to bind events to DOM nodes.\n * @internal\n */ function useDomEventListener(target, name, callback) {\n    _s22();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!target || !name || !callback) return;\n        target.addEventListener(name, callback);\n        return ()=>target.removeEventListener(name, callback);\n    }, [\n        target,\n        name,\n        callback\n    ]);\n}\n_s22(useDomEventListener, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n// Global style manager to track rendered styles and avoid duplicates\nclass GlobalStyleManager {\n    getStyleElement() {\n        if (!this.styleElement) {\n            this.styleElement = document.createElement(\"style\");\n            this.styleElement.setAttribute(\"data-rgm-anchor-styles\", \"\");\n            document.head.appendChild(this.styleElement);\n        }\n        return this.styleElement;\n    }\n    addAdvancedMarkerPointerEventsOverwrite() {\n        if (this.renderedStyles.has(\"marker-pointer-events\")) {\n            return;\n        }\n        const styleElement = this.getStyleElement();\n        styleElement.textContent += \"\\n      gmp-advanced-marker[data-origin='rgm'] {\\n        pointer-events: none !important;\\n      }\\n    \";\n        this.renderedStyles.add(\"marker-pointer-events\");\n    }\n    cleanup() {\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n            this.renderedStyles.clear();\n        }\n    }\n    constructor(){\n        this.renderedStyles = new Set();\n        this.styleElement = null;\n    }\n}\nconst globalStyleManager = new GlobalStyleManager();\nfunction isVersionGreaterEqual(major, minor) {\n    var _a;\n    if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.version)) return undefined;\n    const version = google.maps.version.split(\".\");\n    const currentMajor = parseInt(version[0], 10);\n    const currentMinor = parseInt(version[1], 10);\n    return currentMajor > major || currentMajor === major && currentMinor >= minor;\n}\n/* eslint-disable react-hooks/immutability */ // The `react-hooks/immutability` rule is disabled in this file because the\n// google.maps.marker.AdvancedMarkerElement object is designed to be mutated\n// directly. This is a common pattern when working with imperative APIs like\n// the Google Maps JavaScript API. While this goes against the principles of\n// immutable state in React, it is a necessary evil to integrate with the\n// Google Maps API. The mutations are carefully managed within the `useEffect`\n// hooks to ensure that they only happen when the props change.\n/**\n * Copy of the `google.maps.CollisionBehavior` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */ const CollisionBehavior = {\n    REQUIRED: \"REQUIRED\",\n    REQUIRED_AND_HIDES_OPTIONAL: \"REQUIRED_AND_HIDES_OPTIONAL\",\n    OPTIONAL_AND_HIDES_LOWER_PRIORITY: \"OPTIONAL_AND_HIDES_LOWER_PRIORITY\"\n};\nconst AdvancedMarkerContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// [xPosition, yPosition] when the top left corner is [0, 0]\n/**\n * @deprecated Using `anchorPosition` is deprecated.\n *   Use `anchorLeft` and `anchorTop` instead.\n */ const AdvancedMarkerAnchorPoint = {\n    TOP_LEFT: [\n        \"0%\",\n        \"0%\"\n    ],\n    TOP_CENTER: [\n        \"50%\",\n        \"0%\"\n    ],\n    TOP: [\n        \"50%\",\n        \"0%\"\n    ],\n    TOP_RIGHT: [\n        \"100%\",\n        \"0%\"\n    ],\n    LEFT_CENTER: [\n        \"0%\",\n        \"50%\"\n    ],\n    LEFT_TOP: [\n        \"0%\",\n        \"0%\"\n    ],\n    LEFT: [\n        \"0%\",\n        \"50%\"\n    ],\n    LEFT_BOTTOM: [\n        \"0%\",\n        \"100%\"\n    ],\n    RIGHT_TOP: [\n        \"100%\",\n        \"0%\"\n    ],\n    RIGHT: [\n        \"100%\",\n        \"50%\"\n    ],\n    RIGHT_CENTER: [\n        \"100%\",\n        \"50%\"\n    ],\n    RIGHT_BOTTOM: [\n        \"100%\",\n        \"100%\"\n    ],\n    BOTTOM_LEFT: [\n        \"0%\",\n        \"100%\"\n    ],\n    BOTTOM_CENTER: [\n        \"50%\",\n        \"100%\"\n    ],\n    BOTTOM: [\n        \"50%\",\n        \"100%\"\n    ],\n    BOTTOM_RIGHT: [\n        \"100%\",\n        \"100%\"\n    ],\n    CENTER: [\n        \"50%\",\n        \"50%\"\n    ]\n};\nconst AdvancedMarker = /*#__PURE__*/ _s23((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c3 = _s23((props, ref)=>{\n    _s23();\n    const { children, style, className, anchorPoint } = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n    const advancedMarkerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>marker ? {\n            marker\n        } : null, [\n        marker\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    if (!contentContainer) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, {\n        value: advancedMarkerContextValue\n    }, /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerContent, {\n        anchorPoint: anchorPoint,\n        styles: style,\n        className: className\n    }, children), contentContainer));\n}, \"qJce2Vx4SAXrecQVbB/locDIwzI=\", false, function() {\n    return [\n        useAdvancedMarker\n    ];\n})), \"qJce2Vx4SAXrecQVbB/locDIwzI=\", false, function() {\n    return [\n        useAdvancedMarker\n    ];\n});\n_c4 = AdvancedMarker;\nAdvancedMarker.displayName = \"AdvancedMarker\";\nfunction useAdvancedMarkerRef() {\n    _s24();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\n_s24(useAdvancedMarkerRef, \"FBQ4v4HcC4JdZrPyl/BGQ2M+tPY=\");\nfunction isAdvancedMarker(marker) {\n    return marker.content !== undefined;\n}\nfunction isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\nconst MarkerContent = (param)=>{\n    let { children, styles, className } = param;\n    /* AdvancedMarker div that user can give styles and classes */ return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: className,\n        style: styles\n    }, children);\n};\n_c5 = MarkerContent;\nfunction useAdvancedMarker(props) {\n    _s25();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const markerLibrary = useMapsLibrary(\"marker\");\n    const { children, onClick, className, onMouseEnter, onMouseLeave, onDrag, onDragStart, onDragEnd, collisionBehavior, clickable, draggable, position, title, zIndex, anchorPoint, anchorLeft, anchorTop } = props;\n    const numChildren = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n    // create an AdvancedMarkerElement instance and add it to the map once available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map || !markerLibrary) return;\n        const newMarker = new markerLibrary.AdvancedMarkerElement();\n        newMarker.map = map;\n        setMarker(newMarker);\n        // create the container for marker content if there are children\n        let contentElement = null;\n        if (numChildren > 0) {\n            contentElement = document.createElement(\"div\");\n            newMarker.content = contentElement;\n            setContentContainer(contentElement);\n        }\n        return ()=>{\n            newMarker.map = null;\n            contentElement === null || contentElement === void 0 ? void 0 : contentElement.remove();\n            setMarker(null);\n            setContentContainer(null);\n        };\n    }, [\n        map,\n        markerLibrary,\n        numChildren\n    ]);\n    // When no children are present we don't have our own wrapper div\n    // which usually gets the user provided className. In this case\n    // we set the className directly on the marker.content element that comes\n    // with the AdvancedMarker.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!(marker === null || marker === void 0 ? void 0 : marker.content) || !isElementNode(marker.content) || numChildren > 0) return;\n        marker.content.className = className !== null && className !== void 0 ? className : \"\";\n    }, [\n        marker,\n        className,\n        numChildren\n    ]);\n    useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, numChildren > 0);\n    // copy other props\n    usePropBinding(marker, \"position\", position);\n    usePropBinding(marker, \"title\", title !== null && title !== void 0 ? title : \"\");\n    usePropBinding(marker, \"zIndex\", zIndex);\n    usePropBinding(marker, \"collisionBehavior\", collisionBehavior);\n    // set gmpDraggable from props (when unspecified, it's true if any drag-event\n    // callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (draggable !== undefined) marker.gmpDraggable = draggable;\n        else if (onDrag || onDragStart || onDragEnd) marker.gmpDraggable = true;\n        else marker.gmpDraggable = false;\n    }, [\n        marker,\n        draggable,\n        onDrag,\n        onDragEnd,\n        onDragStart\n    ]);\n    // set gmpClickable from props (when unspecified, it's true if the onClick or one of\n    // the hover events callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const gmpClickable = clickable !== undefined || Boolean(onClick) || Boolean(onMouseEnter) || Boolean(onMouseLeave);\n        // gmpClickable is only available in beta version of the\n        // maps api (as of 2024-10-10)\n        marker.gmpClickable = gmpClickable;\n        // enable pointer events for the markers with custom content\n        if (gmpClickable && (marker === null || marker === void 0 ? void 0 : marker.content) && isElementNode(marker.content)) {\n            marker.content.style.pointerEvents = \"all\";\n            if (onClick) {\n                marker.content.style.cursor = \"pointer\";\n            }\n        }\n    }, [\n        marker,\n        clickable,\n        onClick,\n        onMouseEnter,\n        onMouseLeave\n    ]);\n    useMapsEventListener(marker, \"click\", onClick);\n    useMapsEventListener(marker, \"drag\", onDrag);\n    useMapsEventListener(marker, \"dragstart\", onDragStart);\n    useMapsEventListener(marker, \"dragend\", onDragEnd);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, \"mouseenter\", onMouseEnter);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, \"mouseleave\", onMouseLeave);\n    return [\n        marker,\n        contentContainer\n    ];\n}\n_s25(useAdvancedMarker, \"WUKBV+zUxqaU5AjpAVzs1hQQp9Q=\", false, function() {\n    return [\n        useMap,\n        useMapsLibrary,\n        useAdvancedMarkerAnchoring,\n        usePropBinding,\n        usePropBinding,\n        usePropBinding,\n        usePropBinding,\n        useMapsEventListener,\n        useMapsEventListener,\n        useMapsEventListener,\n        useMapsEventListener,\n        useDomEventListener,\n        useDomEventListener\n    ];\n});\nfunction useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, hasChildren) {\n    _s26();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker || !hasChildren) return;\n        // The anchorLeft and anchorTop options are available since version 3.62.9c\n        // With the release of 3.65 (~May 2026) there will no longer be a version\n        // that doesn't support it.\n        const anchorOptionsSupported = isVersionGreaterEqual(3, 62);\n        const contentElement = marker.content;\n        if (!contentElement || !isElementNode(contentElement)) return;\n        if (anchorLeft !== undefined || anchorTop !== undefined) {\n            if (!anchorOptionsSupported) {\n                console.warn(\"AdvancedMarker: The anchorLeft and anchorTop props are only supported \" + \"in Google Maps API version 3.62 and above. \" + \"The current version is \".concat(google.maps.version, \".\"));\n            }\n            marker.anchorLeft = anchorLeft;\n            marker.anchorTop = anchorTop;\n            // when anchorLeft and/or anchorTop are set, we'll ignore the anchorPoint\n            if (anchorPoint !== undefined) {\n                console.warn(\"AdvancedMarker: the anchorPoint prop is ignored when anchorLeft \" + \"and/or anchorTop are set.\");\n            }\n            return;\n        }\n        if (anchorPoint !== undefined) {\n            // TODO: add console.warn in a future version to inform about deprecation\n            const [x, y] = anchorPoint !== null && anchorPoint !== void 0 ? anchorPoint : AdvancedMarkerAnchorPoint[\"BOTTOM\"];\n            // NOTE: since x and y can be any valid CSS length-percentage\n            //   value, we need to use calc() to negate them.\n            const translateX = \"calc(-1 * \".concat(x, \")\");\n            const translateY = \"calc(-1 * \".concat(y, \")\");\n            if (anchorOptionsSupported) {\n                // implement anchorPoint using the new anchorLeft and anchorTop options\n                marker.anchorLeft = translateX;\n                marker.anchorTop = translateY;\n                // reset transform from legacy implementation\n                contentElement.style.transform = \"\";\n            } else {\n                // The \"translate(50%, 100%)\" counters and resets the default\n                // anchoring of the advanced marker element from the api\n                contentElement.style.transform = \"translate(50%, 100%) translate(\".concat(translateX, \", \").concat(translateY, \")\");\n                // data-origin is needed to identify the custom marker content in the\n                // InfoWindow component as well as in the global CSS used to disable\n                // the pointer event when anchor points are used in older Google Maps\n                // versions.\n                marker.dataset.origin = \"rgm\";\n                globalStyleManager.addAdvancedMarkerPointerEventsOverwrite();\n            }\n        }\n    }, [\n        marker,\n        anchorPoint,\n        anchorLeft,\n        anchorTop,\n        hasChildren\n    ]);\n}\n_s26(useAdvancedMarkerAnchoring, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nfunction setValueForStyles(element, styles, prevStyles) {\n    if (styles != null && typeof styles !== \"object\") {\n        throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n    }\n    const elementStyle = element.style;\n    // without `prevStyles`, just set all values\n    if (prevStyles == null) {\n        if (styles == null) return;\n        for(const styleName in styles){\n            if (!styles.hasOwnProperty(styleName)) continue;\n            setValueForStyle(elementStyle, styleName, styles[styleName]);\n        }\n        return;\n    }\n    // unset all styles in `prevStyles` that aren't in `styles`\n    for(const styleName in prevStyles){\n        if (prevStyles.hasOwnProperty(styleName) && (styles == null || !styles.hasOwnProperty(styleName))) {\n            // Clear style\n            const isCustomProperty = styleName.indexOf(\"--\") === 0;\n            if (isCustomProperty) {\n                elementStyle.setProperty(styleName, \"\");\n            } else if (styleName === \"float\") {\n                elementStyle.cssFloat = \"\";\n            } else {\n                elementStyle[styleName] = \"\";\n            }\n        }\n    }\n    // only assign values from `styles` that are different from `prevStyles`\n    if (styles == null) return;\n    for(const styleName in styles){\n        const value = styles[styleName];\n        if (styles.hasOwnProperty(styleName) && prevStyles[styleName] !== value) {\n            setValueForStyle(elementStyle, styleName, value);\n        }\n    }\n}\nfunction setValueForStyle(elementStyle, styleName, value) {\n    const isCustomProperty = styleName.indexOf(\"--\") === 0;\n    // falsy values will unset the style property\n    if (value == null || typeof value === \"boolean\" || value === \"\") {\n        if (isCustomProperty) {\n            elementStyle.setProperty(styleName, \"\");\n        } else if (styleName === \"float\") {\n            elementStyle.cssFloat = \"\";\n        } else {\n            elementStyle[styleName] = \"\";\n        }\n    } else if (isCustomProperty) {\n        elementStyle.setProperty(styleName, value);\n    } else if (typeof value === \"number\" && value !== 0 && !isUnitlessNumber(styleName)) {\n        elementStyle[styleName] = value + \"px\"; // Presumes implicit 'px' suffix for unitless numbers\n    } else {\n        if (styleName === \"float\") {\n            elementStyle.cssFloat = value;\n        } else {\n            elementStyle[styleName] = (\"\" + value).trim();\n        }\n    }\n}\n// CSS properties which accept numbers but are not in units of \"px\".\nconst unitlessNumbers = new Set([\n    \"animationIterationCount\",\n    \"aspectRatio\",\n    \"borderImageOutset\",\n    \"borderImageSlice\",\n    \"borderImageWidth\",\n    \"boxFlex\",\n    \"boxFlexGroup\",\n    \"boxOrdinalGroup\",\n    \"columnCount\",\n    \"columns\",\n    \"flex\",\n    \"flexGrow\",\n    \"flexPositive\",\n    \"flexShrink\",\n    \"flexNegative\",\n    \"flexOrder\",\n    \"gridArea\",\n    \"gridRow\",\n    \"gridRowEnd\",\n    \"gridRowSpan\",\n    \"gridRowStart\",\n    \"gridColumn\",\n    \"gridColumnEnd\",\n    \"gridColumnSpan\",\n    \"gridColumnStart\",\n    \"fontWeight\",\n    \"lineClamp\",\n    \"lineHeight\",\n    \"opacity\",\n    \"order\",\n    \"orphans\",\n    \"scale\",\n    \"tabSize\",\n    \"widows\",\n    \"zIndex\",\n    \"zoom\",\n    \"fillOpacity\",\n    \"floodOpacity\",\n    \"stopOpacity\",\n    \"strokeDasharray\",\n    \"strokeDashoffset\",\n    \"strokeMiterlimit\",\n    \"strokeOpacity\",\n    \"strokeWidth\"\n]);\nfunction isUnitlessNumber(name) {\n    return unitlessNumbers.has(name);\n}\n/**\n * Component to render an Info Window with the Maps JavaScript API\n */ const InfoWindow = (props)=>{\n    _s27();\n    const { // content options\n    children, headerContent, style, className, pixelOffset, // open options\n    anchor, shouldFocus, // events\n    onClose, onCloseClick } = props, // other options\n    volatileInfoWindowOptions = __rest(props, [\n        \"children\",\n        \"headerContent\",\n        \"style\",\n        \"className\",\n        \"pixelOffset\",\n        \"anchor\",\n        \"shouldFocus\",\n        \"onClose\",\n        \"onCloseClick\"\n    ]);\n    // ## create infowindow instance once the mapsLibrary is available.\n    const mapsLibrary = useMapsLibrary(\"maps\");\n    const [infoWindow, setInfoWindow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const contentContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const headerContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const infoWindowOptions = useMemoized(volatileInfoWindowOptions, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!mapsLibrary) return;\n        contentContainerRef.current = document.createElement(\"div\");\n        headerContainerRef.current = document.createElement(\"div\");\n        const opts = infoWindowOptions;\n        if (pixelOffset) {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (headerContent) {\n            // if headerContent is specified as string we can directly forward it,\n            // otherwise we'll pass the element the portal will render into\n            opts.headerContent = typeof headerContent === \"string\" ? headerContent : headerContainerRef.current;\n        }\n        // intentionally shadowing the state variables here\n        const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n        infoWindow.setContent(contentContainerRef.current);\n        setInfoWindow(infoWindow);\n        // unmount: remove infoWindow and content elements (note: close is called in a different effect-cleanup)\n        return ()=>{\n            var _a, _b;\n            infoWindow.setContent(null);\n            (_a = contentContainerRef.current) === null || _a === void 0 ? void 0 : _a.remove();\n            (_b = headerContainerRef.current) === null || _b === void 0 ? void 0 : _b.remove();\n            contentContainerRef.current = null;\n            headerContainerRef.current = null;\n            setInfoWindow(null);\n        };\n    }, // `infoWindowOptions` and other props are missing from dependencies:\n    //\n    // We don't want to re-create the infowindow instance\n    // when the options change.\n    // Updating the options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        mapsLibrary\n    ]);\n    // ---- update className and styles for `contentContainer`\n    // prevStyleRef stores previously applied style properties, so they can be\n    // removed when unset\n    const prevStyleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!infoWindow || !contentContainerRef.current) return;\n        setValueForStyles(contentContainerRef.current, style || null, prevStyleRef.current);\n        prevStyleRef.current = style || null;\n        if (className !== contentContainerRef.current.className) contentContainerRef.current.className = className || \"\";\n    }, [\n        infoWindow,\n        className,\n        style\n    ]);\n    // ---- update options\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!infoWindow) return;\n        const opts = infoWindowOptions;\n        if (!pixelOffset) {\n            opts.pixelOffset = null;\n        } else {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (!headerContent) {\n            opts.headerContent = null;\n        } else {\n            opts.headerContent = typeof headerContent === \"string\" ? headerContent : headerContainerRef.current;\n        }\n        infoWindow.setOptions(infoWindowOptions);\n    }, // dependency `infoWindow` isn't needed since options are also passed\n    // to the constructor when a new infoWindow is created.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        infoWindowOptions,\n        pixelOffset,\n        headerContent\n    ]);\n    // ## bind event handlers\n    useMapsEventListener(infoWindow, \"close\", onClose);\n    useMapsEventListener(infoWindow, \"closeclick\", onCloseClick);\n    // ---- open info window when content and map are available\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        // `anchor === null` means an anchor is defined but not ready yet.\n        if (!map || !infoWindow || anchor === null) return;\n        const isOpenedWithAnchor = !!anchor;\n        const openOptions = {\n            map\n        };\n        if (anchor) {\n            openOptions.anchor = anchor;\n            // Only do the infowindow adjusting when dealing with an AdvancedMarker\n            if (isAdvancedMarker(anchor) && anchor.content instanceof Element) {\n                const anchorBcr = anchor === null || anchor === void 0 ? void 0 : anchor.getBoundingClientRect();\n                // This checks whether or not the anchor has custom content with our own\n                // div wrapper. If not, that means we have a regular AdvancedMarker without\n                // children, or an AdvancedMarker that uses the anchorLeft/anchorTop props.\n                // In that case we do not want to adjust the infowindow since it is all handled correctly\n                // by the Google Maps API.\n                if (anchorBcr && anchor.dataset.origin === \"rgm\") {\n                    // We can safely typecast here since we control that element and we know that\n                    // it is a div\n                    const anchorDomContent = (_a = anchor.content.firstElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild;\n                    const contentBcr = anchorDomContent === null || anchorDomContent === void 0 ? void 0 : anchorDomContent.getBoundingClientRect();\n                    // center infowindow above marker\n                    const anchorOffsetX = contentBcr.x - anchorBcr.x + (contentBcr.width - anchorBcr.width) / 2;\n                    const anchorOffsetY = contentBcr.y - anchorBcr.y;\n                    const opts = infoWindowOptions;\n                    opts.pixelOffset = new google.maps.Size(pixelOffset ? pixelOffset[0] + anchorOffsetX : anchorOffsetX, pixelOffset ? pixelOffset[1] + anchorOffsetY : anchorOffsetY);\n                    infoWindow.setOptions(opts);\n                }\n            }\n        }\n        if (shouldFocus !== undefined) {\n            openOptions.shouldFocus = shouldFocus;\n        }\n        infoWindow.open(openOptions);\n        return ()=>{\n            // Note: when the infowindow has an anchor, it will automatically show up again when the\n            // anchor was removed from the map before infoWindow.close() is called but the it gets\n            // added back to the map after that.\n            // More information here: https://issuetracker.google.com/issues/343750849\n            if (isOpenedWithAnchor) infoWindow.set(\"anchor\", null);\n            infoWindow.close();\n        };\n    }, [\n        infoWindow,\n        anchor,\n        map,\n        shouldFocus,\n        infoWindowOptions,\n        pixelOffset\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, contentContainerRef.current && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainerRef.current), headerContainerRef.current !== null && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(headerContent, headerContainerRef.current));\n};\n_s27(InfoWindow, \"CUqPxc/ZFo+cir/zjZlow7bh/5s=\", false, function() {\n    return [\n        useMapsLibrary,\n        useMemoized,\n        useMapsEventListener,\n        useMapsEventListener,\n        useMap\n    ];\n});\n_c6 = InfoWindow;\n/**\n * Formats a location into a string representation suitable for Google Static Maps API.\n *\n * @param location - The location to format, can be either a string or an object with lat/lng properties\n * @returns A string representation of the location in the format \"lat,lng\" or the original string\n *\n * @example\n * // Returns \"40.714728,-73.998672\"\n * formatLocation({ lat: 40.714728, lng: -73.998672 })\n *\n * @example\n * // Returns \"New York, NY\"\n * formatLocation(\"New York, NY\")\n */ function formatLocation(location) {\n    return typeof location === \"string\" ? location : \"\".concat(location.lat, \",\").concat(location.lng);\n}\n// Used for removing the leading pipe from the param string\nfunction formatParam(string) {\n    return string.slice(1);\n}\n/**\n * Assembles marker parameters for static maps.\n *\n * This function takes an array of markers and groups them by their style properties.\n * It then creates a string representation of these markers, including their styles and locations,\n * which can be used as parameters for static map APIs.\n *\n * @param {StaticMapsMarker[]} [markers=[]] - An array of markers to be processed. Each marker can have properties such as color, label, size, scale, icon, anchor, and location.\n * @returns {string[]} An array of strings, each representing a group of markers with their styles and locations.\n *\n * @example\n * const markers = [\n *   { color: 'blue', label: 'A', size: 'mid', location: '40.714728,-73.998672' },\n *   { color: 'blue', label: 'B', size: 'mid', location: '40.714728,-73.998672' },\n *   { icon: 'http://example.com/icon.png', location: { lat: 40.714728, lng: -73.998672 } }\n * ];\n * const params = assembleMarkerParams(markers);\n * // Params will be an array of strings representing the marker parameters\n * Example output: [\n *   \"color:blue|label:A|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"color:blue|label:B|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"icon:http://example.com/icon.png|40.714728,-73.998672\"\n * ]\n */ function assembleMarkerParams() {\n    let markers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    const markerParams = [];\n    // Group markers by style\n    const markersByStyle = markers === null || markers === void 0 ? void 0 : markers.reduce((styles, marker)=>{\n        const { color = \"red\", label, size, scale, icon, anchor } = marker;\n        // Create a unique style key based on either icon properties or standard marker properties\n        const relevantProps = icon ? [\n            icon,\n            anchor,\n            scale\n        ] : [\n            color,\n            label,\n            size\n        ];\n        const key = relevantProps.filter(Boolean).join(\"-\");\n        styles[key] = styles[key] || [];\n        styles[key].push(marker);\n        return styles;\n    }, {});\n    Object.values(markersByStyle !== null && markersByStyle !== void 0 ? markersByStyle : {}).forEach((markers)=>{\n        let markerParam = \"\";\n        const { icon } = markers[0];\n        // Create marker style from first marker in group since all markers share the same style.\n        Object.entries(markers[0]).forEach((param)=>{\n            let [key, value] = param;\n            // Determine which properties to include based on whether marker uses custom icon\n            const relevantKeys = icon ? [\n                \"icon\",\n                \"anchor\",\n                \"scale\"\n            ] : [\n                \"color\",\n                \"label\",\n                \"size\"\n            ];\n            if (relevantKeys.includes(key)) {\n                markerParam += \"|\".concat(key, \":\").concat(value);\n            }\n        });\n        // Add location coordinates for each marker in the style group\n        // Handles both string locations and lat/lng object formats.\n        for (const marker of markers){\n            const location = typeof marker.location === \"string\" ? marker.location : \"\".concat(marker.location.lat, \",\").concat(marker.location.lng);\n            markerParam += \"|\".concat(location);\n        }\n        markerParams.push(markerParam);\n    });\n    return markerParams.map(formatParam);\n}\n// Style properties that can be applied to paths in the Static Maps API\nconst PATH_STYLE_KEYS = [\n    \"color\",\n    \"weight\",\n    \"fillcolor\",\n    \"geodesic\"\n];\n/**\n * Builds the style portion of a path parameter string.\n * @param path - The path object containing style properties\n * @returns A string with style parameters in the format \"|key:value\"\n */ function buildStyleParams(path) {\n    let styleParams = \"\";\n    PATH_STYLE_KEYS.forEach((key)=>{\n        if (path[key] !== undefined) {\n            styleParams += \"|\".concat(key, \":\").concat(path[key]);\n        }\n    });\n    return styleParams;\n}\n/**\n * Builds the coordinates portion of a path parameter string.\n * @param coordinates - Either a string or array of location objects\n * @returns A string with coordinates in the format \"|lat,lng|lat,lng\"\n */ function buildCoordinateParams(coordinates) {\n    if (typeof coordinates === \"string\") {\n        return \"|\".concat(decodeURIComponent(coordinates));\n    }\n    return coordinates.map((location)=>\"|\".concat(formatLocation(location))).join(\"\");\n}\n/**\n * Assembles path parameters for the Static Maps API from an array of paths.\n *\n * This function constructs a string of path parameters for each path. Each path parameter string\n * includes the style properties and the coordinates of the paths.\n *\n * @param {Array<StaticMapsPath>} [paths=[]] - An array of paths to be assembled into path parameters.\n * @returns {Array<string>} An array of path parameter strings.\n *\n * @example\n * ```typescript\n * const paths = [\n *   {\n *     color: 'red',\n *     weight: 5,\n *     coordinates: [\n *       { lat: 40.714728, lng: -73.998672 },\n *       { lat: 40.718217, lng: -73.998284 }\n *     ]\n *   }\n * ];\n *\n * const pathParams = assemblePathParams(paths);\n * // Output: ['color:red|weight:5|40.714728,-73.998672|40.718217,-73.998284']\n * ```\n */ function assemblePathParams() {\n    let paths = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return paths.map((path)=>{\n        const styleParams = buildStyleParams(path);\n        const coordinateParams = buildCoordinateParams(path.coordinates);\n        const pathParam = styleParams + coordinateParams;\n        return formatParam(pathParam);\n    });\n}\n/**\n * Converts an array of Google Maps style objects into an array of style strings\n * compatible with the Google Static Maps API.\n *\n * @param styles - An array of Google Maps MapTypeStyle objects that define the styling rules\n * @returns An array of formatted style strings ready to be used with the Static Maps API\n *\n * @example\n * const styles = [{\n *   featureType: \"road\",\n *   elementType: \"geometry\",\n *   stylers: [{color: \"#ff0000\"}, {weight: 1}]\n * }];\n *\n * const styleStrings = assembleMapTypeStyles(styles);\n * // Returns: [\"|feature:road|element:geometry|color:0xff0000|weight:1\"]\n *\n * Each style string follows the format:\n * \"feature:{featureType}|element:{elementType}|{stylerName}:{stylerValue}\"\n *\n * Note: Color values with hexadecimal notation (#) are automatically converted\n * to the required 0x format for the Static Maps API.\n */ function assembleMapTypeStyles(styles) {\n    return styles.map((mapTypeStyle)=>{\n        const { featureType, elementType, stylers = [] } = mapTypeStyle;\n        let styleString = \"\";\n        if (featureType) {\n            styleString += \"|feature:\".concat(featureType);\n        }\n        if (elementType) {\n            styleString += \"|element:\".concat(elementType);\n        }\n        for (const styler of stylers){\n            Object.entries(styler).forEach((param)=>{\n                let [name, value] = param;\n                styleString += \"|\".concat(name, \":\").concat(String(value).replace(\"#\", \"0x\"));\n            });\n        }\n        return styleString;\n    }).map(formatParam);\n}\nconst STATIC_MAPS_BASE = \"https://maps.googleapis.com/maps/api/staticmap\";\n/**\n * Creates a URL for the Google Static Maps API with the specified parameters.\n *\n * @param {Object} options - The configuration options for the static map\n * @param {string} options.apiKey - Your Google Maps API key (required)\n * @param {number} options.width - The width of the map image in pixels (required)\n * @param {number} options.height - The height of the map image in pixels (required)\n * @param {StaticMapsLocation} [options.center] - The center point of the map (lat/lng or address).\n *  Required if no markers or paths or \"visible locations\" are provided.\n * @param {number} [options.zoom] - The zoom level of the map. Required if no markers or paths or \"visible locations\" are provided.\n * @param {1|2|4} [options.scale] - The resolution of the map (1, 2, or 4)\n * @param {string} [options.format] - The image format (png, png8, png32, gif, jpg, jpg-baseline)\n * @param {string} [options.mapType] - The type of map (roadmap, satellite, terrain, hybrid)\n * @param {string} [options.language] - The language of the map labels\n * @param {string} [options.region] - The region code for the map\n * @param {string} [options.map_id] - The Cloud-based map style ID\n * @param {StaticMapsMarker[]} [options.markers=[]] - Array of markers to display on the map\n * @param {StaticMapsPath[]} [options.paths=[]] - Array of paths to display on the map\n * @param {StaticMapsLocation[]} [options.visible=[]] - Array of locations that should be visible on the map\n * @param {MapTypeStyle[]} [options.style=[]] - Array of style objects to customize the map appearance\n *\n * @returns {string} The complete Google Static Maps API URL\n *\n * @throws {Error} If API key is not provided\n * @throws {Error} If width or height is not provided\n *\n * @example\n * const url = createStaticMapsUrl({\n *   apiKey: 'YOUR_API_KEY',\n *   width: 600,\n *   height: 400,\n *   center: { lat: 40.714728, lng: -73.998672 },\n *   zoom: 12,\n *   markers: [\n *     {\n *       location: { lat: 40.714728, lng: -73.998672 },\n *       color: 'red',\n *       label: 'A'\n *     }\n *   ],\n *   paths: [\n *     {\n *       coordinates: [\n *         { lat: 40.714728, lng: -73.998672 },\n *         { lat: 40.719728, lng: -73.991672 }\n *       ],\n *       color: '0x0000ff',\n *       weight: 5\n *     }\n *   ],\n *   style: [\n *     {\n *       featureType: 'road',\n *       elementType: 'geometry',\n *       stylers: [{color: '#00ff00'}]\n *     }\n *   ]\n * });\n *\n * // Results in URL similar to:\n * // https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY\n * // &size=600x400\n * // &center=40.714728,-73.998672&zoom=12\n * // &markers=color:red|label:A|40.714728,-73.998672\n * // &path=color:0x0000ff|weight:5|40.714728,-73.998672|40.719728,-73.991672\n * // &style=feature:road|element:geometry|color:0x00ff00\n */ function createStaticMapsUrl(param) {\n    let { apiKey, width, height, center, zoom, scale, format, mapType, language, region, mapId, markers = [], paths = [], visible = [], style = [] } = param;\n    if (!apiKey) {\n        console.warn(\"API key is required\");\n    }\n    if (!width || !height) {\n        console.warn(\"Width and height are required\");\n    }\n    const params = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        key: apiKey,\n        size: \"\".concat(width, \"x\").concat(height)\n    }, center && {\n        center: formatLocation(center)\n    }), zoom && {\n        zoom\n    }), scale && {\n        scale\n    }), format && {\n        format\n    }), mapType && {\n        maptype: mapType\n    }), language && {\n        language\n    }), region && {\n        region\n    }), mapId && {\n        map_id: mapId\n    });\n    const url = new URL(STATIC_MAPS_BASE);\n    // Params that don't need special handling\n    Object.entries(params).forEach((param)=>{\n        let [key, value] = param;\n        url.searchParams.append(key, String(value));\n    });\n    // Assemble Markers\n    for (const markerParam of assembleMarkerParams(markers)){\n        url.searchParams.append(\"markers\", markerParam);\n    }\n    // Assemble Paths\n    for (const pathParam of assemblePathParams(paths)){\n        url.searchParams.append(\"path\", pathParam);\n    }\n    // Assemble visible locations\n    if (visible.length) {\n        url.searchParams.append(\"visible\", visible.map((location)=>formatLocation(location)).join(\"|\"));\n    }\n    // Assemble Map Type Styles\n    for (const styleString of assembleMapTypeStyles(style)){\n        url.searchParams.append(\"style\", styleString);\n    }\n    return url.toString();\n}\nconst StaticMap = (props)=>{\n    const { url, className } = props;\n    if (!url) throw new Error(\"URL is required\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        className: className,\n        src: url,\n        width: \"100%\"\n    });\n};\n_c7 = StaticMap;\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */ const ControlPosition = {\n    TOP_LEFT: 1,\n    TOP_CENTER: 2,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    LEFT_CENTER: 4,\n    LEFT_TOP: 5,\n    LEFT: 5,\n    LEFT_BOTTOM: 6,\n    RIGHT_TOP: 7,\n    RIGHT: 7,\n    RIGHT_CENTER: 8,\n    RIGHT_BOTTOM: 9,\n    BOTTOM_LEFT: 10,\n    BOTTOM_CENTER: 11,\n    BOTTOM: 11,\n    BOTTOM_RIGHT: 12,\n    CENTER: 13,\n    BLOCK_START_INLINE_START: 14,\n    BLOCK_START_INLINE_CENTER: 15,\n    BLOCK_START_INLINE_END: 16,\n    INLINE_START_BLOCK_CENTER: 17,\n    INLINE_START_BLOCK_START: 18,\n    INLINE_START_BLOCK_END: 19,\n    INLINE_END_BLOCK_START: 20,\n    INLINE_END_BLOCK_CENTER: 21,\n    INLINE_END_BLOCK_END: 22,\n    BLOCK_END_INLINE_START: 23,\n    BLOCK_END_INLINE_CENTER: 24,\n    BLOCK_END_INLINE_END: 25\n};\nconst MapControl = (param)=>{\n    let { children, position } = param;\n    _s28();\n    const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const controls = map.controls[position];\n        controls.push(controlContainer);\n        return ()=>{\n            const controlsArray = controls.getArray();\n            // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n            if (!controlsArray) return;\n            const index = controlsArray.indexOf(controlContainer);\n            controls.removeAt(index);\n        };\n    }, [\n        controlContainer,\n        map,\n        position\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\n_s28(MapControl, \"GWhrPCjHyQkJZ2cqIea0Zsdo0OI=\", false, function() {\n    return [\n        useMap\n    ];\n});\n_c8 = MapControl;\nfunction useMarker(props) {\n    _s29();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const { onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut } = props, markerOptions = __rest(props, [\n        \"onClick\",\n        \"onDrag\",\n        \"onDragStart\",\n        \"onDragEnd\",\n        \"onMouseOver\",\n        \"onMouseOut\"\n    ]);\n    const { position, draggable } = markerOptions;\n    // create marker instance and add to the map once the map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) {\n            if (map === undefined) console.error(\"<Marker> has to be inside a Map component.\");\n            return;\n        }\n        const newMarker = new google.maps.Marker(markerOptions);\n        newMarker.setMap(map);\n        setMarker(newMarker);\n        return ()=>{\n            newMarker.setMap(null);\n            setMarker(null);\n        };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map\n    ]);\n    // attach and re-attach event-handlers when any of the properties change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const m = marker;\n        // Add event listeners\n        const gme = google.maps.event;\n        if (onClick) gme.addListener(m, \"click\", onClick);\n        if (onDrag) gme.addListener(m, \"drag\", onDrag);\n        if (onDragStart) gme.addListener(m, \"dragstart\", onDragStart);\n        if (onDragEnd) gme.addListener(m, \"dragend\", onDragEnd);\n        if (onMouseOver) gme.addListener(m, \"mouseover\", onMouseOver);\n        if (onMouseOut) gme.addListener(m, \"mouseout\", onMouseOut);\n        marker.setDraggable(Boolean(draggable));\n        return ()=>{\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDrag,\n        onDragStart,\n        onDragEnd,\n        onMouseOver,\n        onMouseOut\n    ]);\n    // update markerOptions (note the dependencies aren't properly checked\n    // here, we just assume that setOptions is smart enough to not waste a\n    // lot of time updating values that didn't change)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (markerOptions) marker.setOptions(markerOptions);\n    }, [\n        marker,\n        markerOptions\n    ]);\n    // update position when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Should not update position when draggable\n        if (draggable || !position || !marker) return;\n        marker.setPosition(position);\n    }, [\n        draggable,\n        position,\n        marker\n    ]);\n    return marker;\n}\n_s29(useMarker, \"4XdkpqW0TK7CEh7g7xo7x5bHhRU=\", false, function() {\n    return [\n        useMap\n    ];\n});\n/**\n * Component to render a marker on a map\n */ const Marker = /*#__PURE__*/ _s30((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c9 = _s30((props, ref)=>{\n    _s30();\n    const marker = useMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n}, \"X8uSd1rl6ws6EwUC+zm+JeM+A3k=\", false, function() {\n    return [\n        useMarker\n    ];\n})), \"X8uSd1rl6ws6EwUC+zm+JeM+A3k=\", false, function() {\n    return [\n        useMarker\n    ];\n});\n_c10 = Marker;\nMarker.displayName = \"Marker\";\nfunction useMarkerRef() {\n    _s31();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\n_s31(useMarkerRef, \"FBQ4v4HcC4JdZrPyl/BGQ2M+tPY=\");\n/**\n * Component to configure the appearance of an AdvancedMarker\n */ const Pin = (props)=>{\n    _s32();\n    var _a;\n    const advancedMarker = (_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) === null || _a === void 0 ? void 0 : _a.marker;\n    const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    // Create Pin View instance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!advancedMarker) {\n            if (advancedMarker === undefined) {\n                console.error(\"The <Pin> component can only be used inside <AdvancedMarker>.\");\n            }\n            return;\n        }\n        if (props.glyph && props.children) {\n            logErrorOnce(\"The <Pin> component only uses children to render the glyph if both the glyph property and children are present.\");\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n            logErrorOnce(\"Passing multiple children to the <Pin> component might lead to unexpected results.\");\n        }\n        const pinViewOptions = Object.assign({}, props);\n        const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n        // Set glyph to glyph container if children are present (rendered via portal).\n        // If both props.glyph and props.children are present, props.children takes priority.\n        if (props.children) {\n            pinElement.glyph = glyphContainer;\n        }\n        // Set content of Advanced Marker View to the Pin View element\n        // Here we are selecting the anchor container.\n        // The hierarchy is as follows:\n        // \"advancedMarker.content\" (from google) -> \"anchor container\"\n        const markerContent = (_a = advancedMarker.content) === null || _a === void 0 ? void 0 : _a.firstChild;\n        while(markerContent === null || markerContent === void 0 ? void 0 : markerContent.firstChild){\n            markerContent.removeChild(markerContent.firstChild);\n        }\n        if (markerContent) {\n            markerContent.appendChild(pinElement.element);\n        }\n    }, [\n        advancedMarker,\n        glyphContainer,\n        props\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\n_s32(Pin, \"USBKEQcWQZODuZ3cwquju/JeJfU=\");\n_c11 = Pin;\nconst mapLinear = (x, a1, a2, b1, b2)=>b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = (zoom)=>{\n    if (zoom <= 10) {\n        return 30;\n    }\n    if (zoom >= 15.5) {\n        return 67.5;\n    }\n    // range [10...14]\n    if (zoom <= 14) {\n        return mapLinear(zoom, 10, 14, 30, 45);\n    }\n    // range [14...15.5]\n    return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the Google map when updating the view state\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = (param)=>{\n    let { viewState } = param;\n    const pitch = viewState.pitch;\n    const gmZoom = viewState.zoom + 1;\n    const maxTilt = getMapMaxTilt(gmZoom);\n    return Object.assign(Object.assign({}, viewState), {\n        fovy: 25,\n        pitch: Math.min(maxTilt, pitch)\n    });\n};\n //# sourceMappingURL=index.modern.mjs.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;\n$RefreshReg$(_c, \"APIProvider\");\n$RefreshReg$(_c1, \"AuthFailureMessage\");\n$RefreshReg$(_c2, \"Map\");\n$RefreshReg$(_c3, \"AdvancedMarker$forwardRef\");\n$RefreshReg$(_c4, \"AdvancedMarker\");\n$RefreshReg$(_c5, \"MarkerContent\");\n$RefreshReg$(_c6, \"InfoWindow\");\n$RefreshReg$(_c7, \"StaticMap\");\n$RefreshReg$(_c8, \"MapControl\");\n$RefreshReg$(_c9, \"Marker$forwardRef\");\n$RefreshReg$(_c10, \"Marker\");\n$RefreshReg$(_c11, \"Pin\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzL2Rpc3QvaW5kZXgubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFLO0FBQzVIO0FBQ0M7QUFFMUMsMkRBQTJEO0FBQzNELE1BQU1jLFVBQVU7QUFFaEI7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDhEQUE4RCxHQUc5RCxTQUFTQyxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUlDLElBQUksR0FBR1AsSUFBSUMsT0FBT0sscUJBQXFCLENBQUNULElBQUlVLElBQUlQLEVBQUVRLE1BQU0sRUFBRUQsSUFBSztRQUNwRSxJQUFJVCxFQUFFTyxPQUFPLENBQUNMLENBQUMsQ0FBQ08sRUFBRSxJQUFJLEtBQUtOLE9BQU9DLFNBQVMsQ0FBQ08sb0JBQW9CLENBQUNMLElBQUksQ0FBQ1AsR0FBR0csQ0FBQyxDQUFDTyxFQUFFLEdBQ3pFUixDQUFDLENBQUNDLENBQUMsQ0FBQ08sRUFBRSxDQUFDLEdBQUdWLENBQUMsQ0FBQ0csQ0FBQyxDQUFDTyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPUjtBQUNYO0FBRUEsU0FBU1csVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9sQixHQUFHO2dCQUFFcUIsT0FBT3JCO1lBQUk7UUFBRTtRQUMxRixTQUFTeUIsU0FBU1AsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPbEIsR0FBRztnQkFBRXFCLE9BQU9yQjtZQUFJO1FBQUU7UUFDN0YsU0FBU3VCLEtBQUtHLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHUixRQUFRTyxPQUFPUixLQUFLLElBQUlELE1BQU1TLE9BQU9SLEtBQUssRUFBRVUsSUFBSSxDQUFDTixXQUFXRztRQUFXO1FBQzdHRixLQUFLLENBQUNQLFlBQVlBLFVBQVVhLEtBQUssQ0FBQ2hCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFFQSxPQUFPTSxvQkFBb0IsYUFBYUEsa0JBQWtCLFNBQVVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxPQUFPO0lBQzFGLElBQUlqQyxJQUFJLElBQUlrQyxNQUFNRDtJQUNsQixPQUFPakMsRUFBRW1DLElBQUksR0FBRyxtQkFBbUJuQyxFQUFFK0IsS0FBSyxHQUFHQSxPQUFPL0IsRUFBRWdDLFVBQVUsR0FBR0EsWUFBWWhDO0FBQ25GO0FBRUEsTUFBTW9DLG1CQUFtQjtJQUNyQkMsWUFBWTtJQUNaQyxTQUFTO0lBQ1RDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxjQUFjO0FBQ2xCO0FBRUEsTUFBTUMsb0JBQW9CO0FBQzFCOzs7OztDQUtDLEdBQ0QsTUFBTUM7SUFDRjs7Ozs7Ozs7S0FRQyxHQUNELE9BQU9DLEtBQUtDLE1BQU0sRUFBRUMscUJBQXFCLEVBQUU7UUFDdkMsT0FBT2xDLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSW1DLElBQUlDO1lBQ1IsTUFBTUMsWUFBWUosT0FBT0ksU0FBUyxHQUFHSixPQUFPSSxTQUFTLENBQUNDLEtBQUssQ0FBQyxPQUFPLEVBQUU7WUFDckUsTUFBTUMsbUJBQW1CLElBQUksQ0FBQ0MsZUFBZSxDQUFDUDtZQUM5QyxJQUFJLENBQUNRLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDUjtZQUNwQix1RUFBdUU7WUFDdkUsb0RBQW9EO1lBQ3BELG1FQUFtRTtZQUNuRSxzRUFBc0U7WUFDdEUsb0JBQW9CO1lBQ3BCLElBQUksQ0FBQ0UsS0FBSyxDQUFDRCxLQUFLUSxPQUFPQyxNQUFNLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVSxJQUFJLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVSxhQUFhLEVBQUU7Z0JBQ2hJLDBEQUEwRDtnQkFDMUQsSUFBSSxDQUFDLElBQUksQ0FBQ0MsbUJBQW1CLEVBQUU7b0JBQzNCLElBQUksQ0FBQ0MsYUFBYSxHQUFHeEIsaUJBQWlCRyxNQUFNO2dCQUNoRDtnQkFDQSxJQUFJLENBQUNzQiw0QkFBNEI7WUFDckMsT0FDSztnQkFDRCxJQUFJLENBQUNGLG1CQUFtQixHQUFHUjtnQkFDM0IsSUFBSSxDQUFDVyxpQkFBaUIsQ0FBQ2pCO1lBQzNCO1lBQ0EsSUFBSSxJQUFJLENBQUNjLG1CQUFtQixJQUN4QixJQUFJLENBQUNBLG1CQUFtQixLQUFLUixrQkFBa0I7Z0JBQy9DWSxRQUFRQyxJQUFJLENBQUMsbUVBQ1IseUVBQ0E7WUFDVDtZQUNBLE1BQU1DLGtCQUFrQjtnQkFBQzttQkFBV2hCO2FBQVU7WUFDOUMsTUFBTTdCLFFBQVE4QyxHQUFHLENBQUNELGdCQUFnQkUsR0FBRyxDQUFDaEMsQ0FBQUEsT0FBUXFCLE9BQU9DLElBQUksQ0FBQ0MsYUFBYSxDQUFDdkI7UUFDNUU7SUFDSjtJQUNBOztLQUVDLEdBQ0QsT0FBT2lCLGdCQUFnQlAsTUFBTSxFQUFFO1FBQzNCLE9BQU87WUFDSEEsT0FBT3VCLENBQUM7WUFDUnZCLE9BQU93QixHQUFHO1lBQ1Z4QixPQUFPeUIsUUFBUTtZQUNmekIsT0FBTzBCLE1BQU07WUFDYjFCLE9BQU8yQixrQkFBa0I7WUFDekIzQixPQUFPNEIsZUFBZTtTQUN6QixDQUFDQyxJQUFJLENBQUM7SUFDWDtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxPQUFPWixrQkFBa0JqQixNQUFNLEVBQUU7UUFDN0IsSUFBSSxDQUFDVSxPQUFPQyxNQUFNLEVBQ2RELE9BQU9DLE1BQU0sR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEVBQ25CRixPQUFPQyxNQUFNLENBQUNDLElBQUksR0FBRyxDQUFDO1FBQzFCLElBQUlGLE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ3JDTSxRQUFRaEMsS0FBSyxDQUFDO1lBQ2Q7UUFDSjtRQUNBLElBQUk0QyxhQUFhO1FBQ2pCLE1BQU1DLFVBQVU7WUFDWixJQUFJRCxZQUNBLE9BQU9BO1lBQ1hBLGFBQWEsSUFBSXZELFFBQVEsQ0FBQ0QsU0FBU0U7Z0JBQy9CLElBQUkwQjtnQkFDSixNQUFNOEIsZ0JBQWdCQyxTQUFTQyxhQUFhLENBQUM7Z0JBQzdDLE1BQU1DLFlBQVksSUFBSUM7Z0JBQ3RCLEtBQUssTUFBTSxDQUFDWixLQUFLbkQsTUFBTSxJQUFJZixPQUFPK0UsT0FBTyxDQUFDckMsUUFBUztvQkFDL0MsTUFBTXNDLGVBQWVkLElBQUllLE9BQU8sQ0FBQyxVQUFVbkYsQ0FBQUEsSUFBSyxNQUFNQSxDQUFDLENBQUMsRUFBRSxDQUFDb0YsV0FBVztvQkFDdEVMLFVBQVVNLEdBQUcsQ0FBQ0gsY0FBY0ksT0FBT3JFO2dCQUN2QztnQkFDQThELFVBQVVNLEdBQUcsQ0FBQyxXQUFXO2dCQUN6Qk4sVUFBVU0sR0FBRyxDQUFDLFlBQVk7Z0JBQzFCVCxjQUFjVyxLQUFLLEdBQUc7Z0JBQ3RCWCxjQUFjWSxHQUFHLEdBQUcvQyxvQkFBcUIsTUFBS3NDLFVBQVVVLFFBQVE7Z0JBQ2hFYixjQUFjYyxLQUFLLEdBQ2YsQ0FBQyxDQUFDNUMsS0FBSytCLFNBQVNjLGFBQWEsQ0FBQyxnQkFBZSxNQUFPLFFBQVE3QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0QyxLQUFLLEtBQUs7Z0JBQ3RHZCxjQUFjZ0IsT0FBTyxHQUFHO29CQUNwQixJQUFJLENBQUNqQyxhQUFhLEdBQUd4QixpQkFBaUJJLE1BQU07b0JBQzVDLElBQUksQ0FBQ3FCLDRCQUE0QjtvQkFDakN4QyxPQUFPLElBQUlhLE1BQU07Z0JBQ3JCO2dCQUNBcUIsT0FBT3VDLHNCQUFzQixHQUFHO29CQUM1QixJQUFJLENBQUNsQyxhQUFhLEdBQUd4QixpQkFBaUJHLE1BQU07b0JBQzVDLElBQUksQ0FBQ3NCLDRCQUE0QjtvQkFDakMxQztnQkFDSjtnQkFDQW9DLE9BQU93QyxjQUFjLEdBQUc7b0JBQ3BCLElBQUksQ0FBQ25DLGFBQWEsR0FBR3hCLGlCQUFpQkssWUFBWTtvQkFDbEQsSUFBSSxDQUFDb0IsNEJBQTRCO2dCQUNyQztnQkFDQSxJQUFJLENBQUNELGFBQWEsR0FBR3hCLGlCQUFpQkUsT0FBTztnQkFDN0MsSUFBSSxDQUFDdUIsNEJBQTRCO2dCQUNqQ2lCLFNBQVNrQixJQUFJLENBQUNDLE1BQU0sQ0FBQ3BCO1lBQ3pCO1lBQ0EsT0FBT0Y7UUFDWDtRQUNBLHFFQUFxRTtRQUNyRSx5Q0FBeUM7UUFDekNuQixPQUFPQyxJQUFJLENBQUNDLGFBQWEsR0FBR3dDLENBQUFBLGNBQWV0QixVQUFVaEQsSUFBSSxDQUFDLElBQU00QixPQUFPQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ3dDO0lBQzlGO0lBQ0E7O0tBRUMsR0FDRCxPQUFPckMsK0JBQStCO1FBQ2xDLEtBQUssTUFBTXNDLE1BQU0sSUFBSSxDQUFDOUMsU0FBUyxDQUFFO1lBQzdCOEMsR0FBRyxJQUFJLENBQUN2QyxhQUFhO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0RqQixvQkFBb0JpQixhQUFhLEdBQUd4QixpQkFBaUJDLFVBQVU7QUFDL0Q7O0NBRUMsR0FDRE0sb0JBQW9CVSxTQUFTLEdBQUcsRUFBRTtBQUVsQyxNQUFNK0MsMkJBQTJCO0FBQ2pDLE1BQU1DLHlDQUF5QztJQUMxQyw4QkFBcUMsT0FBUnhHO0NBQ2pDO0FBQ0QsTUFBTXlHLG1DQUFxQnZILGdEQUFtQixDQUFDO0FBQy9DOztDQUVDLEdBQ0QsU0FBU3lIOztJQUNMLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUd6SCwrQ0FBUUEsQ0FBQyxDQUFDO0lBQ2xELE1BQU0wSCxpQkFBaUIsU0FBQ0M7WUFBYUMsc0VBQUs7UUFDdENILGdCQUFnQkksQ0FBQUEsWUFBYzNHLE9BQU80RyxNQUFNLENBQUM1RyxPQUFPNEcsTUFBTSxDQUFDLENBQUMsR0FBR0QsWUFBWTtnQkFBRSxDQUFDRCxHQUFHLEVBQUVEO1lBQVk7SUFDbEc7SUFDQSxNQUFNSSxvQkFBb0I7WUFBQ0gsc0VBQUs7UUFDNUJILGdCQUFnQixDQUFDM0Q7WUFDYixJQUFJQyxLQUFLNkQ7WUFBSTlELEVBQUUsQ0FBQ0MsR0FBRztZQUFFLElBQUlpRSxZQUFZbkgsT0FBT2lELElBQUk7Z0JBQUMsT0FBT0MsT0FBTyxXQUFXQSxLQUFLQSxLQUFLO2FBQUc7WUFDdkYsT0FBT2lFO1FBQ1g7SUFDSjtJQUNBLE1BQU1DLG9CQUFvQjtRQUN0QlIsZ0JBQWdCLENBQUM7SUFDckI7SUFDQSxPQUFPO1FBQUVEO1FBQWNFO1FBQWdCSztRQUFtQkU7SUFBa0I7QUFDaEY7R0FmU1Y7QUFnQlQ7OztDQUdDLEdBQ0QsU0FBU1csdUJBQXVCQyxLQUFLOztJQUNqQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRXZFLFlBQVksRUFBRSxFQUFFLEdBQUdtRSxPQUFPSyxpQkFBaUIzSCxPQUFPc0gsT0FBTztRQUFDO1FBQVU7UUFBVztRQUFVO1FBQVc7S0FBWTtJQUMxSixNQUFNLENBQUNNLFFBQVFDLFVBQVUsR0FBRzFJLCtDQUFRQSxDQUFDMEQsb0JBQW9CaUIsYUFBYTtJQUN0RSxNQUFNLENBQUNnRSxpQkFBaUJDLGlCQUFpQixHQUFHM0ksaURBQVVBLENBQUMsQ0FBQzBJLGlCQUFpQkU7UUFDckUsT0FBT0YsZUFBZSxDQUFDRSxPQUFPM0YsSUFBSSxDQUFDLEdBQzdCeUYsa0JBQ0F6SCxPQUFPNEcsTUFBTSxDQUFDNUcsT0FBTzRHLE1BQU0sQ0FBQyxDQUFDLEdBQUdhLGtCQUFrQjtZQUFFLENBQUNFLE9BQU8zRixJQUFJLENBQUMsRUFBRTJGLE9BQU81RyxLQUFLO1FBQUM7SUFDMUYsR0FBRyxDQUFDO0lBQ0osTUFBTTZHLGtCQUFrQi9JLDhDQUFPQSxDQUFDLElBQU1pRSxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVXlCLElBQUksQ0FBQyxNQUFNO1FBQUN6QjtLQUFVO0lBQzVILE1BQU1FLG1CQUFtQm5FLDhDQUFPQSxDQUFDLElBQU1nSixLQUFLQyxTQUFTLENBQUM5SCxPQUFPNEcsTUFBTSxDQUFDO1lBQUVRO1lBQVFDO1FBQVEsR0FBR0Msa0JBQWtCO1FBQUNGO1FBQVFDO1FBQVNDO0tBQWU7SUFDNUksTUFBTS9ELGdCQUFnQnZFLGtEQUFXQSxDQUFDLENBQUNnRCxPQUFTdkIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUN4RSxJQUFJbUM7WUFDSixJQUFJNkUsZUFBZSxDQUFDekYsS0FBSyxFQUFFO2dCQUN2QixPQUFPeUYsZUFBZSxDQUFDekYsS0FBSztZQUNoQztZQUNBLElBQUksQ0FBRSxFQUFDWSxLQUFLUyxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0MsSUFBSSxNQUFNLFFBQVFWLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1csYUFBYSxHQUFHO2dCQUM3SCxNQUFNLElBQUl4QixNQUFNLDZEQUNaO1lBQ1I7WUFDQSxNQUFNZ0csTUFBTSxNQUFNM0UsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ3ZCO1lBQ25EMEYsaUJBQWlCO2dCQUFFMUY7Z0JBQU1qQixPQUFPZ0g7WUFBSTtZQUNwQyxPQUFPQTtRQUNYLElBQUk7UUFBQ047S0FBZ0I7SUFDckJ4SSxnREFBU0EsQ0FBQztRQUNMLEtBQU13QixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUNuQyxJQUFJO29CQUNBLE1BQU1pQyxTQUFTMUMsT0FBTzRHLE1BQU0sQ0FBQzt3QkFBRTFDLEtBQUtrRDtvQkFBTyxHQUFHRTtvQkFDOUMsSUFBSUQsU0FDQTNFLE9BQU91QixDQUFDLEdBQUdvRDtvQkFDZixJQUFJLENBQUNPLG9CQUFvQixRQUFRQSxvQkFBb0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsZ0JBQWdCckgsTUFBTSxJQUFJLEdBQzdGbUMsT0FBT0ksU0FBUyxHQUFHOEU7b0JBQ3ZCLElBQUlsRixPQUFPc0YsT0FBTyxLQUFLQyxhQUNuQnZGLE9BQU9zRixPQUFPLEdBQUcsS0FDakJ0RixPQUFPc0YsT0FBTyxHQUFHLEtBQ2pCLE9BQU90RixPQUFPc0YsT0FBTztvQkFDekIsSUFBSXRGLE9BQU80QixlQUFlLEtBQUsyRCxXQUMzQnZGLE9BQU80QixlQUFlLEdBQUcyQjt5QkFDeEIsSUFBSXZELE9BQU80QixlQUFlLEtBQUssSUFDaEMsT0FBTzVCLE9BQU80QixlQUFlO29CQUNqQyxNQUFNOUIsb0JBQW9CQyxJQUFJLENBQUNDLFFBQVE2RSxDQUFBQSxTQUFVQyxVQUFVRDtvQkFDM0QsS0FBSyxNQUFNdkYsUUFBUTt3QkFBQzt3QkFBUTsyQkFBV2M7cUJBQVUsQ0FBRTt3QkFDL0MsTUFBTVMsY0FBY3ZCO29CQUN4QjtvQkFDQSxJQUFJa0YsUUFBUTt3QkFDUkE7b0JBQ0o7Z0JBQ0osRUFDQSxPQUFPdEYsT0FBTztvQkFDVixJQUFJdUYsU0FBUzt3QkFDVEEsUUFBUXZGO29CQUNaLE9BQ0s7d0JBQ0RnQyxRQUFRaEMsS0FBSyxDQUFDLCtEQUErREE7b0JBQ2pGO2dCQUNKO1lBQ0osRUFBQztJQUNMLEdBQ0EsdURBQXVEO0lBQ3ZEO1FBQUN3RjtRQUFRUTtRQUFpQjVFO0tBQWlCO0lBQzNDLE9BQU87UUFDSHVFO1FBQ0FFO1FBQ0FsRTtJQUNKO0FBQ0o7SUFoRVN5RDtBQWlFVCxTQUFTa0IsK0JBQStCakIsS0FBSzs7SUFDekMsTUFBTWtCLDhCQUE4QnRKLDhDQUFPQSxDQUFDLElBQU1vSSxNQUFNbUIsdUJBQXVCLEdBQ3pFLE9BQ0FsQyx3Q0FBd0M7UUFBQ2UsTUFBTW1CLHVCQUF1QjtLQUFDO0lBQzdFLE9BQU9EO0FBQ1g7SUFMU0Q7QUFNVDs7Q0FFQyxHQUNELE1BQU1HLGNBQWNwQixDQUFBQTs7SUFDaEIsTUFBTSxFQUFFcUIsUUFBUSxFQUFFLEdBQUdyQixPQUFPc0IsY0FBYzVJLE9BQU9zSCxPQUFPO1FBQUM7S0FBVztJQUNwRSxNQUFNLEVBQUVYLFlBQVksRUFBRUUsY0FBYyxFQUFFSyxpQkFBaUIsRUFBRUUsaUJBQWlCLEVBQUUsR0FBR1Y7SUFDL0UsTUFBTSxFQUFFa0IsTUFBTSxFQUFFRSxlQUFlLEVBQUVsRSxhQUFhLEVBQUUsR0FBR3lELHVCQUF1QnVCO0lBQzFFLE1BQU1KLDhCQUE4QkQsK0JBQStCSztJQUNuRSxNQUFNQyxlQUFlM0osOENBQU9BLENBQUMsSUFBTztZQUNoQ3lIO1lBQ0FFO1lBQ0FLO1lBQ0FFO1lBQ0FRO1lBQ0FFO1lBQ0FsRTtZQUNBNEU7UUFDSixJQUFJO1FBQ0E3QjtRQUNBRTtRQUNBSztRQUNBRTtRQUNBUTtRQUNBRTtRQUNBbEU7UUFDQTRFO0tBQ0g7SUFDRCxxQkFBUXZKLGdEQUFtQixDQUFDdUgsbUJBQW1Cc0MsUUFBUSxFQUFFO1FBQUUxSCxPQUFPeUg7SUFBYSxHQUFHRjtBQUN0RjtJQXpCTUQ7O1FBRTZFaEM7UUFDNUJXO1FBQ2ZrQjs7O0tBSmxDRztBQTJCTjs7O0NBR0MsR0FDRCxTQUFTSyxhQUFhMUUsR0FBRyxFQUFFaUQsS0FBSztJQUM1Qix5RUFBeUU7SUFDekUsMkVBQTJFO0lBQzNFLHVEQUF1RDtJQUN2RCx5REFBeUQ7SUFDekQsS0FBSyxNQUFNMEIsWUFBWUMsZUFBZ0I7UUFDbkMsd0VBQXdFO1FBQ3hFLDBEQUEwRDtRQUMxRCxNQUFNQyxVQUFVNUIsS0FBSyxDQUFDMEIsU0FBUztRQUMvQixNQUFNRyxZQUFZQyxtQkFBbUIsQ0FBQ0osU0FBUztRQUMvQyxzREFBc0Q7UUFDdEQxSixnREFBU0EsQ0FBQztZQUNOLElBQUksQ0FBQytFLEtBQ0Q7WUFDSixJQUFJLENBQUM2RSxTQUNEO1lBQ0osTUFBTUcsV0FBVzNGLE9BQU9DLElBQUksQ0FBQzJGLEtBQUssQ0FBQ0MsV0FBVyxDQUFDbEYsS0FBSzhFLFdBQVcsQ0FBQ0s7Z0JBQzVETixRQUFRTyxlQUFlTixXQUFXOUUsS0FBS21GO1lBQzNDO1lBQ0EsT0FBTyxJQUFNSCxTQUFTSyxNQUFNO1FBQ2hDLEdBQUc7WUFBQ3JGO1lBQUs4RTtZQUFXRDtTQUFRO0lBQ2hDO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNPLGVBQWVFLElBQUksRUFBRXRGLEdBQUcsRUFBRXVGLFFBQVE7SUFDdkMsSUFBSTNHO0lBQ0osTUFBTXVHLEtBQUs7UUFDUEc7UUFDQXRGO1FBQ0F3RixRQUFRLENBQUM7UUFDVEMsV0FBVztRQUNYQyxNQUFNLEtBQVE7SUFDbEI7SUFDQSxJQUFJQyxpQkFBaUJDLFFBQVEsQ0FBQ04sT0FBTztRQUNqQyxNQUFNTyxXQUFXVjtRQUNqQixNQUFNVyxTQUFTOUYsSUFBSStGLFNBQVM7UUFDNUIsTUFBTUMsT0FBT2hHLElBQUlpRyxPQUFPO1FBQ3hCLE1BQU1DLFVBQVVsRyxJQUFJbUcsVUFBVSxNQUFNO1FBQ3BDLE1BQU1DLE9BQU9wRyxJQUFJcUcsT0FBTyxNQUFNO1FBQzlCLE1BQU1DLFNBQVN0RyxJQUFJdUcsU0FBUztRQUM1QixJQUFJLENBQUNULFVBQVUsQ0FBQ1EsVUFBVSxDQUFDRSxPQUFPQyxRQUFRLENBQUNULE9BQU87WUFDOUNwRyxRQUFRQyxJQUFJLENBQUMsMkRBQ1QsZ0VBQ0E7UUFDUjtRQUNBZ0csU0FBU0wsTUFBTSxHQUFHO1lBQ2RNLFFBQVEsQ0FBQ0EsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU9ZLE1BQU0sRUFBQyxLQUFNO2dCQUFFQyxLQUFLO2dCQUFHQyxLQUFLO1lBQUU7WUFDOUZaLE1BQU1BLFFBQVE7WUFDZEUsU0FBU0E7WUFDVEUsTUFBTUE7WUFDTkUsUUFBUSxDQUFDQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0ksTUFBTSxFQUFDLEtBQU07Z0JBQ3pFRyxPQUFPO2dCQUNQQyxNQUFNO2dCQUNOQyxPQUFPLENBQUM7Z0JBQ1JDLE1BQU0sQ0FBQztZQUNYO1FBQ0o7UUFDQSxPQUFPbkI7SUFDWCxPQUNLLElBQUlvQixnQkFBZ0JyQixRQUFRLENBQUNOLE9BQU87UUFDckMsSUFBSSxDQUFDQyxVQUNELE1BQU0sSUFBSXhILE1BQU07UUFDcEIsTUFBTW1KLGFBQWEvQjtRQUNuQitCLFdBQVdDLFFBQVEsR0FBRzVCLFNBQVM0QixRQUFRO1FBQ3ZDRCxXQUFXekIsU0FBUyxHQUFHO1FBQ3ZCeUIsV0FBV3hCLElBQUksR0FBRyxJQUFNSCxTQUFTRyxJQUFJO1FBQ3JDd0IsV0FBVzFCLE1BQU0sR0FBRztZQUNoQjRCLFFBQVEsQ0FBQyxDQUFDeEksS0FBSzJHLFNBQVM2QixNQUFNLE1BQU0sUUFBUXhJLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhILE1BQU0sRUFBQyxLQUFNO1lBQ3JGVyxTQUFTOUIsU0FBUzhCLE9BQU87UUFDN0I7UUFDQSxPQUFPSDtJQUNYO0lBQ0EsT0FBTy9CO0FBQ1g7QUFDQTs7O0NBR0MsR0FDRCxNQUFNSixzQkFBc0I7SUFDeEJ1QyxpQkFBaUI7SUFDakJDLGlCQUFpQjtJQUNqQkMsU0FBUztJQUNUQyxlQUFlO0lBQ2ZDLFlBQVk7SUFDWkMsUUFBUTtJQUNSQyxXQUFXO0lBQ1hDLGFBQWE7SUFDYkMsa0JBQWtCO0lBQ2xCQyxRQUFRO0lBQ1JDLGtDQUFrQztJQUNsQ0MsMEJBQTBCO0lBQzFCQyxvQkFBb0I7SUFDcEJDLGFBQWE7SUFDYkMsWUFBWTtJQUNaQyxhQUFhO0lBQ2JDLHFCQUFxQjtJQUNyQkMsd0JBQXdCO0lBQ3hCQyxlQUFlO0lBQ2ZDLGVBQWU7SUFDZkMsZUFBZTtJQUNmLGtFQUFrRTtJQUNsRSx5RUFBeUU7SUFDekUsV0FBVztJQUNYQyxpQkFBaUI7QUFDckI7QUFDQSxNQUFNaEQsbUJBQW1CO0lBQ3JCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELE1BQU1zQixrQkFBa0I7SUFDcEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNckMsaUJBQWlCNUksT0FBTzRNLElBQUksQ0FBQzdEO0FBRW5DOzs7O0NBSUMsR0FDRCxTQUFTOEQsWUFBWTlMLEtBQUs7O0lBQ3RCLE1BQU0rTCxNQUFNNU4sNkNBQU1BLENBQUMrSTtJQUNuQmhKLGdEQUFTQSxDQUFDO1FBQ042TixJQUFJQyxPQUFPLEdBQUdoTTtJQUNsQjtJQUNBLDRDQUE0QztJQUM1QyxPQUFPK0wsSUFBSUMsT0FBTztBQUN0QjtJQVBTRjtBQVNULFNBQVNHLFlBQVlqTSxLQUFLLEVBQUVrTSxPQUFPOztJQUMvQixNQUFNQyxXQUFXTCxZQUFZOUw7SUFDN0IsT0FBT2xDLDhDQUFPQSxDQUFDO1FBQ1gsSUFBSXFPLFlBQVlELFFBQVFDLFVBQVVuTSxRQUFRO1lBQ3RDLE9BQU9tTTtRQUNYO1FBQ0EsT0FBT25NO0lBQ1gsR0FBRztRQUFDQTtRQUFPbU07UUFBVUQ7S0FBUTtBQUNqQztJQVJTRDs7UUFDWUg7OztBQVNyQixTQUFTTSx1QkFBdUJDLE1BQU0sRUFBRUMsWUFBWSxFQUFFSixPQUFPOztJQUN6RCx1REFBdUQ7SUFDdkRoTyxnREFBU0EsQ0FBQ21PLFFBQVE7UUFBQ0osWUFBWUssY0FBY0o7S0FBUztBQUMxRDtJQUhTRTtBQUtULFNBQVNHLHFCQUFxQkYsTUFBTSxFQUFFQyxZQUFZOztJQUM5Q0YsdUJBQXVCQyxRQUFRQyxjQUFjNU4sNENBQVdBO0FBQzVEO0lBRlM2Tjs7UUFDTEg7OztBQUdKLE1BQU1JLGdCQUFnQixJQUFJQyxJQUFJO0lBQzFCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNEOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGNBQWN6SixHQUFHLEVBQUUwSixRQUFROztJQUNoQzs7Ozs7S0FLQyxHQUNELE1BQU1DLGFBQWEsQ0FBQztJQUNwQixNQUFNZixPQUFPNU0sT0FBTzRNLElBQUksQ0FBQ2M7SUFDekIsS0FBSyxNQUFNeEosT0FBTzBJLEtBQU07UUFDcEIsSUFBSSxDQUFDVyxjQUFjSyxHQUFHLENBQUMxSixNQUNuQjtRQUNKeUosVUFBVSxDQUFDekosSUFBSSxHQUFHd0osUUFBUSxDQUFDeEosSUFBSTtJQUNuQztJQUNBLG9EQUFvRDtJQUNwRCwyRUFBMkU7SUFDM0UsdUVBQXVFO0lBQ3ZFLDhEQUE4RDtJQUM5RG9KLHFCQUFxQjtRQUNqQixJQUFJLENBQUN0SixLQUNEO1FBQ0pBLElBQUk2SixVQUFVLENBQUNGO0lBQ25CLEdBQUc7UUFBQ0E7S0FBVztBQUNmLDZDQUE2QyxHQUNqRDtJQXhCU0Y7O1FBa0JMSDs7O0FBUUosU0FBU1E7O0lBQ0wsSUFBSWxMO0lBQ0osT0FBTyxDQUFDLENBQUNBLEtBQUt6RCxpREFBVUEsQ0FBQ2dILG1CQUFrQixNQUFPLFFBQVF2RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcyRSxNQUFNLEtBQUt0RixpQkFBaUJDLFVBQVU7QUFDaEk7SUFIUzRMO0FBS1Q7OztDQUdDLEdBQ0QsU0FBU0Msc0JBQXNCL0osR0FBRyxFQUFFaUQsS0FBSzs7SUFDckMsTUFBTSxFQUFFK0csUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR2hIO0lBQ2hDLE1BQU1pSCxxQkFBcUIsQ0FBQyxDQUFDRjtJQUM3QjVPLHNEQUFlQSxDQUFDO1FBQ1osSUFBSSxDQUFDNEUsT0FBTyxDQUFDaUssV0FDVDtRQUNKLE1BQU0sRUFBRUUsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFNBQVNuRSxPQUFPLEVBQUVvRSxPQUFPbEUsSUFBSSxFQUFFSixJQUFJLEVBQUUsR0FBR2lFO1FBQ3JFakssSUFBSXVLLFVBQVUsQ0FBQztZQUNYekUsUUFBUTtnQkFBRWEsS0FBS3dEO2dCQUFVdkQsS0FBS3dEO1lBQVU7WUFDeENsRTtZQUNBRTtZQUNBSixNQUFNQSxPQUFPO1FBQ2pCO0lBQ0osR0FBRztRQUFDaEc7UUFBS2lLO0tBQVU7SUFDbkIsT0FBT0M7QUFDWDtLQWZTSDtBQWlCVCxTQUFTUyxnQkFBZ0JDLEdBQUc7SUFDeEIsSUFBSSxDQUFDQSxPQUFPLE9BQU9BLFFBQVEsVUFDdkIsT0FBTztJQUNYLElBQUksQ0FBRSxVQUFTQSxPQUFPLFNBQVNBLEdBQUUsR0FDN0IsT0FBTztJQUNYLE9BQU9qRSxPQUFPQyxRQUFRLENBQUNnRSxJQUFJOUQsR0FBRyxLQUFLSCxPQUFPQyxRQUFRLENBQUNnRSxJQUFJN0QsR0FBRztBQUM5RDtBQUNBLFNBQVM4RCxhQUFhQyxDQUFDLEVBQUVDLENBQUM7SUFDdEIsSUFBSSxDQUFDRCxLQUFLLENBQUNDLEdBQ1AsT0FBTztJQUNYLE1BQU1DLElBQUlDLGdCQUFnQkg7SUFDMUIsTUFBTUksSUFBSUQsZ0JBQWdCRjtJQUMxQixJQUFJQyxFQUFFbEUsR0FBRyxLQUFLb0UsRUFBRXBFLEdBQUcsSUFBSWtFLEVBQUVqRSxHQUFHLEtBQUttRSxFQUFFbkUsR0FBRyxFQUNsQyxPQUFPO0lBQ1gsT0FBTztBQUNYO0FBQ0EsU0FBU2tFLGdCQUFnQkwsR0FBRztJQUN4QixJQUFJRCxnQkFBZ0JDLE1BQ2hCLE9BQU9BO0lBQ1gsT0FBT0EsSUFBSS9ELE1BQU07QUFDckI7QUFFQSxTQUFTc0UsbUJBQW1CaEwsR0FBRyxFQUFFaUwsY0FBYyxFQUFFdkIsUUFBUTs7SUFDckQsTUFBTTVELFNBQVM0RCxTQUFTNUQsTUFBTSxHQUFHZ0YsZ0JBQWdCcEIsU0FBUzVELE1BQU0sSUFBSTtJQUNwRSxJQUFJYSxNQUFNO0lBQ1YsSUFBSUMsTUFBTTtJQUNWLElBQUlkLFVBQVVVLE9BQU9DLFFBQVEsQ0FBQ1gsT0FBT2EsR0FBRyxLQUFLSCxPQUFPQyxRQUFRLENBQUNYLE9BQU9jLEdBQUcsR0FBRztRQUN0RUQsTUFBTWIsT0FBT2EsR0FBRztRQUNoQkMsTUFBTWQsT0FBT2MsR0FBRztJQUNwQjtJQUNBLE1BQU1aLE9BQU9RLE9BQU9DLFFBQVEsQ0FBQ2lELFNBQVMxRCxJQUFJLElBQ3BDMEQsU0FBUzFELElBQUksR0FDYjtJQUNOLE1BQU1FLFVBQVVNLE9BQU9DLFFBQVEsQ0FBQ2lELFNBQVN4RCxPQUFPLElBQzFDd0QsU0FBU3hELE9BQU8sR0FDaEI7SUFDTixNQUFNRSxPQUFPSSxPQUFPQyxRQUFRLENBQUNpRCxTQUFTdEQsSUFBSSxJQUNwQ3NELFNBQVN0RCxJQUFJLEdBQ2I7SUFDTiw2RUFBNkU7SUFDN0UsdUVBQXVFO0lBQ3ZFLDBFQUEwRTtJQUMxRSw4QkFBOEI7SUFDOUJoTCxzREFBZUEsQ0FBQztRQUNaLElBQUksQ0FBQzRFLEtBQ0Q7UUFDSixNQUFNa0wsYUFBYSxDQUFDO1FBQ3BCLElBQUlDLGNBQWM7UUFDbEIsSUFBSXhFLFFBQVEsUUFDUkMsUUFBUSxRQUNQcUUsQ0FBQUEsZUFBZWxDLE9BQU8sQ0FBQ2pELE1BQU0sQ0FBQ2EsR0FBRyxLQUFLQSxPQUNuQ3NFLGVBQWVsQyxPQUFPLENBQUNqRCxNQUFNLENBQUNjLEdBQUcsS0FBS0EsR0FBRSxHQUFJO1lBQ2hEc0UsV0FBV3BGLE1BQU0sR0FBRztnQkFBRWE7Z0JBQUtDO1lBQUk7WUFDL0J1RSxjQUFjO1FBQ2xCO1FBQ0EsSUFBSW5GLFNBQVMsUUFBUWlGLGVBQWVsQyxPQUFPLENBQUMvQyxJQUFJLEtBQUtBLE1BQU07WUFDdkRrRixXQUFXbEYsSUFBSSxHQUFHQTtZQUNsQm1GLGNBQWM7UUFDbEI7UUFDQSxJQUFJakYsWUFBWSxRQUFRK0UsZUFBZWxDLE9BQU8sQ0FBQzdDLE9BQU8sS0FBS0EsU0FBUztZQUNoRWdGLFdBQVdoRixPQUFPLEdBQUdBO1lBQ3JCaUYsY0FBYztRQUNsQjtRQUNBLElBQUkvRSxTQUFTLFFBQVE2RSxlQUFlbEMsT0FBTyxDQUFDM0MsSUFBSSxLQUFLQSxNQUFNO1lBQ3ZEOEUsV0FBVzlFLElBQUksR0FBR0E7WUFDbEIrRSxjQUFjO1FBQ2xCO1FBQ0EsSUFBSUEsYUFBYTtZQUNibkwsSUFBSXVLLFVBQVUsQ0FBQ1c7UUFDbkI7SUFDSjtBQUNKO0tBakRTRjtBQW1EVCxNQUFNSSxxQkFBcUI7SUFDdkIsTUFBTUMsUUFBUTtRQUNWQyxVQUFVO1FBQ1ZDLEtBQUs7UUFDTEMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxTQUFTO1FBQ1RDLFVBQVU7UUFDVkMsV0FBVztRQUNYQyxnQkFBZ0I7UUFDaEJDLFVBQVU7UUFDVkMsT0FBTztRQUNQQyxZQUFZO1FBQ1pDLFNBQVM7SUFDYjtJQUNBLHFCQUFRdlIsZ0RBQW1CLENBQUMsT0FBTztRQUFFeVEsT0FBT0E7SUFBTSxpQkFDOUN6USxnREFBbUIsQ0FBQyxNQUFNLE1BQU0scUNBQ2hDQSxnREFBbUIsQ0FBQyxLQUFLLE1BQ3JCLDJIQUNBQSxnREFBbUIsQ0FBQyxRQUFRLE1BQU0sdUJBQ2xDO0FBQ1o7TUF2Qk13UTtBQXlCTixTQUFTZ0I7O0lBQ0wsTUFBTSxDQUFDQyxJQUFJQyxNQUFNLEdBQUd4UiwrQ0FBUUEsQ0FBQztJQUM3QixNQUFNZ08sTUFBTTlOLGtEQUFXQSxDQUFDLENBQUMrQixRQUFVdVAsTUFBTXZQLFFBQVE7UUFBQ3VQO0tBQU07SUFDeEQsT0FBTztRQUFDRDtRQUFJdkQ7S0FBSTtBQUNwQjtLQUpTc0Q7QUFNVDs7Q0FFQyxHQUNELFNBQVNHOztJQUNMLE1BQU1oSixTQUFTdUc7SUFDZixPQUFPdkcsV0FBV3RGLGlCQUFpQkcsTUFBTTtBQUM3QztLQUhTbU87O1FBQ1V6Qzs7O0FBSW5CLFNBQVMwQzs7SUFDTCxNQUFNLEdBQUdDLFlBQVksR0FBRzFSLGlEQUFVQSxDQUFDMlIsQ0FBQUEsSUFBS0EsSUFBSSxHQUFHO0lBQy9DLE9BQU9EO0FBQ1g7S0FIU0Q7QUFLVCxTQUFTRyxtQkFBbUIzTSxHQUFHLEVBQUU4SSxHQUFHO0lBQ2hDLE1BQU1oRCxTQUFTOUYsSUFBSStGLFNBQVM7SUFDNUIsTUFBTUMsT0FBT2hHLElBQUlpRyxPQUFPO0lBQ3hCLE1BQU1DLFVBQVVsRyxJQUFJbUcsVUFBVSxNQUFNO0lBQ3BDLE1BQU1DLE9BQU9wRyxJQUFJcUcsT0FBTyxNQUFNO0lBQzlCLE1BQU1DLFNBQVN0RyxJQUFJdUcsU0FBUztJQUM1QixJQUFJLENBQUNULFVBQVUsQ0FBQ1EsVUFBVSxDQUFDRSxPQUFPQyxRQUFRLENBQUNULE9BQU87UUFDOUNwRyxRQUFRQyxJQUFJLENBQUMscUVBQ1QsZ0VBQ0E7SUFDUjtJQUNBLHFHQUFxRztJQUNyRzdELE9BQU80RyxNQUFNLENBQUNrRyxJQUFJQyxPQUFPLEVBQUU7UUFDdkJqRCxRQUFRLENBQUNBLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPWSxNQUFNLEVBQUMsS0FBTTtZQUFFQyxLQUFLO1lBQUdDLEtBQUs7UUFBRTtRQUM5RlosTUFBTUEsUUFBUTtRQUNkRSxTQUFTQTtRQUNURSxNQUFNQTtJQUNWO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU3dHLHlCQUF5QjVNLEdBQUc7O0lBQ2pDLE1BQU15TSxjQUFjRDtJQUNwQixNQUFNMUQsTUFBTTVOLDZDQUFNQSxDQUFDO1FBQ2Y0SyxRQUFRO1lBQUVhLEtBQUs7WUFBR0MsS0FBSztRQUFFO1FBQ3pCVixTQUFTO1FBQ1RFLE1BQU07UUFDTkosTUFBTTtJQUNWO0lBQ0EsNkVBQTZFO0lBQzdFLGdFQUFnRTtJQUNoRSw4RUFBOEU7SUFDOUUsb0NBQW9DO0lBQ3BDL0ssZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUMrRSxLQUNEO1FBQ0osTUFBTWdGLFdBQVczRixPQUFPQyxJQUFJLENBQUMyRixLQUFLLENBQUNDLFdBQVcsQ0FBQ2xGLEtBQUssa0JBQWtCO1lBQ2xFMk0sbUJBQW1CM00sS0FBSzhJO1lBQ3hCLHFFQUFxRTtZQUNyRSxzRUFBc0U7WUFDdEUscUVBQXFFO1lBQ3JFLG1DQUFtQztZQUNuQzJEO1FBQ0o7UUFDQSxPQUFPLElBQU16SCxTQUFTSyxNQUFNO0lBQ2hDLEdBQUc7UUFBQ3JGO1FBQUt5TTtLQUFZO0lBQ3JCLE9BQU8zRDtBQUNYO0tBMUJTOEQ7O1FBQ2VKOzs7QUEyQnhCOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsTUFBTUs7SUFDRixPQUFPakQsSUFBSTFKLEdBQUcsRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDYSxPQUFPLENBQUNiLElBQUksSUFBSSxJQUFJLENBQUNhLE9BQU8sQ0FBQ2IsSUFBSSxDQUFDM0QsTUFBTSxHQUFHO0lBQzNEO0lBQ0EsT0FBT3VRLElBQUk1TSxHQUFHLEVBQUU7UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDYSxPQUFPLENBQUNiLElBQUksRUFDbEIsT0FBTztRQUNYLE9BQU8sSUFBSSxDQUFDYSxPQUFPLENBQUNiLElBQUksQ0FBQzRNLEdBQUcsTUFBTTtJQUN0QztJQUNBLE9BQU8zTixLQUFLZSxHQUFHLEVBQUVuRCxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQ2dFLE9BQU8sQ0FBQ2IsSUFBSSxFQUNsQixJQUFJLENBQUNhLE9BQU8sQ0FBQ2IsSUFBSSxHQUFHLEVBQUU7UUFDMUIsSUFBSSxDQUFDYSxPQUFPLENBQUNiLElBQUksQ0FBQ2YsSUFBSSxDQUFDcEM7SUFDM0I7QUFDSjtBQUNBOFAsZUFBZTlMLE9BQU8sR0FBRyxDQUFDO0FBQzFCOzs7Ozs7Q0FNQyxHQUNELFNBQVNnTSxlQUFlOUosS0FBSyxFQUFFK0osT0FBTzs7SUFDbEMsTUFBTUMsY0FBY1Y7SUFDcEIsTUFBTSxDQUFDdk0sS0FBS2tOLE9BQU8sR0FBR3BTLCtDQUFRQSxDQUFDO0lBQy9CLE1BQU0sQ0FBQ3FTLFdBQVdDLGFBQWEsR0FBR2hCO0lBQ2xDLE1BQU1uQixpQkFBaUIyQix5QkFBeUI1TTtJQUNoRCxNQUFNLEVBQUUwQyxFQUFFLEVBQUUySyxhQUFhLEVBQUVDLGFBQWEsRUFBRUMsV0FBVyxFQUFFQyxjQUFjLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUVDLFdBQVcsRUFBRSxHQUFHM0ssT0FBTzBHLGFBQWFoTyxPQUFPc0gsT0FBTztRQUFDO1FBQU07UUFBaUI7UUFBaUI7UUFBZTtRQUFrQjtRQUFlO1FBQWE7UUFBaUI7S0FBYztJQUNyUyxNQUFNNEssVUFBVTVLLE1BQU0rQyxJQUFJLEtBQUsvQixhQUFhaEIsTUFBTXNLLFdBQVcsS0FBS3RKO0lBQ2xFLE1BQU02SixZQUFZN0ssTUFBTTZDLE1BQU0sS0FBSzdCLGFBQWFoQixNQUFNcUssYUFBYSxLQUFLcko7SUFDeEUsSUFBSSxDQUFDb0osaUJBQWtCLEVBQUNRLFdBQVcsQ0FBQ0MsU0FBUSxHQUFJO1FBQzVDbE8sUUFBUUMsSUFBSSxDQUFDLCtDQUNULDJFQUNBLHlFQUNBLDBCQUNBO0lBQ1I7SUFDQSxrRkFBa0Y7SUFDbEYsSUFBSSxDQUFDOEosV0FBVzdELE1BQU0sSUFBSXdILGVBQ3RCM0QsV0FBVzdELE1BQU0sR0FBR3dIO0lBQ3hCLElBQUksQ0FBQzNELFdBQVczRCxJQUFJLElBQUlRLE9BQU9DLFFBQVEsQ0FBQzhHLGNBQ3BDNUQsV0FBVzNELElBQUksR0FBR3VIO0lBQ3RCLElBQUksQ0FBQzVELFdBQVd6RCxPQUFPLElBQUlNLE9BQU9DLFFBQVEsQ0FBQytHLGlCQUN2QzdELFdBQVd6RCxPQUFPLEdBQUdzSDtJQUN6QixJQUFJLENBQUM3RCxXQUFXdkQsSUFBSSxJQUFJSSxPQUFPQyxRQUFRLENBQUNnSCxjQUNwQzlELFdBQVd2RCxJQUFJLEdBQUdxSDtJQUN0QixxQ0FBcUM7SUFDckMsTUFBTU0sWUFBWXBFLFdBQVd4RiwyQkFBMkI7SUFDeEQsSUFBSTRKLGFBQWEsTUFBTTtRQUNuQixzRUFBc0U7UUFDdEVwRSxXQUFXeEYsMkJBQTJCLEdBQ2xDNkksUUFBUTdJLDJCQUEyQjtJQUMzQyxPQUNLO1FBQ0QseUNBQXlDO1FBQ3pDd0YsV0FBV3hGLDJCQUEyQixHQUFHO2VBQ2pDNkksUUFBUTdJLDJCQUEyQixJQUFJLEVBQUU7ZUFDMUM0SjtTQUNOO0lBQ0w7SUFDQSxLQUFLLE1BQU03TixPQUFPbEUsT0FBTzRNLElBQUksQ0FBQ2UsWUFDMUIsSUFBSUEsVUFBVSxDQUFDekosSUFBSSxLQUFLK0QsV0FDcEIsT0FBTzBGLFVBQVUsQ0FBQ3pKLElBQUk7SUFDOUIsTUFBTThOLG1CQUFtQjlTLDZDQUFNQSxDQUFDK0k7SUFDaEMseURBQXlEO0lBQ3pEaEosZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUNrUyxhQUFhLENBQUNGLGFBQ2Y7UUFDSixNQUFNLEVBQUV6SyxjQUFjLEVBQUVLLGlCQUFpQixFQUFFLEdBQUdtSztRQUM5Qyw0RkFBNEY7UUFDNUYsTUFBTSxFQUFFaUIsS0FBSyxFQUFFLEdBQUdoTDtRQUNsQixNQUFNaUwsV0FBVyxHQUF5QlAsT0FBdEJNLFNBQVMsV0FBVSxLQUFpQ0wsT0FBOUJELGlCQUFpQixXQUFVLEtBQTBCLE9BQXZCQyxlQUFlO1FBQ3ZGLElBQUlPO1FBQ0osSUFBSW5PO1FBQ0osSUFBSTBOLGFBQWFiLGVBQWVqRCxHQUFHLENBQUNzRSxXQUFXO1lBQzNDbE8sTUFBTTZNLGVBQWVDLEdBQUcsQ0FBQ29CO1lBQ3pCQyxTQUFTbk8sSUFBSW9PLE1BQU07WUFDbkJqQixVQUFVa0IsV0FBVyxDQUFDRjtZQUN0Qm5PLElBQUk2SixVQUFVLENBQUNGO1lBQ2YsMkVBQTJFO1lBQzNFLDJEQUEyRDtZQUMzRDJFLFdBQVcsSUFBTXRPLElBQUl1TyxTQUFTLENBQUN2TyxJQUFJK0YsU0FBUyxLQUFLO1FBQ3JELE9BQ0s7WUFDRG9JLFNBQVN4TixTQUFTQyxhQUFhLENBQUM7WUFDaEN1TixPQUFPOUMsS0FBSyxDQUFDbUQsTUFBTSxHQUFHO1lBQ3RCckIsVUFBVWtCLFdBQVcsQ0FBQ0Y7WUFDdEJuTyxNQUFNLElBQUlYLE9BQU9DLElBQUksQ0FBQ21QLEdBQUcsQ0FBQ04sUUFBUW5TLE9BQU80RyxNQUFNLENBQUM1RyxPQUFPNEcsTUFBTSxDQUFDNUcsT0FBTzRHLE1BQU0sQ0FBQyxDQUFDLEdBQUcrRyxhQUFjZ0UsZ0JBQ3hGO2dCQUFFQSxlQUFlQTtZQUFjLElBQy9CLENBQUMsSUFBTUMsY0FDUDtnQkFBRUEsYUFBYUE7WUFBWSxJQUMzQixDQUFDO1FBQ1g7UUFDQVYsT0FBT2xOO1FBQ1B3QyxlQUFleEMsS0FBSzBDO1FBQ3BCLElBQUkySyxlQUFlO1lBQ2YsTUFBTSxFQUFFbEIsT0FBTyxFQUFFLEdBQUdrQixlQUFlcUIsWUFBWS9TLE9BQU8wUixlQUFlO2dCQUFDO2FBQVU7WUFDaEZyTixJQUFJMk8sU0FBUyxDQUFDRCxXQUFXdkM7UUFDN0IsT0FFSyxJQUFJLENBQUMwQixXQUFXLENBQUNDLFdBQVc7WUFDN0I5TixJQUFJMk8sU0FBUyxDQUFDO2dCQUFFN0gsTUFBTTtnQkFBS0UsTUFBTSxDQUFDO2dCQUFLRCxPQUFPLENBQUM7Z0JBQUlGLE9BQU87WUFBRztRQUNqRTtRQUNBLHVGQUF1RjtRQUN2RixJQUFJbUgsaUJBQWlCakYsT0FBTyxFQUFFO1lBQzFCLE1BQU0sRUFBRWtGLE9BQU9XLFVBQVUsRUFBRUMsYUFBYUMsZ0JBQWdCLEVBQUUsR0FBR2QsaUJBQWlCakYsT0FBTztZQUNyRixJQUFJNkYsZUFBZVgsT0FBTztnQkFDdEJqTyxJQUFJNkosVUFBVSxDQUFDaUY7WUFDbkI7UUFDSjtRQUNBLE9BQU87WUFDSGQsaUJBQWlCakYsT0FBTyxHQUFHO2dCQUN2QmtGO2dCQUNBLHVEQUF1RDtnQkFDdkRZLGFBQWE1RCxlQUFlbEMsT0FBTztZQUN2QztZQUNBLGtDQUFrQztZQUNsQ29GLE9BQU85SSxNQUFNO1lBQ2IsSUFBSXFJLFdBQVc7Z0JBQ1gseUJBQXlCO2dCQUN6QmIsZUFBZTFOLElBQUksQ0FBQytPLFVBQVVsTztZQUNsQyxPQUNLO2dCQUNELHlFQUF5RTtnQkFDekVYLE9BQU9DLElBQUksQ0FBQzJGLEtBQUssQ0FBQzhKLHNCQUFzQixDQUFDL087WUFDN0M7WUFDQWtOLE9BQU87WUFDUHJLLGtCQUFrQkg7UUFDdEI7SUFDSixHQUNBLG1EQUFtRDtJQUNuRCw2RUFBNkU7SUFDN0UsK0JBQStCO0lBQy9CLHlFQUF5RTtJQUN6RSx1REFBdUQ7SUFDdkQ7UUFDSXlLO1FBQ0FGO1FBQ0F2SztRQUNBLHNFQUFzRTtRQUN0RSx5QkFBeUI7UUFDekJPLE1BQU1nTCxLQUFLO1FBQ1hoTCxNQUFNMEssYUFBYTtRQUNuQjFLLE1BQU0ySyxXQUFXO0tBQ3BCO0lBQ0QsT0FBTztRQUFDNU47UUFBS29OO1FBQWNuQztLQUFlO0FBQzlDO0tBNUhTOEI7O1FBQ2VSO1FBRWNIO1FBQ1hROzs7QUEwSDNCLE1BQU1vQyxrQ0FBb0JwVSxnREFBbUIsQ0FBQztBQUM5QyxrRkFBa0Y7QUFDbEYsa0NBQWtDO0FBQ2xDLE1BQU1xVSxjQUFjO0lBQ2hCQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsZUFBZTtBQUNuQjtBQUNBLE1BQU1DLGdCQUFnQjtJQUNsQkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLGVBQWU7QUFDbkI7QUFDQSxNQUFNZixNQUFNLENBQUN4TDs7SUFDVCxNQUFNLEVBQUVxQixRQUFRLEVBQUU1QixFQUFFLEVBQUUrTSxTQUFTLEVBQUVwRSxLQUFLLEVBQUUsR0FBR3BJO0lBQzNDLE1BQU0rSixVQUFVN1IsaURBQVVBLENBQUNnSDtJQUMzQixNQUFNMUMsZ0JBQWdCcUs7SUFDdEIsSUFBSSxDQUFDa0QsU0FBUztRQUNWLE1BQU0sSUFBSWpQLE1BQU07SUFDcEI7SUFDQSxNQUFNLENBQUNpQyxLQUFLMFAsUUFBUXpFLGVBQWUsR0FBRzhCLGVBQWU5SixPQUFPK0o7SUFDNURoQyxtQkFBbUJoTCxLQUFLaUwsZ0JBQWdCaEk7SUFDeEN5QixhQUFhMUUsS0FBS2lEO0lBQ2xCd0csY0FBY3pKLEtBQUtpRDtJQUNuQixNQUFNaUgscUJBQXFCSCxzQkFBc0IvSixLQUFLaUQ7SUFDdEQsTUFBTTBNLHlCQUF5QixDQUFDLENBQUMxTSxNQUFNMk0sVUFBVTtJQUNqRCxtRUFBbUU7SUFDbkUzVSxnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQytFLEtBQ0Q7UUFDSiwwRkFBMEY7UUFDMUYsb0ZBQW9GO1FBQ3BGLGlEQUFpRDtRQUNqRCxJQUFJa0ssb0JBQW9CO1lBQ3BCbEssSUFBSTZKLFVBQVUsQ0FBQztnQkFBRWdHLGtCQUFrQjtZQUFLO1FBQzVDO1FBQ0EsbUVBQW1FO1FBQ25FLElBQUkzRixzQkFBc0J5Rix3QkFBd0I7WUFDOUMzUCxJQUFJNkosVUFBVSxDQUFDO2dCQUNYaUcsaUJBQWlCO2dCQUNqQkMsbUJBQW1CO1lBQ3ZCO1FBQ0o7UUFDQSxPQUFPO1lBQ0gvUCxJQUFJNkosVUFBVSxDQUFDO2dCQUNYaUcsaUJBQWlCN00sTUFBTTZNLGVBQWU7Z0JBQ3RDQyxtQkFBbUI5TSxNQUFNOE0saUJBQWlCO1lBQzlDO1FBQ0o7SUFDSixHQUFHO1FBQ0MvUDtRQUNBa0s7UUFDQXlGO1FBQ0ExTSxNQUFNNk0sZUFBZTtRQUNyQjdNLE1BQU04TSxpQkFBaUI7S0FDMUI7SUFDRCxxRUFBcUU7SUFDckUsTUFBTWpLLFNBQVM3QyxNQUFNNkMsTUFBTSxHQUFHZ0YsZ0JBQWdCN0gsTUFBTTZDLE1BQU0sSUFBSTtJQUM5RCxJQUFJYSxNQUFNO0lBQ1YsSUFBSUMsTUFBTTtJQUNWLElBQUlkLFVBQVVVLE9BQU9DLFFBQVEsQ0FBQ1gsT0FBT2EsR0FBRyxLQUFLSCxPQUFPQyxRQUFRLENBQUNYLE9BQU9jLEdBQUcsR0FBRztRQUN0RUQsTUFBTWIsT0FBT2EsR0FBRztRQUNoQkMsTUFBTWQsT0FBT2MsR0FBRztJQUNwQjtJQUNBLE1BQU1vSixnQkFBZ0JuViw4Q0FBT0EsQ0FBQztRQUMxQixJQUFJK0QsSUFBSUMsSUFBSW9SO1FBQ1osT0FBTztZQUNIbkssUUFBUTtnQkFBRWEsS0FBS0EsUUFBUSxRQUFRQSxRQUFRLEtBQUssSUFBSUEsTUFBTTtnQkFBR0MsS0FBS0EsUUFBUSxRQUFRQSxRQUFRLEtBQUssSUFBSUEsTUFBTTtZQUFFO1lBQ3ZHWixNQUFNLENBQUNwSCxLQUFLcUUsTUFBTStDLElBQUksTUFBTSxRQUFRcEgsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFDekRzSCxTQUFTLENBQUNySCxLQUFLb0UsTUFBTWlELE9BQU8sTUFBTSxRQUFRckgsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFDL0R1SCxNQUFNLENBQUM2SixLQUFLaE4sTUFBTW1ELElBQUksTUFBTSxRQUFRNkosT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDN0Q7SUFDSixHQUFHO1FBQUN0SjtRQUFLQztRQUFLM0QsTUFBTStDLElBQUk7UUFBRS9DLE1BQU1pRCxPQUFPO1FBQUVqRCxNQUFNbUQsSUFBSTtLQUFDO0lBQ3BELGtHQUFrRztJQUNsR2hMLHNEQUFlQSxDQUFDO1FBQ1osSUFBSSxDQUFDNEUsT0FBTyxDQUFDMlAsd0JBQ1Q7UUFDSjNQLElBQUl1SyxVQUFVLENBQUN5RjtRQUNmLE1BQU1oTCxXQUFXaEYsSUFBSWtGLFdBQVcsQ0FBQyxrQkFBa0I7WUFDL0NsRixJQUFJdUssVUFBVSxDQUFDeUY7UUFDbkI7UUFDQSxPQUFPLElBQU1oTCxTQUFTSyxNQUFNO0lBQ2hDLEdBQUc7UUFBQ3JGO1FBQUsyUDtRQUF3Qks7S0FBYztJQUMvQyxNQUFNRSxnQkFBZ0JyViw4Q0FBT0EsQ0FBQyxJQUFPbUIsT0FBTzRHLE1BQU0sQ0FBQztZQUFFdU4sT0FBTztZQUFRM0IsUUFBUTtZQUFRbEQsVUFBVTtZQUMxRix3REFBd0Q7WUFDeERLLFFBQVF6QixxQkFBcUIsQ0FBQyxJQUFJO1FBQUUsR0FBR21CLFFBQVM7UUFBQ0E7UUFBT25CO0tBQW1CO0lBQy9FLE1BQU0xRixlQUFlM0osOENBQU9BLENBQUMsSUFBTztZQUFFbUY7UUFBSSxJQUFJO1FBQUNBO0tBQUk7SUFDbkQsSUFBSVAsa0JBQWtCeEIsaUJBQWlCSyxZQUFZLEVBQUU7UUFDakQscUJBQVExRCxnREFBbUIsQ0FBQyxPQUFPO1lBQUV5USxPQUFPclAsT0FBTzRHLE1BQU0sQ0FBQztnQkFBRTBJLFVBQVU7WUFBVyxHQUFJbUUsWUFBWSxDQUFDLElBQUlTO1lBQWlCVCxXQUFXQTtRQUFVLGlCQUN4STdVLGdEQUFtQixDQUFDd1Esb0JBQW9CO0lBQ2hEO0lBQ0EscUJBQVF4USxnREFBbUIsQ0FBQyxPQUFPb0IsT0FBTzRHLE1BQU0sQ0FBQztRQUFFa0csS0FBSzRHO1FBQVEsZUFBZTtRQUFPckUsT0FBT29FLFlBQVl4TCxZQUFZaU07UUFBZVQsV0FBV0E7SUFBVSxHQUFJL00sS0FBSztRQUFFQTtJQUFHLElBQUksQ0FBQyxJQUFLMUMsb0JBQU9wRixnREFBbUIsQ0FBQ29VLGtCQUFrQnZLLFFBQVEsRUFBRTtRQUFFMUgsT0FBT3lIO0lBQWEsR0FBR0YsWUFBYTtBQUNsUjtLQS9FTW1LOztRQUdvQjNFO1FBSWdCaUQ7UUFDdEMvQjtRQUNBdEc7UUFDQStFO1FBQzJCTTs7O01BWHpCMEU7QUFnRk4sK0VBQStFO0FBQy9FLGlGQUFpRjtBQUNqRiw4REFBOEQ7QUFDOURBLElBQUkyQixlQUFlLEdBQUc7QUFFdEIsTUFBTUMsZ0JBQWdCLElBQUk3RztBQUMxQixTQUFTOEc7SUFBYTtRQUFHQyxLQUFILHVCQUFPOztJQUN6QixNQUFNclEsTUFBTTJELEtBQUtDLFNBQVMsQ0FBQ3lNO0lBQzNCLElBQUksQ0FBQ0YsY0FBY3pHLEdBQUcsQ0FBQzFKLE1BQU07UUFDekJtUSxjQUFjRyxHQUFHLENBQUN0UTtRQUNsQk4sUUFBUWhDLEtBQUssSUFBSTJTO0lBQ3JCO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUUsU0FBUztRQUFDL04sc0VBQUs7O0lBQ2pCLE1BQU1nTyxNQUFNdlYsaURBQVVBLENBQUNnSDtJQUN2QixNQUFNLEVBQUVuQyxHQUFHLEVBQUUsR0FBRzdFLGlEQUFVQSxDQUFDNlQsc0JBQXNCLENBQUM7SUFDbEQsSUFBSTBCLFFBQVEsTUFBTTtRQUNkSixhQUFhLHNEQUNULG9FQUNBLG1FQUNBO1FBQ0osT0FBTztJQUNYO0lBQ0EsTUFBTSxFQUFFaE8sWUFBWSxFQUFFLEdBQUdvTztJQUN6QixtRUFBbUU7SUFDbkUsSUFBSWhPLE9BQU8sTUFDUCxPQUFPSixZQUFZLENBQUNJLEdBQUcsSUFBSTtJQUMvQix5Q0FBeUM7SUFDekMsSUFBSTFDLEtBQ0EsT0FBT0E7SUFDWCwyQ0FBMkM7SUFDM0MsT0FBT3NDLFlBQVksQ0FBQyxVQUFVLElBQUk7QUFDdEM7S0FuQk1tTztBQXFCTixTQUFTRSxlQUFlM1MsSUFBSTs7SUFDeEIsTUFBTWlQLGNBQWNWO0lBQ3BCLE1BQU1tRSxNQUFNdlYsaURBQVVBLENBQUNnSDtJQUN2QmxILGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFDZ1MsZUFBZSxDQUFDeUQsS0FDakI7UUFDSixzREFBc0Q7UUFDdEQsbUZBQW1GO1FBQ25GLCtDQUErQztRQUMvQyxLQUFLQSxJQUFJblIsYUFBYSxDQUFDdkI7SUFDM0IsR0FBRztRQUFDaVA7UUFBYXlEO1FBQUsxUztLQUFLO0lBQzNCLE9BQU8sQ0FBQzBTLFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJak4sZUFBZSxDQUFDekYsS0FBSyxLQUFLO0FBQ3BGO0tBWlMyUzs7UUFDZXBFOzs7QUFheEIscURBQXFELEdBQ3JEOzs7Q0FHQyxHQUNELFNBQVNxRSxxQkFBcUJDLE1BQU0sRUFBRTdTLElBQUksRUFBRThTLFFBQVE7O0lBQ2hEN1YsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUM0VixVQUFVLENBQUM3UyxRQUFRLENBQUM4UyxVQUNyQjtRQUNKLE1BQU05TCxXQUFXM0YsT0FBT0MsSUFBSSxDQUFDMkYsS0FBSyxDQUFDQyxXQUFXLENBQUMyTCxRQUFRN1MsTUFBTThTO1FBQzdELE9BQU8sSUFBTTlMLFNBQVNLLE1BQU07SUFDaEMsR0FBRztRQUFDd0w7UUFBUTdTO1FBQU04UztLQUFTO0FBQy9CO0tBUFNGO0FBU1Q7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRyxlQUFlQyxNQUFNLEVBQUVDLElBQUksRUFBRWxVLEtBQUs7O0lBQ3ZDOUIsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUMrVixRQUNEO1FBQ0osb0RBQW9EO1FBQ3BEQSxNQUFNLENBQUNDLEtBQUssR0FBR2xVO0lBQ25CLEdBQUc7UUFBQ2lVO1FBQVFDO1FBQU1sVTtLQUFNO0FBQzVCO0tBUFNnVTtBQVNULHFEQUFxRCxHQUNyRDs7O0NBR0MsR0FDRCxTQUFTRyxvQkFBb0JMLE1BQU0sRUFBRTdTLElBQUksRUFBRThTLFFBQVE7O0lBQy9DN1YsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUM0VixVQUFVLENBQUM3UyxRQUFRLENBQUM4UyxVQUNyQjtRQUNKRCxPQUFPTSxnQkFBZ0IsQ0FBQ25ULE1BQU04UztRQUM5QixPQUFPLElBQU1ELE9BQU9PLG1CQUFtQixDQUFDcFQsTUFBTThTO0lBQ2xELEdBQUc7UUFBQ0Q7UUFBUTdTO1FBQU04UztLQUFTO0FBQy9CO0tBUFNJO0FBU1QscUVBQXFFO0FBQ3JFLE1BQU1HO0lBS0ZDLGtCQUFrQjtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUNDLFlBQVksRUFBRTtZQUNwQixJQUFJLENBQUNBLFlBQVksR0FBRzVRLFNBQVNDLGFBQWEsQ0FBQztZQUMzQyxJQUFJLENBQUMyUSxZQUFZLENBQUNDLFlBQVksQ0FBQywwQkFBMEI7WUFDekQ3USxTQUFTa0IsSUFBSSxDQUFDd00sV0FBVyxDQUFDLElBQUksQ0FBQ2tELFlBQVk7UUFDL0M7UUFDQSxPQUFPLElBQUksQ0FBQ0EsWUFBWTtJQUM1QjtJQUNBRSwwQ0FBMEM7UUFDdEMsSUFBSSxJQUFJLENBQUNDLGNBQWMsQ0FBQzlILEdBQUcsQ0FBQywwQkFBMEI7WUFDbEQ7UUFDSjtRQUNBLE1BQU0ySCxlQUFlLElBQUksQ0FBQ0QsZUFBZTtRQUN6Q0MsYUFBYUksV0FBVyxJQUFLO1FBSzdCLElBQUksQ0FBQ0QsY0FBYyxDQUFDbEIsR0FBRyxDQUFDO0lBQzVCO0lBQ0FvQixVQUFVO1FBQ04sSUFBSSxJQUFJLENBQUNMLFlBQVksRUFBRTtZQUNuQixJQUFJLENBQUNBLFlBQVksQ0FBQ2xNLE1BQU07WUFDeEIsSUFBSSxDQUFDa00sWUFBWSxHQUFHO1lBQ3BCLElBQUksQ0FBQ0csY0FBYyxDQUFDRyxLQUFLO1FBQzdCO0lBQ0o7SUE5QkFDLGFBQWM7UUFDVixJQUFJLENBQUNKLGNBQWMsR0FBRyxJQUFJbEk7UUFDMUIsSUFBSSxDQUFDK0gsWUFBWSxHQUFHO0lBQ3hCO0FBNEJKO0FBQ0EsTUFBTVEscUJBQXFCLElBQUlWO0FBRS9CLFNBQVNXLHNCQUFzQkMsS0FBSyxFQUFFQyxLQUFLO0lBQ3ZDLElBQUl0VDtJQUNKLElBQUksQ0FBRSxFQUFDQSxLQUFLUyxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0MsSUFBSSxNQUFNLFFBQVFWLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3lFLE9BQU8sR0FDcEgsT0FBT1k7SUFDWCxNQUFNWixVQUFVaEUsT0FBT0MsSUFBSSxDQUFDK0QsT0FBTyxDQUFDdEUsS0FBSyxDQUFDO0lBQzFDLE1BQU1vVCxlQUFlQyxTQUFTL08sT0FBTyxDQUFDLEVBQUUsRUFBRTtJQUMxQyxNQUFNZ1AsZUFBZUQsU0FBUy9PLE9BQU8sQ0FBQyxFQUFFLEVBQUU7SUFDMUMsT0FBUThPLGVBQWVGLFNBQVVFLGlCQUFpQkYsU0FBU0ksZ0JBQWdCSDtBQUMvRTtBQUVBLDJDQUEyQyxHQUMzQywyRUFBMkU7QUFDM0UsNEVBQTRFO0FBQzVFLDRFQUE0RTtBQUM1RSw0RUFBNEU7QUFDNUUseUVBQXlFO0FBQ3pFLDhFQUE4RTtBQUM5RSwrREFBK0Q7QUFDL0Q7OztDQUdDLEdBQ0QsTUFBTUksb0JBQW9CO0lBQ3RCQyxVQUFVO0lBQ1ZDLDZCQUE2QjtJQUM3QkMsbUNBQW1DO0FBQ3ZDO0FBQ0EsTUFBTUMsc0NBQXdCOVgsZ0RBQW1CLENBQUM7QUFDbEQsNERBQTREO0FBQzVEOzs7Q0FHQyxHQUNELE1BQU0rWCw0QkFBNEI7SUFDOUJDLFVBQVU7UUFBQztRQUFNO0tBQUs7SUFDdEJDLFlBQVk7UUFBQztRQUFPO0tBQUs7SUFDekJDLEtBQUs7UUFBQztRQUFPO0tBQUs7SUFDbEJDLFdBQVc7UUFBQztRQUFRO0tBQUs7SUFDekJDLGFBQWE7UUFBQztRQUFNO0tBQU07SUFDMUJDLFVBQVU7UUFBQztRQUFNO0tBQUs7SUFDdEJDLE1BQU07UUFBQztRQUFNO0tBQU07SUFDbkJDLGFBQWE7UUFBQztRQUFNO0tBQU87SUFDM0JDLFdBQVc7UUFBQztRQUFRO0tBQUs7SUFDekJDLE9BQU87UUFBQztRQUFRO0tBQU07SUFDdEJDLGNBQWM7UUFBQztRQUFRO0tBQU07SUFDN0JDLGNBQWM7UUFBQztRQUFRO0tBQU87SUFDOUJDLGFBQWE7UUFBQztRQUFNO0tBQU87SUFDM0JDLGVBQWU7UUFBQztRQUFPO0tBQU87SUFDOUJDLFFBQVE7UUFBQztRQUFPO0tBQU87SUFDdkJDLGNBQWM7UUFBQztRQUFRO0tBQU87SUFDOUJDLFFBQVE7UUFBQztRQUFPO0tBQU07QUFDMUI7QUFDQSxNQUFNQywrQkFBaUJ4WSxLQUFBQSxpREFBVUEsWUFBQyxDQUFDNEgsT0FBTzZGOztJQUN0QyxNQUFNLEVBQUV4RSxRQUFRLEVBQUUrRyxLQUFLLEVBQUVvRSxTQUFTLEVBQUVxRSxXQUFXLEVBQUUsR0FBRzdRO0lBQ3BELE1BQU0sQ0FBQzhRLFFBQVFDLGlCQUFpQixHQUFHQyxrQkFBa0JoUjtJQUNyRCxNQUFNaVIsNkJBQTZCclosOENBQU9BLENBQUMsSUFBT2taLFNBQVM7WUFBRUE7UUFBTyxJQUFJLE1BQU87UUFBQ0E7S0FBTztJQUN2RnpZLDBEQUFtQkEsQ0FBQ3dOLEtBQUssSUFBTWlMLFFBQVE7UUFBQ0E7S0FBTztJQUMvQyxJQUFJLENBQUNDLGtCQUNELE9BQU87SUFDWCxxQkFBUXBaLGdEQUFtQixDQUFDOFgsc0JBQXNCak8sUUFBUSxFQUFFO1FBQUUxSCxPQUFPbVg7SUFBMkIsaUJBQUcxWSx1REFBWUEsZUFBQ1osZ0RBQW1CLENBQUN1WixlQUFlO1FBQUVMLGFBQWFBO1FBQWFNLFFBQVEvSTtRQUFPb0UsV0FBV0E7SUFBVSxHQUFHbkwsV0FBVzBQO0FBQ3JPOztRQU51Q0M7Ozs7UUFBQUE7Ozs7QUFPdkNKLGVBQWVRLFdBQVcsR0FBRztBQUM3QixTQUFTQzs7SUFDTCxNQUFNLENBQUNQLFFBQVFRLFVBQVUsR0FBR3paLCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU0wWixjQUFjeFosa0RBQVdBLENBQUMsQ0FBQ3laO1FBQzdCRixVQUFVRTtJQUNkLEdBQUcsRUFBRTtJQUNMLE9BQU87UUFBQ0Q7UUFBYVQ7S0FBTztBQUNoQztLQU5TTztBQU9ULFNBQVNJLGlCQUFpQlgsTUFBTTtJQUM1QixPQUFRQSxPQUFPWSxPQUFPLEtBQUsxUTtBQUMvQjtBQUNBLFNBQVMyUSxjQUFjQyxJQUFJO0lBQ3ZCLE9BQU9BLEtBQUtDLFFBQVEsS0FBS0MsS0FBS0MsWUFBWTtBQUM5QztBQUNBLE1BQU1iLGdCQUFnQjtRQUFDLEVBQUU3UCxRQUFRLEVBQUU4UCxNQUFNLEVBQUUzRSxTQUFTLEVBQUU7SUFDbEQsNERBQTRELEdBQzVELHFCQUFRN1UsZ0RBQW1CLENBQUMsT0FBTztRQUFFNlUsV0FBV0E7UUFBV3BFLE9BQU8rSTtJQUFPLEdBQUc5UDtBQUNoRjtNQUhNNlA7QUFJTixTQUFTRixrQkFBa0JoUixLQUFLOztJQUM1QixNQUFNLENBQUM4USxRQUFRUSxVQUFVLEdBQUd6WiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNrWixrQkFBa0JpQixvQkFBb0IsR0FBR25hLCtDQUFRQSxDQUFDO0lBQ3pELE1BQU1rRixNQUFNeVE7SUFDWixNQUFNeUUsZ0JBQWdCdkUsZUFBZTtJQUNyQyxNQUFNLEVBQUVyTSxRQUFRLEVBQUVrRCxPQUFPLEVBQUVpSSxTQUFTLEVBQUUwRixZQUFZLEVBQUVDLFlBQVksRUFBRXpOLE1BQU0sRUFBRTBOLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxpQkFBaUIsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVuSyxRQUFRLEVBQUVvSyxLQUFLLEVBQUUvSixNQUFNLEVBQUVtSSxXQUFXLEVBQUU2QixVQUFVLEVBQUVDLFNBQVMsRUFBRSxHQUFHM1M7SUFDM00sTUFBTTRTLGNBQWN0YSwyQ0FBUUEsQ0FBQ3VhLEtBQUssQ0FBQ3hSO0lBQ25DLGdGQUFnRjtJQUNoRnJKLGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFDK0UsT0FBTyxDQUFDa1YsZUFDVDtRQUNKLE1BQU1hLFlBQVksSUFBSWIsY0FBY2MscUJBQXFCO1FBQ3pERCxVQUFVL1YsR0FBRyxHQUFHQTtRQUNoQnVVLFVBQVV3QjtRQUNWLGdFQUFnRTtRQUNoRSxJQUFJRSxpQkFBaUI7UUFDckIsSUFBSUosY0FBYyxHQUFHO1lBQ2pCSSxpQkFBaUJ0VixTQUFTQyxhQUFhLENBQUM7WUFDeENtVixVQUFVcEIsT0FBTyxHQUFHc0I7WUFDcEJoQixvQkFBb0JnQjtRQUN4QjtRQUNBLE9BQU87WUFDSEYsVUFBVS9WLEdBQUcsR0FBRztZQUNoQmlXLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZTVRLE1BQU07WUFDckZrUCxVQUFVO1lBQ1ZVLG9CQUFvQjtRQUN4QjtJQUNKLEdBQUc7UUFBQ2pWO1FBQUtrVjtRQUFlVztLQUFZO0lBQ3BDLGlFQUFpRTtJQUNqRSwrREFBK0Q7SUFDL0QseUVBQXlFO0lBQ3pFLDJCQUEyQjtJQUMzQjVhLGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFFOFksQ0FBQUEsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU9ZLE9BQU8sS0FBSyxDQUFDQyxjQUFjYixPQUFPWSxPQUFPLEtBQUtrQixjQUFjLEdBQ3JIO1FBQ0o5QixPQUFPWSxPQUFPLENBQUNsRixTQUFTLEdBQUdBLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUlBLFlBQVk7SUFDeEYsR0FBRztRQUFDc0U7UUFBUXRFO1FBQVdvRztLQUFZO0lBQ25DSywyQkFBMkJuQyxRQUFRRCxhQUFhNkIsWUFBWUMsV0FBV0MsY0FBYztJQUNyRixtQkFBbUI7SUFDbkI5RSxlQUFlZ0QsUUFBUSxZQUFZekk7SUFDbkN5RixlQUFlZ0QsUUFBUSxTQUFTMkIsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSUEsUUFBUTtJQUM3RTNFLGVBQWVnRCxRQUFRLFVBQVVwSTtJQUNqQ29GLGVBQWVnRCxRQUFRLHFCQUFxQndCO0lBQzVDLDZFQUE2RTtJQUM3RSwyQkFBMkI7SUFDM0J0YSxnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQzhZLFFBQ0Q7UUFDSixJQUFJMEIsY0FBY3hSLFdBQ2Q4UCxPQUFPb0MsWUFBWSxHQUFHVjthQUNyQixJQUFJOU4sVUFBVTBOLGVBQWVDLFdBQzlCdkIsT0FBT29DLFlBQVksR0FBRzthQUV0QnBDLE9BQU9vQyxZQUFZLEdBQUc7SUFDOUIsR0FBRztRQUFDcEM7UUFBUTBCO1FBQVc5TjtRQUFRMk47UUFBV0Q7S0FBWTtJQUN0RCxvRkFBb0Y7SUFDcEYsNENBQTRDO0lBQzVDcGEsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUM4WSxRQUNEO1FBQ0osTUFBTXFDLGVBQWVaLGNBQWN2UixhQUMvQm9TLFFBQVE3TyxZQUNSNk8sUUFBUWxCLGlCQUNSa0IsUUFBUWpCO1FBQ1osd0RBQXdEO1FBQ3hELDhCQUE4QjtRQUM5QnJCLE9BQU9xQyxZQUFZLEdBQUdBO1FBQ3RCLDREQUE0RDtRQUM1RCxJQUFJQSxnQkFBaUJyQyxDQUFBQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT1ksT0FBTyxLQUFLQyxjQUFjYixPQUFPWSxPQUFPLEdBQUc7WUFDbkhaLE9BQU9ZLE9BQU8sQ0FBQ3RKLEtBQUssQ0FBQ2lMLGFBQWEsR0FBRztZQUNyQyxJQUFJOU8sU0FBUztnQkFDVHVNLE9BQU9ZLE9BQU8sQ0FBQ3RKLEtBQUssQ0FBQ2tMLE1BQU0sR0FBRztZQUNsQztRQUNKO0lBQ0osR0FBRztRQUFDeEM7UUFBUXlCO1FBQVdoTztRQUFTMk47UUFBY0M7S0FBYTtJQUMzRHhFLHFCQUFxQm1ELFFBQVEsU0FBU3ZNO0lBQ3RDb0oscUJBQXFCbUQsUUFBUSxRQUFRcE07SUFDckNpSixxQkFBcUJtRCxRQUFRLGFBQWFzQjtJQUMxQ3pFLHFCQUFxQm1ELFFBQVEsV0FBV3VCO0lBQ3hDcEUsb0JBQW9CNkMsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU95QyxPQUFPLEVBQUUsY0FBY3JCO0lBQ2xHakUsb0JBQW9CNkMsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU95QyxPQUFPLEVBQUUsY0FBY3BCO0lBQ2xHLE9BQU87UUFBQ3JCO1FBQVFDO0tBQWlCO0FBQ3JDO0tBbEZTQzs7UUFHT3hEO1FBQ1VFO1FBaUN0QnVGO1FBRUFuRjtRQUNBQTtRQUNBQTtRQUNBQTtRQWlDQUg7UUFDQUE7UUFDQUE7UUFDQUE7UUFDQU07UUFDQUE7OztBQUdKLFNBQVNnRiwyQkFBMkJuQyxNQUFNLEVBQUVELFdBQVcsRUFBRTZCLFVBQVUsRUFBRUMsU0FBUyxFQUFFYSxXQUFXOztJQUN2RnhiLGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFDOFksVUFBVSxDQUFDMEMsYUFDWjtRQUNKLDJFQUEyRTtRQUMzRSx5RUFBeUU7UUFDekUsMkJBQTJCO1FBQzNCLE1BQU1DLHlCQUF5QjFFLHNCQUFzQixHQUFHO1FBQ3hELE1BQU1pRSxpQkFBaUJsQyxPQUFPWSxPQUFPO1FBQ3JDLElBQUksQ0FBQ3NCLGtCQUFrQixDQUFDckIsY0FBY3FCLGlCQUNsQztRQUNKLElBQUlOLGVBQWUxUixhQUFhMlIsY0FBYzNSLFdBQVc7WUFDckQsSUFBSSxDQUFDeVMsd0JBQXdCO2dCQUN6QjlXLFFBQVFDLElBQUksQ0FBQywyRUFDVCxnREFDQSwwQkFBOEMsT0FBcEJSLE9BQU9DLElBQUksQ0FBQytELE9BQU8sRUFBQztZQUN0RDtZQUNBMFEsT0FBTzRCLFVBQVUsR0FBR0E7WUFDcEI1QixPQUFPNkIsU0FBUyxHQUFHQTtZQUNuQix5RUFBeUU7WUFDekUsSUFBSTlCLGdCQUFnQjdQLFdBQVc7Z0JBQzNCckUsUUFBUUMsSUFBSSxDQUFDLHFFQUNUO1lBQ1I7WUFDQTtRQUNKO1FBQ0EsSUFBSWlVLGdCQUFnQjdQLFdBQVc7WUFDM0IseUVBQXlFO1lBQ3pFLE1BQU0sQ0FBQ3lJLEdBQUdpSyxFQUFFLEdBQUc3QyxnQkFBZ0IsUUFBUUEsZ0JBQWdCLEtBQUssSUFBSUEsY0FBY25CLHlCQUF5QixDQUFDLFNBQVM7WUFDakgsNkRBQTZEO1lBQzdELGlEQUFpRDtZQUNqRCxNQUFNaUUsYUFBYSxhQUFlLE9BQUZsSyxHQUFFO1lBQ2xDLE1BQU1tSyxhQUFhLGFBQWUsT0FBRkYsR0FBRTtZQUNsQyxJQUFJRCx3QkFBd0I7Z0JBQ3hCLHVFQUF1RTtnQkFDdkUzQyxPQUFPNEIsVUFBVSxHQUFHaUI7Z0JBQ3BCN0MsT0FBTzZCLFNBQVMsR0FBR2lCO2dCQUNuQiw2Q0FBNkM7Z0JBQzdDWixlQUFlNUssS0FBSyxDQUFDeUwsU0FBUyxHQUFHO1lBQ3JDLE9BQ0s7Z0JBQ0QsNkRBQTZEO2dCQUM3RCx3REFBd0Q7Z0JBQ3hEYixlQUFlNUssS0FBSyxDQUFDeUwsU0FBUyxHQUFHLGtDQUFpREQsT0FBZkQsWUFBVyxNQUFlLE9BQVhDLFlBQVc7Z0JBQzdGLHFFQUFxRTtnQkFDckUsb0VBQW9FO2dCQUNwRSxxRUFBcUU7Z0JBQ3JFLFlBQVk7Z0JBQ1o5QyxPQUFPZ0QsT0FBTyxDQUFDQyxNQUFNLEdBQUc7Z0JBQ3hCakYsbUJBQW1CTix1Q0FBdUM7WUFDOUQ7UUFDSjtJQUNKLEdBQUc7UUFBQ3NDO1FBQVFEO1FBQWE2QjtRQUFZQztRQUFXYTtLQUFZO0FBQ2hFO0tBckRTUDtBQXVEVCxTQUFTZSxrQkFBa0JULE9BQU8sRUFBRXBDLE1BQU0sRUFBRThDLFVBQVU7SUFDbEQsSUFBSTlDLFVBQVUsUUFBUSxPQUFPQSxXQUFXLFVBQVU7UUFDOUMsTUFBTSxJQUFJclcsTUFBTSx5RUFDWiwyRUFDQTtJQUNSO0lBQ0EsTUFBTW9aLGVBQWVYLFFBQVFuTCxLQUFLO0lBQ2xDLDRDQUE0QztJQUM1QyxJQUFJNkwsY0FBYyxNQUFNO1FBQ3BCLElBQUk5QyxVQUFVLE1BQ1Y7UUFDSixJQUFLLE1BQU1nRCxhQUFhaEQsT0FBUTtZQUM1QixJQUFJLENBQUNBLE9BQU9sWSxjQUFjLENBQUNrYixZQUN2QjtZQUNKQyxpQkFBaUJGLGNBQWNDLFdBQVdoRCxNQUFNLENBQUNnRCxVQUFVO1FBQy9EO1FBQ0E7SUFDSjtJQUNBLDJEQUEyRDtJQUMzRCxJQUFLLE1BQU1BLGFBQWFGLFdBQVk7UUFDaEMsSUFBSUEsV0FBV2hiLGNBQWMsQ0FBQ2tiLGNBQ3pCaEQsQ0FBQUEsVUFBVSxRQUFRLENBQUNBLE9BQU9sWSxjQUFjLENBQUNrYixVQUFTLEdBQUk7WUFDdkQsY0FBYztZQUNkLE1BQU1FLG1CQUFtQkYsVUFBVWhiLE9BQU8sQ0FBQyxVQUFVO1lBQ3JELElBQUlrYixrQkFBa0I7Z0JBQ2xCSCxhQUFhSSxXQUFXLENBQUNILFdBQVc7WUFDeEMsT0FDSyxJQUFJQSxjQUFjLFNBQVM7Z0JBQzVCRCxhQUFhSyxRQUFRLEdBQUc7WUFDNUIsT0FDSztnQkFDREwsWUFBWSxDQUFDQyxVQUFVLEdBQUc7WUFDOUI7UUFDSjtJQUNKO0lBQ0Esd0VBQXdFO0lBQ3hFLElBQUloRCxVQUFVLE1BQ1Y7SUFDSixJQUFLLE1BQU1nRCxhQUFhaEQsT0FBUTtRQUM1QixNQUFNclgsUUFBUXFYLE1BQU0sQ0FBQ2dELFVBQVU7UUFDL0IsSUFBSWhELE9BQU9sWSxjQUFjLENBQUNrYixjQUN0QkYsVUFBVSxDQUFDRSxVQUFVLEtBQUtyYSxPQUFPO1lBQ2pDc2EsaUJBQWlCRixjQUFjQyxXQUFXcmE7UUFDOUM7SUFDSjtBQUNKO0FBQ0EsU0FBU3NhLGlCQUFpQkYsWUFBWSxFQUFFQyxTQUFTLEVBQUVyYSxLQUFLO0lBQ3BELE1BQU11YSxtQkFBbUJGLFVBQVVoYixPQUFPLENBQUMsVUFBVTtJQUNyRCw2Q0FBNkM7SUFDN0MsSUFBSVcsU0FBUyxRQUFRLE9BQU9BLFVBQVUsYUFBYUEsVUFBVSxJQUFJO1FBQzdELElBQUl1YSxrQkFBa0I7WUFDbEJILGFBQWFJLFdBQVcsQ0FBQ0gsV0FBVztRQUN4QyxPQUNLLElBQUlBLGNBQWMsU0FBUztZQUM1QkQsYUFBYUssUUFBUSxHQUFHO1FBQzVCLE9BQ0s7WUFDREwsWUFBWSxDQUFDQyxVQUFVLEdBQUc7UUFDOUI7SUFDSixPQUVLLElBQUlFLGtCQUFrQjtRQUN2QkgsYUFBYUksV0FBVyxDQUFDSCxXQUFXcmE7SUFDeEMsT0FFSyxJQUFJLE9BQU9BLFVBQVUsWUFDdEJBLFVBQVUsS0FDVixDQUFDMGEsaUJBQWlCTCxZQUFZO1FBQzlCRCxZQUFZLENBQUNDLFVBQVUsR0FBR3JhLFFBQVEsTUFBTSxxREFBcUQ7SUFDakcsT0FFSztRQUNELElBQUlxYSxjQUFjLFNBQVM7WUFDdkJELGFBQWFLLFFBQVEsR0FBR3phO1FBQzVCLE9BQ0s7WUFDRG9hLFlBQVksQ0FBQ0MsVUFBVSxHQUFHLENBQUMsS0FBS3JhLEtBQUksRUFBRzJhLElBQUk7UUFDL0M7SUFDSjtBQUNKO0FBQ0Esb0VBQW9FO0FBQ3BFLE1BQU1DLGtCQUFrQixJQUFJbk8sSUFBSTtJQUM1QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxTQUFTaU8saUJBQWlCelosSUFBSTtJQUMxQixPQUFPMlosZ0JBQWdCL04sR0FBRyxDQUFDNUw7QUFDL0I7QUFFQTs7Q0FFQyxHQUNELE1BQU00WixhQUFhM1UsQ0FBQUE7O0lBQ2YsTUFBTSxFQUNOLGtCQUFrQjtJQUNsQnFCLFFBQVEsRUFBRXVULGFBQWEsRUFBRXhNLEtBQUssRUFBRW9FLFNBQVMsRUFBRXFJLFdBQVcsRUFDdEQsZUFBZTtJQUNmQyxNQUFNLEVBQUVDLFdBQVcsRUFDbkIsU0FBUztJQUNUQyxPQUFPLEVBQUVDLFlBQVksRUFBRSxHQUFHalYsT0FDMUIsZ0JBQWdCO0lBQ2hCa1YsNEJBQTRCeGMsT0FBT3NILE9BQU87UUFBQztRQUFZO1FBQWlCO1FBQVM7UUFBYTtRQUFlO1FBQVU7UUFBZTtRQUFXO0tBQWU7SUFDaEssbUVBQW1FO0lBQ25FLE1BQU1tVixjQUFjekgsZUFBZTtJQUNuQyxNQUFNLENBQUMwSCxZQUFZQyxjQUFjLEdBQUd4ZCwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNeWQsc0JBQXNCcmQsNkNBQU1BLENBQUM7SUFDbkMsTUFBTXNkLHFCQUFxQnRkLDZDQUFNQSxDQUFDO0lBQ2xDLE1BQU11ZCxvQkFBb0J6UCxZQUFZbVAsMkJBQTJCMWMsNENBQVdBO0lBQzVFUixnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQ21kLGFBQ0Q7UUFDSkcsb0JBQW9CeFAsT0FBTyxHQUFHcEksU0FBU0MsYUFBYSxDQUFDO1FBQ3JENFgsbUJBQW1CelAsT0FBTyxHQUFHcEksU0FBU0MsYUFBYSxDQUFDO1FBQ3BELE1BQU04WCxPQUFPRDtRQUNiLElBQUlYLGFBQWE7WUFDYlksS0FBS1osV0FBVyxHQUFHLElBQUl6WSxPQUFPQyxJQUFJLENBQUNxWixJQUFJLENBQUNiLFdBQVcsQ0FBQyxFQUFFLEVBQUVBLFdBQVcsQ0FBQyxFQUFFO1FBQzFFO1FBQ0EsSUFBSUQsZUFBZTtZQUNmLHNFQUFzRTtZQUN0RSwrREFBK0Q7WUFDL0RhLEtBQUtiLGFBQWEsR0FDZCxPQUFPQSxrQkFBa0IsV0FDbkJBLGdCQUNBVyxtQkFBbUJ6UCxPQUFPO1FBQ3hDO1FBQ0EsbURBQW1EO1FBQ25ELE1BQU1zUCxhQUFhLElBQUloWixPQUFPQyxJQUFJLENBQUNzWSxVQUFVLENBQUNhO1FBQzlDSixXQUFXTyxVQUFVLENBQUNMLG9CQUFvQnhQLE9BQU87UUFDakR1UCxjQUFjRDtRQUNkLHdHQUF3RztRQUN4RyxPQUFPO1lBQ0gsSUFBSXpaLElBQUlDO1lBQ1J3WixXQUFXTyxVQUFVLENBQUM7WUFDckJoYSxDQUFBQSxLQUFLMlosb0JBQW9CeFAsT0FBTyxNQUFNLFFBQVFuSyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd5RyxNQUFNO1lBQ2hGeEcsQ0FBQUEsS0FBSzJaLG1CQUFtQnpQLE9BQU8sTUFBTSxRQUFRbEssT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd0csTUFBTTtZQUNoRmtULG9CQUFvQnhQLE9BQU8sR0FBRztZQUM5QnlQLG1CQUFtQnpQLE9BQU8sR0FBRztZQUM3QnVQLGNBQWM7UUFDbEI7SUFDSixHQUNBLHFFQUFxRTtJQUNyRSxFQUFFO0lBQ0YscURBQXFEO0lBQ3JELDJCQUEyQjtJQUMzQiwwREFBMEQ7SUFDMUQsRUFBRTtJQUNGLHVEQUF1RDtJQUN2RDtRQUFDRjtLQUFZO0lBQ2IsMERBQTBEO0lBQzFELDBFQUEwRTtJQUMxRSxxQkFBcUI7SUFDckIsTUFBTVMsZUFBZTNkLDZDQUFNQSxDQUFDO0lBQzVCRCxnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQ29kLGNBQWMsQ0FBQ0Usb0JBQW9CeFAsT0FBTyxFQUMzQztRQUNKa08sa0JBQWtCc0Isb0JBQW9CeFAsT0FBTyxFQUFFc0MsU0FBUyxNQUFNd04sYUFBYTlQLE9BQU87UUFDbEY4UCxhQUFhOVAsT0FBTyxHQUFHc0MsU0FBUztRQUNoQyxJQUFJb0UsY0FBYzhJLG9CQUFvQnhQLE9BQU8sQ0FBQzBHLFNBQVMsRUFDbkQ4SSxvQkFBb0J4UCxPQUFPLENBQUMwRyxTQUFTLEdBQUdBLGFBQWE7SUFDN0QsR0FBRztRQUFDNEk7UUFBWTVJO1FBQVdwRTtLQUFNO0lBQ2pDLHNCQUFzQjtJQUN0QnBRLGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFDb2QsWUFDRDtRQUNKLE1BQU1LLE9BQU9EO1FBQ2IsSUFBSSxDQUFDWCxhQUFhO1lBQ2RZLEtBQUtaLFdBQVcsR0FBRztRQUN2QixPQUNLO1lBQ0RZLEtBQUtaLFdBQVcsR0FBRyxJQUFJelksT0FBT0MsSUFBSSxDQUFDcVosSUFBSSxDQUFDYixXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRTtRQUMxRTtRQUNBLElBQUksQ0FBQ0QsZUFBZTtZQUNoQmEsS0FBS2IsYUFBYSxHQUFHO1FBQ3pCLE9BQ0s7WUFDRGEsS0FBS2IsYUFBYSxHQUNkLE9BQU9BLGtCQUFrQixXQUNuQkEsZ0JBQ0FXLG1CQUFtQnpQLE9BQU87UUFDeEM7UUFDQXNQLFdBQVd4TyxVQUFVLENBQUM0TztJQUMxQixHQUNBLHFFQUFxRTtJQUNyRSx1REFBdUQ7SUFDdkQsdURBQXVEO0lBQ3ZEO1FBQUNBO1FBQW1CWDtRQUFhRDtLQUFjO0lBQy9DLHlCQUF5QjtJQUN6QmpILHFCQUFxQnlILFlBQVksU0FBU0o7SUFDMUNySCxxQkFBcUJ5SCxZQUFZLGNBQWNIO0lBQy9DLDJEQUEyRDtJQUMzRCxNQUFNbFksTUFBTXlRO0lBQ1p4VixnREFBU0EsQ0FBQztRQUNOLElBQUkyRDtRQUNKLGtFQUFrRTtRQUNsRSxJQUFJLENBQUNvQixPQUFPLENBQUNxWSxjQUFjTixXQUFXLE1BQ2xDO1FBQ0osTUFBTWUscUJBQXFCLENBQUMsQ0FBQ2Y7UUFDN0IsTUFBTWdCLGNBQWM7WUFBRS9ZO1FBQUk7UUFDMUIsSUFBSStYLFFBQVE7WUFDUmdCLFlBQVloQixNQUFNLEdBQUdBO1lBQ3JCLHVFQUF1RTtZQUN2RSxJQUFJckQsaUJBQWlCcUQsV0FBV0EsT0FBT3BELE9BQU8sWUFBWXFFLFNBQVM7Z0JBQy9ELE1BQU1DLFlBQVlsQixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT21CLHFCQUFxQjtnQkFDOUYsd0VBQXdFO2dCQUN4RSwyRUFBMkU7Z0JBQzNFLDJFQUEyRTtnQkFDM0UseUZBQXlGO2dCQUN6RiwwQkFBMEI7Z0JBQzFCLElBQUlELGFBQWFsQixPQUFPaEIsT0FBTyxDQUFDQyxNQUFNLEtBQUssT0FBTztvQkFDOUMsNkVBQTZFO29CQUM3RSxjQUFjO29CQUNkLE1BQU1tQyxtQkFBbUIsQ0FBQ3ZhLEtBQUttWixPQUFPcEQsT0FBTyxDQUFDeUUsaUJBQWlCLE1BQU0sUUFBUXhhLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dhLGlCQUFpQjtvQkFDMUgsTUFBTUMsYUFBYUYscUJBQXFCLFFBQVFBLHFCQUFxQixLQUFLLElBQUksS0FBSyxJQUFJQSxpQkFBaUJELHFCQUFxQjtvQkFDN0gsaUNBQWlDO29CQUNqQyxNQUFNSSxnQkFBZ0JELFdBQVczTSxDQUFDLEdBQzlCdU0sVUFBVXZNLENBQUMsR0FDWCxDQUFDMk0sV0FBV2xKLEtBQUssR0FBRzhJLFVBQVU5SSxLQUFLLElBQUk7b0JBQzNDLE1BQU1vSixnQkFBZ0JGLFdBQVcxQyxDQUFDLEdBQUdzQyxVQUFVdEMsQ0FBQztvQkFDaEQsTUFBTStCLE9BQU9EO29CQUNiQyxLQUFLWixXQUFXLEdBQUcsSUFBSXpZLE9BQU9DLElBQUksQ0FBQ3FaLElBQUksQ0FBQ2IsY0FBY0EsV0FBVyxDQUFDLEVBQUUsR0FBR3dCLGdCQUFnQkEsZUFBZXhCLGNBQWNBLFdBQVcsQ0FBQyxFQUFFLEdBQUd5QixnQkFBZ0JBO29CQUNySmxCLFdBQVd4TyxVQUFVLENBQUM2TztnQkFDMUI7WUFDSjtRQUNKO1FBQ0EsSUFBSVYsZ0JBQWdCL1QsV0FBVztZQUMzQjhVLFlBQVlmLFdBQVcsR0FBR0E7UUFDOUI7UUFDQUssV0FBV21CLElBQUksQ0FBQ1Q7UUFDaEIsT0FBTztZQUNILHdGQUF3RjtZQUN4RixzRkFBc0Y7WUFDdEYsb0NBQW9DO1lBQ3BDLDBFQUEwRTtZQUMxRSxJQUFJRCxvQkFDQVQsV0FBV2xYLEdBQUcsQ0FBQyxVQUFVO1lBQzdCa1gsV0FBV29CLEtBQUs7UUFDcEI7SUFDSixHQUFHO1FBQUNwQjtRQUFZTjtRQUFRL1g7UUFBS2dZO1FBQWFTO1FBQW1CWDtLQUFZO0lBQ3pFLHFCQUFRbGQsZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsTUFDeEMyZCxvQkFBb0J4UCxPQUFPLGtCQUN2QnZOLHVEQUFZQSxDQUFDOEksVUFBVWlVLG9CQUFvQnhQLE9BQU8sR0FDdER5UCxtQkFBbUJ6UCxPQUFPLEtBQUssc0JBQzNCdk4sdURBQVlBLENBQUNxYyxlQUFlVyxtQkFBbUJ6UCxPQUFPO0FBQ2xFO0tBdkpNNk87O1FBV2tCakg7UUFJTTNIO1FBZ0YxQjRIO1FBQ0FBO1FBRVlIOzs7TUFsR1ZtSDtBQXlKTjs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsU0FBUytCLGVBQWVDLFFBQVE7SUFDNUIsT0FBTyxPQUFPQSxhQUFhLFdBQ3JCQSxXQUNBLEdBQW1CQSxPQUFoQkEsU0FBU2pULEdBQUcsRUFBQyxLQUFnQixPQUFiaVQsU0FBU2hULEdBQUc7QUFDekM7QUFDQSwyREFBMkQ7QUFDM0QsU0FBU2lULFlBQVlDLE1BQU07SUFDdkIsT0FBT0EsT0FBT0MsS0FBSyxDQUFDO0FBQ3hCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJDLEdBQ0QsU0FBU0M7UUFBcUJDLFVBQUFBLGlFQUFVLEVBQUU7SUFDdEMsTUFBTUMsZUFBZSxFQUFFO0lBQ3ZCLHlCQUF5QjtJQUN6QixNQUFNQyxpQkFBaUJGLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRRyxNQUFNLENBQUMsQ0FBQ2hHLFFBQVFMO1FBQzdGLE1BQU0sRUFBRTlILFFBQVEsS0FBSyxFQUFFb08sS0FBSyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFekMsTUFBTSxFQUFFLEdBQUdoRTtRQUM1RCwwRkFBMEY7UUFDMUYsTUFBTTBHLGdCQUFnQkQsT0FBTztZQUFDQTtZQUFNekM7WUFBUXdDO1NBQU0sR0FBRztZQUFDdE87WUFBT29PO1lBQU9DO1NBQUs7UUFDekUsTUFBTXBhLE1BQU11YSxjQUFjQyxNQUFNLENBQUNyRSxTQUFTOVYsSUFBSSxDQUFDO1FBQy9DNlQsTUFBTSxDQUFDbFUsSUFBSSxHQUFHa1UsTUFBTSxDQUFDbFUsSUFBSSxJQUFJLEVBQUU7UUFDL0JrVSxNQUFNLENBQUNsVSxJQUFJLENBQUNmLElBQUksQ0FBQzRVO1FBQ2pCLE9BQU9LO0lBQ1gsR0FBRyxDQUFDO0lBQ0pwWSxPQUFPMmUsTUFBTSxDQUFDUixtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSUEsaUJBQWlCLENBQUMsR0FBR1MsT0FBTyxDQUFDWCxDQUFBQTtRQUM5RixJQUFJWSxjQUFjO1FBQ2xCLE1BQU0sRUFBRUwsSUFBSSxFQUFFLEdBQUdQLE9BQU8sQ0FBQyxFQUFFO1FBQzNCLHlGQUF5RjtRQUN6RmplLE9BQU8rRSxPQUFPLENBQUNrWixPQUFPLENBQUMsRUFBRSxFQUFFVyxPQUFPLENBQUM7Z0JBQUMsQ0FBQzFhLEtBQUtuRCxNQUFNO1lBQzVDLGlGQUFpRjtZQUNqRixNQUFNK2QsZUFBZU4sT0FDZjtnQkFBQztnQkFBUTtnQkFBVTthQUFRLEdBQzNCO2dCQUFDO2dCQUFTO2dCQUFTO2FBQU87WUFDaEMsSUFBSU0sYUFBYWxWLFFBQVEsQ0FBQzFGLE1BQU07Z0JBQzVCMmEsZUFBZSxJQUFXOWQsT0FBUG1ELEtBQUksS0FBUyxPQUFObkQ7WUFDOUI7UUFDSjtRQUNBLDhEQUE4RDtRQUM5RCw0REFBNEQ7UUFDNUQsS0FBSyxNQUFNZ1gsVUFBVWtHLFFBQVM7WUFDMUIsTUFBTUwsV0FBVyxPQUFPN0YsT0FBTzZGLFFBQVEsS0FBSyxXQUN0QzdGLE9BQU82RixRQUFRLEdBQ2YsR0FBMEI3RixPQUF2QkEsT0FBTzZGLFFBQVEsQ0FBQ2pULEdBQUcsRUFBQyxLQUF1QixPQUFwQm9OLE9BQU82RixRQUFRLENBQUNoVCxHQUFHO1lBQ25EaVUsZUFBZSxJQUFhLE9BQVRqQjtRQUN2QjtRQUNBTSxhQUFhL2EsSUFBSSxDQUFDMGI7SUFDdEI7SUFDQSxPQUFPWCxhQUFhbGEsR0FBRyxDQUFDNlo7QUFDNUI7QUFFQSx1RUFBdUU7QUFDdkUsTUFBTWtCLGtCQUFrQjtJQUFDO0lBQVM7SUFBVTtJQUFhO0NBQVc7QUFDcEU7Ozs7Q0FJQyxHQUNELFNBQVNDLGlCQUFpQkMsSUFBSTtJQUMxQixJQUFJQyxjQUFjO0lBQ2xCSCxnQkFBZ0JILE9BQU8sQ0FBQzFhLENBQUFBO1FBQ3BCLElBQUkrYSxJQUFJLENBQUMvYSxJQUFJLEtBQUsrRCxXQUFXO1lBQ3pCaVgsZUFBZSxJQUFXRCxPQUFQL2EsS0FBSSxLQUFhLE9BQVYrYSxJQUFJLENBQUMvYSxJQUFJO1FBQ3ZDO0lBQ0o7SUFDQSxPQUFPZ2I7QUFDWDtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTQyxzQkFBc0JDLFdBQVc7SUFDdEMsSUFBSSxPQUFPQSxnQkFBZ0IsVUFBVTtRQUNqQyxPQUFPLElBQW9DLE9BQWhDQyxtQkFBbUJEO0lBQ2xDO0lBQ0EsT0FBT0EsWUFBWXBiLEdBQUcsQ0FBQzRaLENBQUFBLFdBQVksSUFBNkIsT0FBekJELGVBQWVDLFlBQWFyWixJQUFJLENBQUM7QUFDNUU7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELFNBQVMrYTtRQUFtQkMsUUFBQUEsaUVBQVEsRUFBRTtJQUNsQyxPQUFPQSxNQUFNdmIsR0FBRyxDQUFDaWIsQ0FBQUE7UUFDYixNQUFNQyxjQUFjRixpQkFBaUJDO1FBQ3JDLE1BQU1PLG1CQUFtQkwsc0JBQXNCRixLQUFLRyxXQUFXO1FBQy9ELE1BQU1LLFlBQVlQLGNBQWNNO1FBQ2hDLE9BQU8zQixZQUFZNEI7SUFDdkI7QUFDSjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBU0Msc0JBQXNCdEgsTUFBTTtJQUNqQyxPQUFPQSxPQUNGcFUsR0FBRyxDQUFDLENBQUMyYjtRQUNOLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFVBQVUsRUFBRSxFQUFFLEdBQUdIO1FBQ25ELElBQUlJLGNBQWM7UUFDbEIsSUFBSUgsYUFBYTtZQUNiRyxlQUFlLFlBQXdCLE9BQVpIO1FBQy9CO1FBQ0EsSUFBSUMsYUFBYTtZQUNiRSxlQUFlLFlBQXdCLE9BQVpGO1FBQy9CO1FBQ0EsS0FBSyxNQUFNRyxVQUFVRixRQUFTO1lBQzFCOWYsT0FBTytFLE9BQU8sQ0FBQ2liLFFBQVFwQixPQUFPLENBQUM7b0JBQUMsQ0FBQzVjLE1BQU1qQixNQUFNO2dCQUN6Q2dmLGVBQWUsSUFBWTNhLE9BQVJwRCxNQUFLLEtBQW9DLE9BQWpDb0QsT0FBT3JFLE9BQU9rRSxPQUFPLENBQUMsS0FBSztZQUMxRDtRQUNKO1FBQ0EsT0FBTzhhO0lBQ1gsR0FDSy9iLEdBQUcsQ0FBQzZaO0FBQ2I7QUFFQSxNQUFNb0MsbUJBQW1CO0FBQ3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrRUMsR0FDRCxTQUFTQyxvQkFBb0IsS0FBNEk7UUFBNUksRUFBRTlZLE1BQU0sRUFBRStNLEtBQUssRUFBRTNCLE1BQU0sRUFBRTFJLE1BQU0sRUFBRUUsSUFBSSxFQUFFdVUsS0FBSyxFQUFFNEIsTUFBTSxFQUFFQyxPQUFPLEVBQUVqYyxRQUFRLEVBQUVDLE1BQU0sRUFBRTZOLEtBQUssRUFBRWdNLFVBQVUsRUFBRSxFQUFFc0IsUUFBUSxFQUFFLEVBQUVjLFVBQVUsRUFBRSxFQUFFaFIsUUFBUSxFQUFFLEVBQUUsR0FBNUk7SUFDekIsSUFBSSxDQUFDakksUUFBUTtRQUNUeEQsUUFBUUMsSUFBSSxDQUFDO0lBQ2pCO0lBQ0EsSUFBSSxDQUFDc1EsU0FBUyxDQUFDM0IsUUFBUTtRQUNuQjVPLFFBQVFDLElBQUksQ0FBQztJQUNqQjtJQUNBLE1BQU1uQixTQUFTMUMsT0FBTzRHLE1BQU0sQ0FBQzVHLE9BQU80RyxNQUFNLENBQUM1RyxPQUFPNEcsTUFBTSxDQUFDNUcsT0FBTzRHLE1BQU0sQ0FBQzVHLE9BQU80RyxNQUFNLENBQUM1RyxPQUFPNEcsTUFBTSxDQUFDNUcsT0FBTzRHLE1BQU0sQ0FBQzVHLE9BQU80RyxNQUFNLENBQUM7UUFBRTFDLEtBQUtrRDtRQUFRa1gsTUFBTSxHQUFZOUwsT0FBVDJCLE9BQU0sS0FBVSxPQUFQM0I7SUFBUyxHQUFJMUksVUFBVTtRQUFFQSxRQUFRNlQsZUFBZTdUO0lBQVEsSUFBTUUsUUFBUTtRQUFFQTtJQUFLLElBQU11VSxTQUFTO1FBQUVBO0lBQU0sSUFBTTRCLFVBQVU7UUFBRUE7SUFBTyxJQUFNQyxXQUFXO1FBQUVFLFNBQVNGO0lBQVEsSUFBTWpjLFlBQVk7UUFBRUE7SUFBUyxJQUFNQyxVQUFVO1FBQUVBO0lBQU8sSUFBTTZOLFNBQVM7UUFBRXNPLFFBQVF0TztJQUFNO0lBQ3RaLE1BQU11TyxNQUFNLElBQUlDLElBQUlSO0lBQ3BCLDBDQUEwQztJQUMxQ2pnQixPQUFPK0UsT0FBTyxDQUFDckMsUUFBUWtjLE9BQU8sQ0FBQztZQUFDLENBQUMxYSxLQUFLbkQsTUFBTTtRQUN4Q3lmLElBQUlFLFlBQVksQ0FBQzVhLE1BQU0sQ0FBQzVCLEtBQUtrQixPQUFPckU7SUFDeEM7SUFDQSxtQkFBbUI7SUFDbkIsS0FBSyxNQUFNOGQsZUFBZWIscUJBQXFCQyxTQUFVO1FBQ3JEdUMsSUFBSUUsWUFBWSxDQUFDNWEsTUFBTSxDQUFDLFdBQVcrWTtJQUN2QztJQUNBLGlCQUFpQjtJQUNqQixLQUFLLE1BQU1ZLGFBQWFILG1CQUFtQkMsT0FBUTtRQUMvQ2lCLElBQUlFLFlBQVksQ0FBQzVhLE1BQU0sQ0FBQyxRQUFRMlo7SUFDcEM7SUFDQSw2QkFBNkI7SUFDN0IsSUFBSVksUUFBUTlmLE1BQU0sRUFBRTtRQUNoQmlnQixJQUFJRSxZQUFZLENBQUM1YSxNQUFNLENBQUMsV0FBV3VhLFFBQVFyYyxHQUFHLENBQUM0WixDQUFBQSxXQUFZRCxlQUFlQyxXQUFXclosSUFBSSxDQUFDO0lBQzlGO0lBQ0EsMkJBQTJCO0lBQzNCLEtBQUssTUFBTXdiLGVBQWVMLHNCQUFzQnJRLE9BQVE7UUFDcERtUixJQUFJRSxZQUFZLENBQUM1YSxNQUFNLENBQUMsU0FBU2lhO0lBQ3JDO0lBQ0EsT0FBT1MsSUFBSWpiLFFBQVE7QUFDdkI7QUFFQSxNQUFNb2IsWUFBWSxDQUFDMVo7SUFDZixNQUFNLEVBQUV1WixHQUFHLEVBQUUvTSxTQUFTLEVBQUUsR0FBR3hNO0lBQzNCLElBQUksQ0FBQ3VaLEtBQ0QsTUFBTSxJQUFJemUsTUFBTTtJQUNwQixxQkFBT25ELGdEQUFtQixDQUFDLE9BQU87UUFBRTZVLFdBQVdBO1FBQVduTyxLQUFLa2I7UUFBS3JNLE9BQU87SUFBTztBQUN0RjtNQUxNd007QUFPTjs7O0NBR0MsR0FDRCxNQUFNQyxrQkFBa0I7SUFDcEJoSyxVQUFVO0lBQ1ZDLFlBQVk7SUFDWkMsS0FBSztJQUNMQyxXQUFXO0lBQ1hDLGFBQWE7SUFDYkMsVUFBVTtJQUNWQyxNQUFNO0lBQ05DLGFBQWE7SUFDYkMsV0FBVztJQUNYQyxPQUFPO0lBQ1BDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxhQUFhO0lBQ2JDLGVBQWU7SUFDZkMsUUFBUTtJQUNSQyxjQUFjO0lBQ2RDLFFBQVE7SUFDUmlKLDBCQUEwQjtJQUMxQkMsMkJBQTJCO0lBQzNCQyx3QkFBd0I7SUFDeEJDLDJCQUEyQjtJQUMzQkMsMEJBQTBCO0lBQzFCQyx3QkFBd0I7SUFDeEJDLHdCQUF3QjtJQUN4QkMseUJBQXlCO0lBQ3pCQyxzQkFBc0I7SUFDdEJDLHdCQUF3QjtJQUN4QkMseUJBQXlCO0lBQ3pCQyxzQkFBc0I7QUFDMUI7QUFDQSxNQUFNQyxhQUFhO1FBQUMsRUFBRW5aLFFBQVEsRUFBRWdILFFBQVEsRUFBRTs7SUFDdEMsTUFBTW9TLG1CQUFtQjdpQiw4Q0FBT0EsQ0FBQyxJQUFNOEYsU0FBU0MsYUFBYSxDQUFDLFFBQVEsRUFBRTtJQUN4RSxNQUFNWixNQUFNeVE7SUFDWnhWLGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFDK0UsS0FDRDtRQUNKLE1BQU0yZCxXQUFXM2QsSUFBSTJkLFFBQVEsQ0FBQ3JTLFNBQVM7UUFDdkNxUyxTQUFTeGUsSUFBSSxDQUFDdWU7UUFDZCxPQUFPO1lBQ0gsTUFBTUUsZ0JBQWdCRCxTQUFTRSxRQUFRO1lBQ3ZDLHVHQUF1RztZQUN2RyxJQUFJLENBQUNELGVBQ0Q7WUFDSixNQUFNRSxRQUFRRixjQUFjeGhCLE9BQU8sQ0FBQ3NoQjtZQUNwQ0MsU0FBU0ksUUFBUSxDQUFDRDtRQUN0QjtJQUNKLEdBQUc7UUFBQ0o7UUFBa0IxZDtRQUFLc0w7S0FBUztJQUNwQyxxQkFBTzlQLHVEQUFZQSxDQUFDOEksVUFBVW9aO0FBQ2xDO0tBbEJNRDs7UUFFVWhOOzs7TUFGVmdOO0FBb0JOLFNBQVNPLFVBQVUvYSxLQUFLOztJQUNwQixNQUFNLENBQUM4USxRQUFRUSxVQUFVLEdBQUd6WiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNa0YsTUFBTXlRO0lBQ1osTUFBTSxFQUFFakosT0FBTyxFQUFFRyxNQUFNLEVBQUUwTixXQUFXLEVBQUVDLFNBQVMsRUFBRTJJLFdBQVcsRUFBRUMsVUFBVSxFQUFFLEdBQUdqYixPQUFPa2IsZ0JBQWdCeGlCLE9BQU9zSCxPQUFPO1FBQUM7UUFBVztRQUFVO1FBQWU7UUFBYTtRQUFlO0tBQWE7SUFDaE0sTUFBTSxFQUFFcUksUUFBUSxFQUFFbUssU0FBUyxFQUFFLEdBQUcwSTtJQUNoQyxzRUFBc0U7SUFDdEVsakIsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUMrRSxLQUFLO1lBQ04sSUFBSUEsUUFBUWlFLFdBQ1JyRSxRQUFRaEMsS0FBSyxDQUFDO1lBQ2xCO1FBQ0o7UUFDQSxNQUFNbVksWUFBWSxJQUFJMVcsT0FBT0MsSUFBSSxDQUFDOGUsTUFBTSxDQUFDRDtRQUN6Q3BJLFVBQVU3SSxNQUFNLENBQUNsTjtRQUNqQnVVLFVBQVV3QjtRQUNWLE9BQU87WUFDSEEsVUFBVTdJLE1BQU0sQ0FBQztZQUNqQnFILFVBQVU7UUFDZDtJQUNBLHdFQUF3RTtJQUN4RSx5REFBeUQ7SUFDekQsaUVBQWlFO0lBQ2pFLHVEQUF1RDtJQUMzRCxHQUFHO1FBQUN2VTtLQUFJO0lBQ1Isd0VBQXdFO0lBQ3hFL0UsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUM4WSxRQUNEO1FBQ0osTUFBTVUsSUFBSVY7UUFDVixzQkFBc0I7UUFDdEIsTUFBTXNLLE1BQU1oZixPQUFPQyxJQUFJLENBQUMyRixLQUFLO1FBQzdCLElBQUl1QyxTQUNBNlcsSUFBSW5aLFdBQVcsQ0FBQ3VQLEdBQUcsU0FBU2pOO1FBQ2hDLElBQUlHLFFBQ0EwVyxJQUFJblosV0FBVyxDQUFDdVAsR0FBRyxRQUFROU07UUFDL0IsSUFBSTBOLGFBQ0FnSixJQUFJblosV0FBVyxDQUFDdVAsR0FBRyxhQUFhWTtRQUNwQyxJQUFJQyxXQUNBK0ksSUFBSW5aLFdBQVcsQ0FBQ3VQLEdBQUcsV0FBV2E7UUFDbEMsSUFBSTJJLGFBQ0FJLElBQUluWixXQUFXLENBQUN1UCxHQUFHLGFBQWF3SjtRQUNwQyxJQUFJQyxZQUNBRyxJQUFJblosV0FBVyxDQUFDdVAsR0FBRyxZQUFZeUo7UUFDbkNuSyxPQUFPdUssWUFBWSxDQUFDakksUUFBUVo7UUFDNUIsT0FBTztZQUNINEksSUFBSXRQLHNCQUFzQixDQUFDMEY7UUFDL0I7SUFDSixHQUFHO1FBQ0NWO1FBQ0EwQjtRQUNBak87UUFDQUc7UUFDQTBOO1FBQ0FDO1FBQ0EySTtRQUNBQztLQUNIO0lBQ0Qsc0VBQXNFO0lBQ3RFLHNFQUFzRTtJQUN0RSxrREFBa0Q7SUFDbERqakIsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUM4WSxRQUNEO1FBQ0osSUFBSW9LLGVBQ0FwSyxPQUFPbEssVUFBVSxDQUFDc1U7SUFDMUIsR0FBRztRQUFDcEs7UUFBUW9LO0tBQWM7SUFDMUIsK0JBQStCO0lBQy9CbGpCLGdEQUFTQSxDQUFDO1FBQ04sNENBQTRDO1FBQzVDLElBQUl3YSxhQUFhLENBQUNuSyxZQUFZLENBQUN5SSxRQUMzQjtRQUNKQSxPQUFPd0ssV0FBVyxDQUFDalQ7SUFDdkIsR0FBRztRQUFDbUs7UUFBV25LO1FBQVV5STtLQUFPO0lBQ2hDLE9BQU9BO0FBQ1g7S0ExRVNpSzs7UUFFT3ZOOzs7QUF5RWhCOztDQUVDLEdBQ0QsTUFBTTJOLHVCQUFTL2lCLEtBQUFBLGlEQUFVQSxZQUFDLENBQUM0SCxPQUFPNkY7O0lBQzlCLE1BQU1pTCxTQUFTaUssVUFBVS9hO0lBQ3pCM0gsMERBQW1CQSxDQUFDd04sS0FBSyxJQUFNaUwsUUFBUTtRQUFDQTtLQUFPO0lBQy9DLHFCQUFPblosZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUU7QUFDL0M7O1FBSG1Cb2pCOzs7O1FBQUFBOzs7O0FBSW5CSSxPQUFPL0osV0FBVyxHQUFHO0FBQ3JCLFNBQVNtSzs7SUFDTCxNQUFNLENBQUN6SyxRQUFRUSxVQUFVLEdBQUd6WiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNMFosY0FBY3haLGtEQUFXQSxDQUFDLENBQUN5WjtRQUM3QkYsVUFBVUU7SUFDZCxHQUFHLEVBQUU7SUFDTCxPQUFPO1FBQUNEO1FBQWFUO0tBQU87QUFDaEM7S0FOU3lLO0FBUVQ7O0NBRUMsR0FDRCxNQUFNQyxNQUFNeGIsQ0FBQUE7O0lBQ1IsSUFBSXJFO0lBQ0osTUFBTThmLGlCQUFpQixDQUFDOWYsS0FBS3pELGlEQUFVQSxDQUFDdVgsc0JBQXFCLE1BQU8sUUFBUTlULE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR21WLE1BQU07SUFDOUcsTUFBTTRLLGlCQUFpQjlqQiw4Q0FBT0EsQ0FBQyxJQUFNOEYsU0FBU0MsYUFBYSxDQUFDLFFBQVEsRUFBRTtJQUN0RSwyQkFBMkI7SUFDM0IzRixnREFBU0EsQ0FBQztRQUNOLElBQUkyRDtRQUNKLElBQUksQ0FBQzhmLGdCQUFnQjtZQUNqQixJQUFJQSxtQkFBbUJ6YSxXQUFXO2dCQUM5QnJFLFFBQVFoQyxLQUFLLENBQUM7WUFDbEI7WUFDQTtRQUNKO1FBQ0EsSUFBSXFGLE1BQU0yYixLQUFLLElBQUkzYixNQUFNcUIsUUFBUSxFQUFFO1lBQy9CZ00sYUFBYTtRQUNqQjtRQUNBLElBQUkvVSwyQ0FBUUEsQ0FBQ3VhLEtBQUssQ0FBQzdTLE1BQU1xQixRQUFRLElBQUksR0FBRztZQUNwQ2dNLGFBQWE7UUFDakI7UUFDQSxNQUFNdU8saUJBQWlCN2lCLE9BQU80RyxNQUFNLENBQUMsQ0FBQyxHQUFHSztRQUN6QyxNQUFNNmIsYUFBYSxJQUFJemYsT0FBT0MsSUFBSSxDQUFDeVUsTUFBTSxDQUFDZ0wsVUFBVSxDQUFDRjtRQUNyRCw4RUFBOEU7UUFDOUUscUZBQXFGO1FBQ3JGLElBQUk1YixNQUFNcUIsUUFBUSxFQUFFO1lBQ2hCd2EsV0FBV0YsS0FBSyxHQUFHRDtRQUN2QjtRQUNBLDhEQUE4RDtRQUM5RCw4Q0FBOEM7UUFDOUMsK0JBQStCO1FBQy9CLCtEQUErRDtRQUMvRCxNQUFNSyxnQkFBZ0IsQ0FBQ3BnQixLQUFLOGYsZUFBZS9KLE9BQU8sTUFBTSxRQUFRL1YsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcWdCLFVBQVU7UUFDdEcsTUFBT0Qsa0JBQWtCLFFBQVFBLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJQSxjQUFjQyxVQUFVLENBQUU7WUFDM0ZELGNBQWNFLFdBQVcsQ0FBQ0YsY0FBY0MsVUFBVTtRQUN0RDtRQUNBLElBQUlELGVBQWU7WUFDZkEsY0FBYzNRLFdBQVcsQ0FBQ3lRLFdBQVd0SSxPQUFPO1FBQ2hEO0lBQ0osR0FBRztRQUFDa0k7UUFBZ0JDO1FBQWdCMWI7S0FBTTtJQUMxQyxxQkFBT3pILHVEQUFZQSxDQUFDeUgsTUFBTXFCLFFBQVEsRUFBRXFhO0FBQ3hDO0tBdkNNRjtPQUFBQTtBQXlDTixNQUFNVSxZQUFZLENBQUN6UyxHQUFHMFMsSUFBSUMsSUFBSUMsSUFBSUMsS0FBT0QsS0FBSyxDQUFFNVMsSUFBSTBTLEVBQUMsSUFBTUcsQ0FBQUEsS0FBS0QsRUFBQyxJQUFPRCxDQUFBQSxLQUFLRCxFQUFDO0FBQzlFLE1BQU1JLGdCQUFnQixDQUFDeFo7SUFDbkIsSUFBSUEsUUFBUSxJQUFJO1FBQ1osT0FBTztJQUNYO0lBQ0EsSUFBSUEsUUFBUSxNQUFNO1FBQ2QsT0FBTztJQUNYO0lBQ0Esa0JBQWtCO0lBQ2xCLElBQUlBLFFBQVEsSUFBSTtRQUNaLE9BQU9tWixVQUFVblosTUFBTSxJQUFJLElBQUksSUFBSTtJQUN2QztJQUNBLG9CQUFvQjtJQUNwQixPQUFPbVosVUFBVW5aLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDekM7QUFDQTs7Q0FFQyxHQUNELDhEQUE4RDtBQUM5RCxNQUFNeVosaUJBQWlCO1FBQUMsRUFBRXhWLFNBQVMsRUFBRTtJQUNqQyxNQUFNSyxRQUFRTCxVQUFVSyxLQUFLO0lBQzdCLE1BQU1vVixTQUFTelYsVUFBVWpFLElBQUksR0FBRztJQUNoQyxNQUFNMlosVUFBVUgsY0FBY0U7SUFDOUIsT0FBTzFqQixPQUFPNEcsTUFBTSxDQUFDNUcsT0FBTzRHLE1BQU0sQ0FBQyxDQUFDLEdBQUdxSCxZQUFZO1FBQUUyVixNQUFNO1FBQUl0VixPQUFPdVYsS0FBS0MsR0FBRyxDQUFDSCxTQUFTclY7SUFBTztBQUNuRztBQUV3ZCxDQUN4ZCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2aXMuZ2wvcmVhY3QtZ29vZ2xlLW1hcHMvZGlzdC9pbmRleC5tb2Rlcm4ubWpzP2U3YzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VSZWR1Y2VyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNvbnRleHQsIHVzZUxheW91dEVmZmVjdCwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGlzRGVlcEVxdWFsIGZyb20gJ2Zhc3QtZGVlcC1lcXVhbCc7XG5cbi8vIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYnkgdGhlIGJ1aWxkIHByb2Nlc3MuXG5jb25zdCBWRVJTSU9OID0gJzEuNy4xJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jb25zdCBBUElMb2FkaW5nU3RhdHVzID0ge1xuICAgIE5PVF9MT0FERUQ6ICdOT1RfTE9BREVEJyxcbiAgICBMT0FESU5HOiAnTE9BRElORycsXG4gICAgTE9BREVEOiAnTE9BREVEJyxcbiAgICBGQUlMRUQ6ICdGQUlMRUQnLFxuICAgIEFVVEhfRkFJTFVSRTogJ0FVVEhfRkFJTFVSRSdcbn07XG5cbmNvbnN0IE1BUFNfQVBJX0JBU0VfVVJMID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcyc7XG4vKipcbiAqIEEgR29vZ2xlTWFwc0FwaUxvYWRlciB0byByZWxpYWJseSBsb2FkIGFuZCB1bmxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJLlxuICpcbiAqIFRoZSBhY3R1YWwgbG9hZGluZyBhbmQgdW5sb2FkaW5nIGlzIGRlbGF5ZWQgaW50byB0aGUgbWljcm90YXNrIHF1ZXVlLCB0b1xuICogYWxsb3cgdXNpbmcgdGhlIEFQSSBpbiBhbiB1c2VFZmZlY3QgaG9vaywgd2l0aG91dCB3b3JyeWluZyBhYm91dCBtdWx0aXBsZSBBUEkgbG9hZHMuXG4gKi9cbmNsYXNzIEdvb2dsZU1hcHNBcGlMb2FkZXIge1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBNYXBzIEphdmFTY3JpcHQgQVBJIHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICAgICAqIFNpbmNlIHRoZSBNYXBzIGxpYnJhcnkgY2FuIG9ubHkgYmUgbG9hZGVkIG9uY2UgcGVyIHBhZ2UsIHRoaXMgd2lsbFxuICAgICAqIHByb2R1Y2UgYSB3YXJuaW5nIHdoZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50XG4gICAgICogcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHdoZW4gbG9hZGluZyBjb21wbGV0ZXNcbiAgICAgKiBhbmQgcmVqZWN0cyBpbiBjYXNlIG9mIGFuIGVycm9yIG9yIHdoZW4gdGhlIGxvYWRpbmcgd2FzIGFib3J0ZWQuXG4gICAgICovXG4gICAgc3RhdGljIGxvYWQocGFyYW1zLCBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBsaWJyYXJpZXMgPSBwYXJhbXMubGlicmFyaWVzID8gcGFyYW1zLmxpYnJhcmllcy5zcGxpdCgnLCcpIDogW107XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gdGhpcy5zZXJpYWxpemVQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gob25Mb2FkaW5nU3RhdHVzQ2hhbmdlKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IGlmIGBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5YCBoYXMgYmVlbiBkZWZpbmVkIGV4dGVybmFsbHksIHdlXG4gICAgICAgICAgICAvLyAgIGFzc3VtZSB0aGF0IGxvYWRpbmcgaXMgY29tcGxldGUgYW5kIHN1Y2Nlc3NmdWwuXG4gICAgICAgICAgICAvLyAgIElmIGl0IHdhcyBkZWZpbmVkIGJ5IGEgcHJldmlvdXMgY2FsbCB0byB0aGlzIG1ldGhvZCwgYSB3YXJuaW5nXG4gICAgICAgICAgICAvLyAgIG1lc3NhZ2UgaXMgbG9nZ2VkIGlmIHRoZXJlIGFyZSBkaWZmZXJlbmNlcyBpbiBhcGktcGFyYW1ldGVycyB1c2VkXG4gICAgICAgICAgICAvLyAgIGZvciBib3RoIGNhbGxzLlxuICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IHdpbmRvdy5nb29nbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXBzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW1wb3J0TGlicmFyeSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIHNlcmlhbGl6ZWQgcGFyYW1ldGVycyBtZWFucyBpdCB3YXMgbG9hZGVkIGV4dGVybmFsbHlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgPSBzZXJpYWxpemVkUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEltcG9ydExpYnJhcnkocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgIT09IHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtnb29nbGUtbWFwcy1hcGktbG9hZGVyXSBUaGUgbWFwcyBBUEkgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgYCArXG4gICAgICAgICAgICAgICAgICAgIGB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXJzIGFuZCB3aWxsIG5vdCBiZSBsb2FkZWQgYWdhaW4uIFJlZnJlc2ggdGhlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgcGFnZSBmb3IgbmV3IHZhbHVlcyB0byBoYXZlIGVmZmVjdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpYnJhcmllc1RvTG9hZCA9IFsnbWFwcycsIC4uLmxpYnJhcmllc107XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChsaWJyYXJpZXNUb0xvYWQubWFwKG5hbWUgPT4gZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShuYW1lKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBwYXJhbWV0ZXJzIHVzZWQgdG8gbG9hZCB0aGUgbGlicmFyeSBmb3IgZWFzaWVyIGNvbXBhcmlzb24uXG4gICAgICovXG4gICAgc3RhdGljIHNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBhcmFtcy52LFxuICAgICAgICAgICAgcGFyYW1zLmtleSxcbiAgICAgICAgICAgIHBhcmFtcy5sYW5ndWFnZSxcbiAgICAgICAgICAgIHBhcmFtcy5yZWdpb24sXG4gICAgICAgICAgICBwYXJhbXMuYXV0aFJlZmVycmVyUG9saWN5LFxuICAgICAgICAgICAgcGFyYW1zLnNvbHV0aW9uQ2hhbm5lbFxuICAgICAgICBdLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZ2xvYmFsIGBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5YCBmdW5jdGlvbiBmb3IgYm9vdHN0cmFwcGluZy5cbiAgICAgKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIGR5bmFtaWMgbG9hZGluZyBzY3JpcHRcbiAgICAgKiBmcm9tIHRoZSBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIHdpdGggc29tZSBtaW5vciBhZGp1c3RtZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBjcmVhdGVkIGltcG9ydExpYnJhcnkgZnVuY3Rpb24gd2lsbCBsb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSxcbiAgICAgKiB3aGljaCB3aWxsIHRoZW4gcmVwbGFjZSB0aGUgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGZ1bmN0aW9uIHdpdGggdGhlIGZ1bGxcbiAgICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvbG9hZC1tYXBzLWpzLWFwaSNkeW5hbWljLWxpYnJhcnktaW1wb3J0XG4gICAgICovXG4gICAgc3RhdGljIGluaXRJbXBvcnRMaWJyYXJ5KHBhcmFtcykge1xuICAgICAgICBpZiAoIXdpbmRvdy5nb29nbGUpXG4gICAgICAgICAgICB3aW5kb3cuZ29vZ2xlID0ge307XG4gICAgICAgIGlmICghd2luZG93Lmdvb2dsZS5tYXBzKVxuICAgICAgICAgICAgd2luZG93Lmdvb2dsZS5tYXBzID0ge307XG4gICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlLm1hcHNbJ2ltcG9ydExpYnJhcnknXSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2dvb2dsZS1tYXBzLWFwaS1sb2FkZXItaW50ZXJuYWxdOiBpbml0SW1wb3J0TGlicmFyeSBtdXN0IG9ubHkgYmUgY2FsbGVkIG9uY2UnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXBpUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGxvYWRBcGkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXBpUHJvbWlzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpUHJvbWlzZTtcbiAgICAgICAgICAgIGFwaVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxQYXJhbU5hbWUgPSBrZXkucmVwbGFjZSgvW0EtWl0vZywgdCA9PiAnXycgKyB0WzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB1cmxQYXJhbXMuc2V0KHVybFBhcmFtTmFtZSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQoJ2xvYWRpbmcnLCAnYXN5bmMnKTtcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXMuc2V0KCdjYWxsYmFjaycsICdfX2dvb2dsZU1hcHNDYWxsYmFja19fJyk7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5zcmMgPSBNQVBTX0FQSV9CQVNFX1VSTCArIGA/YCArIHVybFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsZW1lbnQubm9uY2UgPVxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W25vbmNlXScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9uY2UpIHx8ICcnO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsZW1lbnQub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgY291bGQgbm90IGxvYWQuJykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2luZG93Ll9fZ29vZ2xlTWFwc0NhbGxiYWNrX18gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2luZG93LmdtX2F1dGhGYWlsdXJlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURJTkc7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0RWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcGlQcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBmb3IgdGhlIGZpcnN0IGxvYWQsIHdlIGRlY2xhcmUgYW4gaW1wb3J0TGlicmFyeSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAgICAgICAgLy8gYmUgb3ZlcndyaXR0ZW4gb25jZSB0aGUgYXBpIGlzIGxvYWRlZC5cbiAgICAgICAgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSA9IGxpYnJhcnlOYW1lID0+IGxvYWRBcGkoKS50aGVuKCgpID0+IGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobGlicmFyeU5hbWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYWxsIHJlZ2lzdGVyZWQgbG9hZGluZ1N0YXR1c0xpc3RlbmVycyBhZnRlciBhIHN0YXR1cyB1cGRhdGUuXG4gICAgICovXG4gICAgc3RhdGljIG5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGZuKHRoaXMubG9hZGluZ1N0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBjdXJyZW50IGxvYWRpbmdTdGF0dXMgb2YgdGhlIEFQSS5cbiAqL1xuR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5OT1RfTE9BREVEO1xuLyoqXG4gKiBBIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGxvYWRpbmcgc3RhdHVzIGNoYW5nZXMuXG4gKi9cbkdvb2dsZU1hcHNBcGlMb2FkZXIubGlzdGVuZXJzID0gW107XG5cbmNvbnN0IERFRkFVTFRfU09MVVRJT05fQ0hBTk5FTCA9ICdHTVBfdmlzZ2xfcmdtbGlicmFyeV92MV9kZWZhdWx0JztcbmNvbnN0IERFRkFVTFRfSU5URVJOQUxfVVNBR0VfQVRUUklCVVRJT05fSURTID0gW1xuICAgIGBnbXBfdmlzZ2xfcmVhY3Rnb29nbGVtYXBzX3Yke1ZFUlNJT059YFxuXTtcbmNvbnN0IEFQSVByb3ZpZGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIGxvY2FsIGhvb2sgdG8gc2V0IHVwIHRoZSBtYXAtaW5zdGFuY2UgbWFuYWdlbWVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiB1c2VNYXBJbnN0YW5jZXMoKSB7XG4gICAgY29uc3QgW21hcEluc3RhbmNlcywgc2V0TWFwSW5zdGFuY2VzXSA9IHVzZVN0YXRlKHt9KTtcbiAgICBjb25zdCBhZGRNYXBJbnN0YW5jZSA9IChtYXBJbnN0YW5jZSwgaWQgPSAnZGVmYXVsdCcpID0+IHtcbiAgICAgICAgc2V0TWFwSW5zdGFuY2VzKGluc3RhbmNlcyA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZXMpLCB7IFtpZF06IG1hcEluc3RhbmNlIH0pKSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVNYXBJbnN0YW5jZSA9IChpZCA9ICdkZWZhdWx0JykgPT4ge1xuICAgICAgICBzZXRNYXBJbnN0YW5jZXMoKF9hKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2IgPSBpZDsgX2FbX2JdOyB2YXIgcmVtYWluaW5nID0gX19yZXN0KF9hLCBbdHlwZW9mIF9iID09PSBcInN5bWJvbFwiID8gX2IgOiBfYiArIFwiXCJdKTtcbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2xlYXJNYXBJbnN0YW5jZXMgPSAoKSA9PiB7XG4gICAgICAgIHNldE1hcEluc3RhbmNlcyh7fSk7XG4gICAgfTtcbiAgICByZXR1cm4geyBtYXBJbnN0YW5jZXMsIGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSwgY2xlYXJNYXBJbnN0YW5jZXMgfTtcbn1cbi8qKlxuICogbG9jYWwgaG9vayB0byBoYW5kbGUgdGhlIGxvYWRpbmcgb2YgdGhlIG1hcHMgQVBJLCByZXR1cm5zIHRoZSBjdXJyZW50IGxvYWRpbmcgc3RhdHVzXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gdXNlR29vZ2xlTWFwc0FwaUxvYWRlcihwcm9wcykge1xuICAgIGNvbnN0IHsgb25Mb2FkLCBvbkVycm9yLCBhcGlLZXksIHZlcnNpb24sIGxpYnJhcmllcyA9IFtdIH0gPSBwcm9wcywgb3RoZXJBcGlQYXJhbXMgPSBfX3Jlc3QocHJvcHMsIFtcIm9uTG9hZFwiLCBcIm9uRXJyb3JcIiwgXCJhcGlLZXlcIiwgXCJ2ZXJzaW9uXCIsIFwibGlicmFyaWVzXCJdKTtcbiAgICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUoR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkaW5nU3RhdHVzKTtcbiAgICBjb25zdCBbbG9hZGVkTGlicmFyaWVzLCBhZGRMb2FkZWRMaWJyYXJ5XSA9IHVzZVJlZHVjZXIoKGxvYWRlZExpYnJhcmllcywgYWN0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2FkZWRMaWJyYXJpZXNbYWN0aW9uLm5hbWVdXG4gICAgICAgICAgICA/IGxvYWRlZExpYnJhcmllc1xuICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvYWRlZExpYnJhcmllcyksIHsgW2FjdGlvbi5uYW1lXTogYWN0aW9uLnZhbHVlIH0pO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBsaWJyYXJpZXNTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGxpYnJhcmllcyA9PT0gbnVsbCB8fCBsaWJyYXJpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpYnJhcmllcy5qb2luKCcsJyksIFtsaWJyYXJpZXNdKTtcbiAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gdXNlTWVtbygoKSA9PiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgYXBpS2V5LCB2ZXJzaW9uIH0sIG90aGVyQXBpUGFyYW1zKSksIFthcGlLZXksIHZlcnNpb24sIG90aGVyQXBpUGFyYW1zXSk7XG4gICAgY29uc3QgaW1wb3J0TGlicmFyeSA9IHVzZUNhbGxiYWNrKChuYW1lKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGxvYWRlZExpYnJhcmllc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlZExpYnJhcmllc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoX2EgPSBnb29nbGUgPT09IG51bGwgfHwgZ29vZ2xlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnb29nbGUubWFwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmltcG9ydExpYnJhcnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1thcGktcHJvdmlkZXItaW50ZXJuYWxdIGltcG9ydExpYnJhcnkgd2FzIGNhbGxlZCBiZWZvcmUgJyArXG4gICAgICAgICAgICAgICAgJ2dvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkgd2FzIGRlZmluZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0geWllbGQgd2luZG93Lmdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgICAgIGFkZExvYWRlZExpYnJhcnkoeyBuYW1lLCB2YWx1ZTogcmVzIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pLCBbbG9hZGVkTGlicmFyaWVzXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7IGtleTogYXBpS2V5IH0sIG90aGVyQXBpUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbilcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnYgPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGlmICgobGlicmFyaWVzU3RyaW5nID09PSBudWxsIHx8IGxpYnJhcmllc1N0cmluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlicmFyaWVzU3RyaW5nLmxlbmd0aCkgPiAwKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGlicmFyaWVzID0gbGlicmFyaWVzU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY2hhbm5lbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jaGFubmVsIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2hhbm5lbCA+IDk5OSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5jaGFubmVsO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc29sdXRpb25DaGFubmVsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zb2x1dGlvbkNoYW5uZWwgPSBERUZBVUxUX1NPTFVUSU9OX0NIQU5ORUw7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zLnNvbHV0aW9uQ2hhbm5lbCA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuc29sdXRpb25DaGFubmVsO1xuICAgICAgICAgICAgICAgIHlpZWxkIEdvb2dsZU1hcHNBcGlMb2FkZXIubG9hZChwYXJhbXMsIHN0YXR1cyA9PiBzZXRTdGF0dXMoc3RhdHVzKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFsnY29yZScsICdtYXBzJywgLi4ubGlicmFyaWVzXSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpbXBvcnRMaWJyYXJ5KG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignPEFwaVByb3ZpZGVyPiBmYWlsZWQgdG8gbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEknLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSkoKTtcbiAgICB9LCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2FwaUtleSwgbGlicmFyaWVzU3RyaW5nLCBzZXJpYWxpemVkUGFyYW1zXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgICAgIGltcG9ydExpYnJhcnlcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlSW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzKHByb3BzKSB7XG4gICAgY29uc3QgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzID0gdXNlTWVtbygoKSA9PiBwcm9wcy5kaXNhYmxlVXNhZ2VBdHRyaWJ1dGlvblxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBERUZBVUxUX0lOVEVSTkFMX1VTQUdFX0FUVFJJQlVUSU9OX0lEUywgW3Byb3BzLmRpc2FibGVVc2FnZUF0dHJpYnV0aW9uXSk7XG4gICAgcmV0dXJuIGludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHdyYXAgdGhlIGNvbXBvbmVudHMgZnJvbSB0aGlzIGxpYnJhcnkgYW5kIGxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJXG4gKi9cbmNvbnN0IEFQSVByb3ZpZGVyID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHByb3BzLCBsb2FkZXJQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wiY2hpbGRyZW5cIl0pO1xuICAgIGNvbnN0IHsgbWFwSW5zdGFuY2VzLCBhZGRNYXBJbnN0YW5jZSwgcmVtb3ZlTWFwSW5zdGFuY2UsIGNsZWFyTWFwSW5zdGFuY2VzIH0gPSB1c2VNYXBJbnN0YW5jZXMoKTtcbiAgICBjb25zdCB7IHN0YXR1cywgbG9hZGVkTGlicmFyaWVzLCBpbXBvcnRMaWJyYXJ5IH0gPSB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKGxvYWRlclByb3BzKTtcbiAgICBjb25zdCBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgPSB1c2VJbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMobG9hZGVyUHJvcHMpO1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgbWFwSW5zdGFuY2VzLFxuICAgICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgICAgIGNsZWFyTWFwSW5zdGFuY2VzLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICAgICAgaW1wb3J0TGlicmFyeSxcbiAgICAgICAgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzXG4gICAgfSksIFtcbiAgICAgICAgbWFwSW5zdGFuY2VzLFxuICAgICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgICAgIGNsZWFyTWFwSW5zdGFuY2VzLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICAgICAgaW1wb3J0TGlicmFyeSxcbiAgICAgICAgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzXG4gICAgXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEFQSVByb3ZpZGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKSk7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgZWZmZWN0cyB0byBiaW5kIGV2ZW50LWhhbmRsZXJzIGZvciBhbGwgZXZlbnQtcHJvcHMgaW4gTWFwRXZlbnRQcm9wcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBFdmVudHMobWFwLCBwcm9wcykge1xuICAgIC8vIG5vdGU6IGNhbGxpbmcgYSB1c2VFZmZlY3QgaG9vayBmcm9tIHdpdGhpbiBhIGxvb3AgaXMgcHJvaGliaXRlZCBieSB0aGVcbiAgICAvLyBydWxlcyBvZiBob29rcywgYnV0IGl0J3Mgb2sgaGVyZSBzaW5jZSBpdCdzIHVuY29uZGl0aW9uYWwgYW5kIHRoZSBudW1iZXJcbiAgICAvLyBhbmQgb3JkZXIgb2YgaXRlcmF0aW9ucyBpcyBhbHdheXMgc3RyaWN0bHkgdGhlIHNhbWUuXG4gICAgLy8gKHNlZSBodHRwczovL2xlZ2FjeS5yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJ1bGVzLmh0bWwpXG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBldmVudFByb3BOYW1lcykge1xuICAgICAgICAvLyBmaXhtZTogdGhpcyBjYXN0IGlzIGVzc2VudGlhbGx5IGEgJ3RydXN0IG1lLCBicm8nIGZvciB0eXBlc2NyaXB0LCBidXRcbiAgICAgICAgLy8gICBhIHByb3BlciBzb2x1dGlvbiBzZWVtcyB3YXkgdG9vIGNvbXBsaWNhdGVkIHJpZ2h0IG5vd1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBjb25zdCBldmVudFR5cGUgPSBwcm9wTmFtZVRvRXZlbnRUeXBlW3Byb3BOYW1lXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsIGV2ZW50VHlwZSwgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihjcmVhdGVNYXBFdmVudChldmVudFR5cGUsIG1hcCwgZXYpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgICB9LCBbbWFwLCBldmVudFR5cGUsIGhhbmRsZXJdKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgd3JhcHBlZCBtYXAtZXZlbnRzIHVzZWQgZm9yIHRoZSBldmVudC1wcm9wcy5cbiAqIEBwYXJhbSB0eXBlIHRoZSBldmVudCB0eXBlIGFzIGl0IGlzIHNwZWNpZmllZCB0byB0aGUgbWFwcyBhcGlcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tXG4gKiBAcGFyYW0gc3JjRXZlbnQgdGhlIHNvdXJjZS1ldmVudCBpZiB0aGVyZSBpcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hcEV2ZW50KHR5cGUsIG1hcCwgc3JjRXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXYgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIG1hcCxcbiAgICAgICAgZGV0YWlsOiB7fSxcbiAgICAgICAgc3RvcHBhYmxlOiBmYWxzZSxcbiAgICAgICAgc3RvcDogKCkgPT4geyB9XG4gICAgfTtcbiAgICBpZiAoY2FtZXJhRXZlbnRUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICBjb25zdCBjYW1FdmVudCA9IGV2O1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICBjb25zdCBoZWFkaW5nID0gbWFwLmdldEhlYWRpbmcoKSB8fCAwO1xuICAgICAgICBjb25zdCB0aWx0ID0gbWFwLmdldFRpbHQoKSB8fCAwO1xuICAgICAgICBjb25zdCBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgIGlmICghY2VudGVyIHx8ICFib3VuZHMgfHwgIU51bWJlci5pc0Zpbml0ZSh6b29tKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbY3JlYXRlRXZlbnRdIGF0IGxlYXN0IG9uZSBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIG1hcCAnICtcbiAgICAgICAgICAgICAgICAncmV0dXJuZWQgdW5kZWZpbmVkLiBUaGlzIGlzIG5vdCBleHBlY3RlZCB0byBoYXBwZW4uIFBsZWFzZSAnICtcbiAgICAgICAgICAgICAgICAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FtRXZlbnQuZGV0YWlsID0ge1xuICAgICAgICAgICAgY2VudGVyOiAoY2VudGVyID09PSBudWxsIHx8IGNlbnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7IGxhdDogMCwgbG5nOiAwIH0sXG4gICAgICAgICAgICB6b29tOiB6b29tIHx8IDAsXG4gICAgICAgICAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgICAgICAgICAgdGlsdDogdGlsdCxcbiAgICAgICAgICAgIGJvdW5kczogKGJvdW5kcyA9PT0gbnVsbCB8fCBib3VuZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvdW5kcy50b0pTT04oKSkgfHwge1xuICAgICAgICAgICAgICAgIG5vcnRoOiA5MCxcbiAgICAgICAgICAgICAgICBlYXN0OiAxODAsXG4gICAgICAgICAgICAgICAgc291dGg6IC05MCxcbiAgICAgICAgICAgICAgICB3ZXN0OiAtMTgwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYW1FdmVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAobW91c2VFdmVudFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGlmICghc3JjRXZlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjcmVhdGVFdmVudF0gbW91c2UgZXZlbnRzIG11c3QgcHJvdmlkZSBhIHNyY0V2ZW50Jyk7XG4gICAgICAgIGNvbnN0IG1vdXNlRXZlbnQgPSBldjtcbiAgICAgICAgbW91c2VFdmVudC5kb21FdmVudCA9IHNyY0V2ZW50LmRvbUV2ZW50O1xuICAgICAgICBtb3VzZUV2ZW50LnN0b3BwYWJsZSA9IHRydWU7XG4gICAgICAgIG1vdXNlRXZlbnQuc3RvcCA9ICgpID0+IHNyY0V2ZW50LnN0b3AoKTtcbiAgICAgICAgbW91c2VFdmVudC5kZXRhaWwgPSB7XG4gICAgICAgICAgICBsYXRMbmc6ICgoX2EgPSBzcmNFdmVudC5sYXRMbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHBsYWNlSWQ6IHNyY0V2ZW50LnBsYWNlSWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBldjtcbn1cbi8qKlxuICogbWFwcyB0aGUgY2FtZWxDYXNlZCBuYW1lcyBvZiBldmVudC1wcm9wcyB0byB0aGUgY29ycmVzcG9uZGluZyBldmVudC10eXBlc1xuICogdXNlZCBpbiB0aGUgbWFwcyBBUEkuXG4gKi9cbmNvbnN0IHByb3BOYW1lVG9FdmVudFR5cGUgPSB7XG4gICAgb25Cb3VuZHNDaGFuZ2VkOiAnYm91bmRzX2NoYW5nZWQnLFxuICAgIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxuICAgIG9uQ29udGV4dG1lbnU6ICdjb250ZXh0bWVudScsXG4gICAgb25EYmxjbGljazogJ2RibGNsaWNrJyxcbiAgICBvbkRyYWc6ICdkcmFnJyxcbiAgICBvbkRyYWdlbmQ6ICdkcmFnZW5kJyxcbiAgICBvbkRyYWdzdGFydDogJ2RyYWdzdGFydCcsXG4gICAgb25IZWFkaW5nQ2hhbmdlZDogJ2hlYWRpbmdfY2hhbmdlZCcsXG4gICAgb25JZGxlOiAnaWRsZScsXG4gICAgb25Jc0ZyYWN0aW9uYWxab29tRW5hYmxlZENoYW5nZWQ6ICdpc2ZyYWN0aW9uYWx6b29tZW5hYmxlZF9jaGFuZ2VkJyxcbiAgICBvbk1hcENhcGFiaWxpdGllc0NoYW5nZWQ6ICdtYXBjYXBhYmlsaXRpZXNfY2hhbmdlZCcsXG4gICAgb25NYXBUeXBlSWRDaGFuZ2VkOiAnbWFwdHlwZWlkX2NoYW5nZWQnLFxuICAgIG9uTW91c2Vtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICBvbk1vdXNlb3V0OiAnbW91c2VvdXQnLFxuICAgIG9uTW91c2VvdmVyOiAnbW91c2VvdmVyJyxcbiAgICBvblByb2plY3Rpb25DaGFuZ2VkOiAncHJvamVjdGlvbl9jaGFuZ2VkJyxcbiAgICBvblJlbmRlcmluZ1R5cGVDaGFuZ2VkOiAncmVuZGVyaW5ndHlwZV9jaGFuZ2VkJyxcbiAgICBvblRpbGVzTG9hZGVkOiAndGlsZXNsb2FkZWQnLFxuICAgIG9uVGlsdENoYW5nZWQ6ICd0aWx0X2NoYW5nZWQnLFxuICAgIG9uWm9vbUNoYW5nZWQ6ICd6b29tX2NoYW5nZWQnLFxuICAgIC8vIG5vdGU6IG9uQ2FtZXJhQ2hhbmdlZCBpcyBhbiBhbGlhcyBmb3IgdGhlIGJvdW5kc19jaGFuZ2VkIGV2ZW50LFxuICAgIC8vIHNpbmNlIHRoYXQgaXMgZ29pbmcgdG8gYmUgZmlyZWQgaW4gZXZlcnkgc2l0dWF0aW9uIHdoZXJlIHRoZSBjYW1lcmEgaXNcbiAgICAvLyB1cGRhdGVkLlxuICAgIG9uQ2FtZXJhQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJ1xufTtcbmNvbnN0IGNhbWVyYUV2ZW50VHlwZXMgPSBbXG4gICAgJ2JvdW5kc19jaGFuZ2VkJyxcbiAgICAnY2VudGVyX2NoYW5nZWQnLFxuICAgICdoZWFkaW5nX2NoYW5nZWQnLFxuICAgICd0aWx0X2NoYW5nZWQnLFxuICAgICd6b29tX2NoYW5nZWQnXG5dO1xuY29uc3QgbW91c2VFdmVudFR5cGVzID0gW1xuICAgICdjbGljaycsXG4gICAgJ2NvbnRleHRtZW51JyxcbiAgICAnZGJsY2xpY2snLFxuICAgICdtb3VzZW1vdmUnLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ21vdXNlb3Zlcidcbl07XG5jb25zdCBldmVudFByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BOYW1lVG9FdmVudFR5cGUpO1xuXG4vKipcbiAqIEEgaG9vayB0byBzdG9yZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYSB2YXJpYWJsZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RvcmVcbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyB2YWx1ZVxuICovXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZih1bmRlZmluZWQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3JlZnNcbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9pemVkKHZhbHVlLCBpc0VxdWFsKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSB1c2VQcmV2aW91cyh2YWx1ZSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAocHJldmlvdXMgJiYgaXNFcXVhbChwcmV2aW91cywgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIFt2YWx1ZSwgcHJldmlvdXMsIGlzRXF1YWxdKTtcbn1cblxuZnVuY3Rpb24gdXNlQ3VzdG9tQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcGVuZGVuY2llcywgaXNFcXVhbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB1c2VFZmZlY3QoZWZmZWN0LCBbdXNlTWVtb2l6ZWQoZGVwZW5kZW5jaWVzLCBpc0VxdWFsKV0pO1xufVxuXG5mdW5jdGlvbiB1c2VEZWVwQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcGVuZGVuY2llcykge1xuICAgIHVzZUN1c3RvbUNvbXBhcmVFZmZlY3QoZWZmZWN0LCBkZXBlbmRlbmNpZXMsIGlzRGVlcEVxdWFsKTtcbn1cblxuY29uc3QgbWFwT3B0aW9uS2V5cyA9IG5ldyBTZXQoW1xuICAgICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICdjbGlja2FibGVJY29ucycsXG4gICAgJ2NvbnRyb2xTaXplJyxcbiAgICAnZGlzYWJsZURlZmF1bHRVSScsXG4gICAgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLFxuICAgICdkcmFnZ2FibGUnLFxuICAgICdkcmFnZ2FibGVDdXJzb3InLFxuICAgICdkcmFnZ2luZ0N1cnNvcicsXG4gICAgJ2Z1bGxzY3JlZW5Db250cm9sJyxcbiAgICAnZnVsbHNjcmVlbkNvbnRyb2xPcHRpb25zJyxcbiAgICAnZ2VzdHVyZUhhbmRsaW5nJyxcbiAgICAnaGVhZGluZ0ludGVyYWN0aW9uRW5hYmxlZCcsXG4gICAgJ2lzRnJhY3Rpb25hbFpvb21FbmFibGVkJyxcbiAgICAna2V5Ym9hcmRTaG9ydGN1dHMnLFxuICAgICdtYXBUeXBlQ29udHJvbCcsXG4gICAgJ21hcFR5cGVDb250cm9sT3B0aW9ucycsXG4gICAgJ21hcFR5cGVJZCcsXG4gICAgJ21heFpvb20nLFxuICAgICdtaW5ab29tJyxcbiAgICAnbm9DbGVhcicsXG4gICAgJ3BhbkNvbnRyb2wnLFxuICAgICdwYW5Db250cm9sT3B0aW9ucycsXG4gICAgJ3Jlc3RyaWN0aW9uJyxcbiAgICAncm90YXRlQ29udHJvbCcsXG4gICAgJ3JvdGF0ZUNvbnRyb2xPcHRpb25zJyxcbiAgICAnc2NhbGVDb250cm9sJyxcbiAgICAnc2NhbGVDb250cm9sT3B0aW9ucycsXG4gICAgJ3Njcm9sbHdoZWVsJyxcbiAgICAnc3RyZWV0VmlldycsXG4gICAgJ3N0cmVldFZpZXdDb250cm9sJyxcbiAgICAnc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zJyxcbiAgICAnc3R5bGVzJyxcbiAgICAndGlsdEludGVyYWN0aW9uRW5hYmxlZCcsXG4gICAgJ3pvb21Db250cm9sJyxcbiAgICAnem9vbUNvbnRyb2xPcHRpb25zJ1xuXSk7XG4vKipcbiAqIEludGVybmFsIGhvb2sgdG8gdXBkYXRlIHRoZSBtYXAtb3B0aW9ucyB3aGVuIHByb3BzIGFyZSBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZVxuICogQHBhcmFtIG1hcFByb3BzIHRoZSBwcm9wcyB0byB1cGRhdGUgdGhlIG1hcC1pbnN0YW5jZSB3aXRoXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwT3B0aW9ucyhtYXAsIG1hcFByb3BzKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGVmZmVjdHMgYXJlbid0IHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgY2hhbmdlZC5cbiAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSB2YWx1ZXMgd2lsbCBiZSBvciBoYXZlIGJlZW4gcGFzc2VkIHRvIHRoZSBtYXBcbiAgICAgKiBjb25zdHJ1Y3RvciB2aWEgbWFwT3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdCBtYXBPcHRpb25zID0ge307XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1hcFByb3BzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghbWFwT3B0aW9uS2V5cy5oYXMoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBtYXBPcHRpb25zW2tleV0gPSBtYXBQcm9wc1trZXldO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgdGhlIG1hcCBvcHRpb25zIHdoZW4gbWFwT3B0aW9ucyBpcyBjaGFuZ2VkXG4gICAgLy8gTm90ZTogZHVlIHRvIHRoZSBkZXN0cnVjdHVyaW5nIGFib3ZlLCBtYXBPcHRpb25zIHdpbGwgYmUgc2VlbiBhcyBjaGFuZ2VkXG4gICAgLy8gICB3aXRoIGV2ZXJ5IHJlLXJlbmRlciwgc28gd2UncmUgYXNzdW1pbmcgdGhlIG1hcHMtYXBpIHdpbGwgcHJvcGVybHlcbiAgICAvLyAgIGRlYWwgd2l0aCB1bmNoYW5nZWQgb3B0aW9uLXZhbHVlcyBwYXNzZWQgaW50byBzZXRPcHRpb25zLlxuICAgIHVzZURlZXBDb21wYXJlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hcC5zZXRPcHRpb25zKG1hcE9wdGlvbnMpO1xuICAgIH0sIFttYXBPcHRpb25zXSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbn1cblxuZnVuY3Rpb24gdXNlQXBpTG9hZGluZ1N0YXR1cygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpIHx8IEFQSUxvYWRpbmdTdGF0dXMuTk9UX0xPQURFRDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBob29rIHRoYXQgdXBkYXRlcyB0aGUgY2FtZXJhIHdoZW4gZGVjay5nbCB2aWV3U3RhdGUgY2hhbmdlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcykge1xuICAgIGNvbnN0IHsgdmlld3BvcnQsIHZpZXdTdGF0ZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNEZWNrR2xDb250cm9sbGVkID0gISF2aWV3cG9ydDtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcCB8fCAhdmlld1N0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUsIGJlYXJpbmc6IGhlYWRpbmcsIHBpdGNoOiB0aWx0LCB6b29tIH0gPSB2aWV3U3RhdGU7XG4gICAgICAgIG1hcC5tb3ZlQ2FtZXJhKHtcbiAgICAgICAgICAgIGNlbnRlcjogeyBsYXQ6IGxhdGl0dWRlLCBsbmc6IGxvbmdpdHVkZSB9LFxuICAgICAgICAgICAgaGVhZGluZyxcbiAgICAgICAgICAgIHRpbHQsXG4gICAgICAgICAgICB6b29tOiB6b29tICsgMVxuICAgICAgICB9KTtcbiAgICB9LCBbbWFwLCB2aWV3U3RhdGVdKTtcbiAgICByZXR1cm4gaXNEZWNrR2xDb250cm9sbGVkO1xufVxuXG5mdW5jdGlvbiBpc0xhdExuZ0xpdGVyYWwob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoISgnbGF0JyBpbiBvYmogJiYgJ2xuZycgaW4gb2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUob2JqLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKG9iai5sbmcpO1xufVxuZnVuY3Rpb24gbGF0TG5nRXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoIWEgfHwgIWIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBBID0gdG9MYXRMbmdMaXRlcmFsKGEpO1xuICAgIGNvbnN0IEIgPSB0b0xhdExuZ0xpdGVyYWwoYik7XG4gICAgaWYgKEEubGF0ICE9PSBCLmxhdCB8fCBBLmxuZyAhPT0gQi5sbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvTGF0TG5nTGl0ZXJhbChvYmopIHtcbiAgICBpZiAoaXNMYXRMbmdMaXRlcmFsKG9iaikpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIG9iai50b0pTT04oKTtcbn1cblxuZnVuY3Rpb24gdXNlTWFwQ2FtZXJhUGFyYW1zKG1hcCwgY2FtZXJhU3RhdGVSZWYsIG1hcFByb3BzKSB7XG4gICAgY29uc3QgY2VudGVyID0gbWFwUHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKG1hcFByb3BzLmNlbnRlcikgOiBudWxsO1xuICAgIGxldCBsYXQgPSBudWxsO1xuICAgIGxldCBsbmcgPSBudWxsO1xuICAgIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgICAgICBsYXQgPSBjZW50ZXIubGF0O1xuICAgICAgICBsbmcgPSBjZW50ZXIubG5nO1xuICAgIH1cbiAgICBjb25zdCB6b29tID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLnpvb20pXG4gICAgICAgID8gbWFwUHJvcHMuem9vbVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgaGVhZGluZyA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy5oZWFkaW5nKVxuICAgICAgICA/IG1hcFByb3BzLmhlYWRpbmdcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHRpbHQgPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMudGlsdClcbiAgICAgICAgPyBtYXBQcm9wcy50aWx0XG4gICAgICAgIDogbnVsbDtcbiAgICAvLyB0aGUgZm9sbG93aW5nIGVmZmVjdCBydW5zIGZvciBldmVyeSByZW5kZXIgb2YgdGhlIG1hcCBjb21wb25lbnQgYW5kIGNoZWNrc1xuICAgIC8vIGlmIHRoZXJlIGFyZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBrbm93biBzdGF0ZSBvZiB0aGUgbWFwIGluc3RhbmNlXG4gICAgLy8gKGNhbWVyYVN0YXRlUmVmLCB3aGljaCBpcyB1cGRhdGVkIGJ5IGFsbCBib3VuZHNfY2hhbmdlZCBldmVudHMpIGFuZCB0aGVcbiAgICAvLyBkZXNpcmVkIHN0YXRlIGluIHRoZSBwcm9wcy5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV4dENhbWVyYSA9IHt9O1xuICAgICAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxhdCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgbG5nICE9PSBudWxsICYmXG4gICAgICAgICAgICAoY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubGF0ICE9PSBsYXQgfHxcbiAgICAgICAgICAgICAgICBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmNlbnRlci5sbmcgIT09IGxuZykpIHtcbiAgICAgICAgICAgIG5leHRDYW1lcmEuY2VudGVyID0geyBsYXQsIGxuZyB9O1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b29tICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuem9vbSAhPT0gem9vbSkge1xuICAgICAgICAgICAgbmV4dENhbWVyYS56b29tID0gem9vbTtcbiAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGluZyAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmhlYWRpbmcgIT09IGhlYWRpbmcpIHtcbiAgICAgICAgICAgIG5leHRDYW1lcmEuaGVhZGluZyA9IGhlYWRpbmc7XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbHQgIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC50aWx0ICE9PSB0aWx0KSB7XG4gICAgICAgICAgICBuZXh0Q2FtZXJhLnRpbHQgPSB0aWx0O1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgbWFwLm1vdmVDYW1lcmEobmV4dENhbWVyYSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuY29uc3QgQXV0aEZhaWx1cmVNZXNzYWdlID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB6SW5kZXg6IDk5OSxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RmxvdzogJ2NvbHVtbiBub3dyYXAnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgIGZvbnRTaXplOiAnLjhyZW0nLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC42KScsXG4gICAgICAgIGJhY2tncm91bmQ6ICcjZGRkZGRkJyxcbiAgICAgICAgcGFkZGluZzogJzFyZW0gMS41cmVtJ1xuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHN0eWxlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIkVycm9yOiBBdXRoRmFpbHVyZVwiKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCxcbiAgICAgICAgICAgIFwiQSBwcm9ibGVtIHdpdGggeW91ciBBUEkga2V5IHByZXZlbnRzIHRoZSBtYXAgZnJvbSByZW5kZXJpbmcgY29ycmVjdGx5LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSB2YWx1ZSBvZiB0aGUgXCIsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBcIkFQSVByb3ZpZGVyLmFwaUtleVwiKSxcbiAgICAgICAgICAgIFwiIHByb3AgaXMgY29ycmVjdC4gQ2hlY2sgdGhlIGVycm9yLW1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgZm9yIGZ1cnRoZXIgZGV0YWlscy5cIikpKTtcbn07XG5cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrUmVmKCkge1xuICAgIGNvbnN0IFtlbCwgc2V0RWxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgcmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiBzZXRFbCh2YWx1ZSksIFtzZXRFbF0pO1xuICAgIHJldHVybiBbZWwsIHJlZl07XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiB0aGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBpcyBsb2FkZWRcbiAqL1xuZnVuY3Rpb24gdXNlQXBpSXNMb2FkZWQoKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICAgIHJldHVybiBzdGF0dXMgPT09IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xufVxuXG5mdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcbiAgICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VSZWR1Y2VyKHggPT4geCArIDEsIDApO1xuICAgIHJldHVybiBmb3JjZVVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQm91bmRzQ2hhbmdlKG1hcCwgcmVmKSB7XG4gICAgY29uc3QgY2VudGVyID0gbWFwLmdldENlbnRlcigpO1xuICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gICAgY29uc3QgdGlsdCA9IG1hcC5nZXRUaWx0KCkgfHwgMDtcbiAgICBjb25zdCBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3VzZVRyYWNrZWRDYW1lcmFTdGF0ZV0gYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgbWFwICcgK1xuICAgICAgICAgICAgJ3JldHVybmVkIHVuZGVmaW5lZC4gVGhpcyBpcyBub3QgZXhwZWN0ZWQgdG8gaGFwcGVuLiBQbGVhc2UgJyArXG4gICAgICAgICAgICAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gICAgfVxuICAgIC8vIGZpeG1lOiBkbyB3ZSBuZWVkIHRoZSBgdW5kZWZpbmVkYCBjYXNlcyBmb3IgdGhlIGNhbWVyYS1wYXJhbXM/IFdoZW4gYXJlIHRoZXkgdXNlZCBpbiB0aGUgbWFwcyBBUEk/XG4gICAgT2JqZWN0LmFzc2lnbihyZWYuY3VycmVudCwge1xuICAgICAgICBjZW50ZXI6IChjZW50ZXIgPT09IG51bGwgfHwgY2VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZW50ZXIudG9KU09OKCkpIHx8IHsgbGF0OiAwLCBsbmc6IDAgfSxcbiAgICAgICAgem9vbTogem9vbSB8fCAwLFxuICAgICAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgICAgICB0aWx0OiB0aWx0XG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QgdG8gdHJhY2sgdGhlIGxhc3Qga25vd24gc3RhdGUgb2YgdGhlIG1hcCBjYW1lcmEuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYHVzZU1hcENhbWVyYVBhcmFtc2AgdG8gcmVkdWNlIHN0dXR0ZXJpbmcgaW4gbm9ybWFsIG9wZXJhdGlvblxuICogYnkgYXZvaWRpbmcgdXBkYXRlcyBvZiB0aGUgbWFwIGNhbWVyYSB3aXRoIHZhbHVlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCkge1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoe1xuICAgICAgICBjZW50ZXI6IHsgbGF0OiAwLCBsbmc6IDAgfSxcbiAgICAgICAgaGVhZGluZzogMCxcbiAgICAgICAgdGlsdDogMCxcbiAgICAgICAgem9vbTogMFxuICAgIH0pO1xuICAgIC8vIFJlY29yZCBjYW1lcmEgc3RhdGUgd2l0aCBldmVyeSBib3VuZHNfY2hhbmdlZCBldmVudCBkaXNwYXRjaGVkIGJ5IHRoZSBtYXAuXG4gICAgLy8gVGhpcyBkYXRhIGlzIHVzZWQgdG8gcHJldmVudCBmZWVkaW5nIHRoZXNlIHZhbHVlcyBiYWNrIHRvIHRoZVxuICAgIC8vIG1hcC1pbnN0YW5jZSB3aGVuIGEgdHlwaWNhbCBcImNvbnRyb2xsZWQgY29tcG9uZW50XCIgc2V0dXAgKHN0YXRlIHZhcmlhYmxlIGlzXG4gICAgLy8gZmVkIGludG8gYW5kIHVwZGF0ZWQgYnkgdGhlIG1hcCkuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnYm91bmRzX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVCb3VuZHNDaGFuZ2UobWFwLCByZWYpO1xuICAgICAgICAgICAgLy8gV2hlbiBhbiBldmVudCBpcyBvY2N1cmVkLCB3ZSBoYXZlIHRvIHVwZGF0ZSBkdXJpbmcgdGhlIG5leHQgY3ljbGUuXG4gICAgICAgICAgICAvLyBUaGUgYXBwbGljYXRpb24gY291bGQgZGVjaWRlIHRvIGlnbm9yZSB0aGUgZXZlbnQgYW5kIG5vdCB1cGRhdGUgYW55XG4gICAgICAgICAgICAvLyBjYW1lcmEgcHJvcHMgb2YgdGhlIG1hcCwgbWVhbmluZyB0aGF0IGluIHRoYXQgY2FzZSB3ZSB3aWxsIGhhdmUgdG9cbiAgICAgICAgICAgIC8vICd1bmRvJyB0aGUgY2hhbmdlIHRvIHRoZSBjYW1lcmEuXG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgIH0sIFttYXAsIGZvcmNlVXBkYXRlXSk7XG4gICAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBTdG9yZXMgYSBzdGFjayBvZiBtYXAtaW5zdGFuY2VzIGZvciBlYWNoIG1hcElkLiBXaGVuZXZlciBhblxuICogaW5zdGFuY2UgaXMgdXNlZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjayB3aGlsZSBpbiB1c2UsXG4gKiBhbmQgcmV0dXJuZWQgdG8gdGhlIHN0YWNrIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50cy5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIGNvcnJlY3RseSBpbXBsZW1lbnQgY2FjaGluZyBmb3IgbXVsdGlwbGVcbiAqIG1hcHMgb20gdGhlIHNhbWUgcGFnZSwgd2hpbGUgcmV1c2luZyBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICpcbiAqIEZJWE1FOiB3aGlsZSBpdCBzaG91bGQgaW4gdGhlb3J5IGJlIHBvc3NpYmxlIHRvIHJldXNlIG1hcHMgc29sZWx5XG4gKiAgIGJhc2VkIG9uIHRoZSBtYXBJZCAoYXMgYWxsIG90aGVyIHBhcmFtZXRlcnMgY2FuIGJlIGNoYW5nZWQgYXRcbiAqICAgcnVudGltZSksIHdlIGRvbid0IHlldCBoYXZlIGdvb2QgZW5vdWdoIHRyYWNraW5nIG9mIG9wdGlvbnMgdG9cbiAqICAgcmVsaWFibHkgdW5zZXQgYWxsIHRoZSBvcHRpb25zIHRoYXQgaGF2ZSBiZWVuIHNldC5cbiAqL1xuY2xhc3MgQ2FjaGVkTWFwU3RhY2sge1xuICAgIHN0YXRpYyBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNba2V5XSAmJiB0aGlzLmVudHJpZXNba2V5XS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBzdGF0aWMgcG9wKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuZW50cmllc1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNba2V5XS5wb3AoKSB8fCBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgcHVzaChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyaWVzW2tleV0pXG4gICAgICAgICAgICB0aGlzLmVudHJpZXNba2V5XSA9IFtdO1xuICAgICAgICB0aGlzLmVudHJpZXNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5DYWNoZWRNYXBTdGFjay5lbnRyaWVzID0ge307XG4vKipcbiAqIFRoZSBtYWluIGhvb2sgdGFrZXMgY2FyZSBvZiBjcmVhdGluZyBtYXAtaW5zdGFuY2VzIGFuZCByZWdpc3RlcmluZyB0aGVtIGluXG4gKiB0aGUgYXBpLXByb3ZpZGVyIGNvbnRleHQuXG4gKiBAcmV0dXJuIGEgdHVwbGUgb2YgdGhlIG1hcC1pbnN0YW5jZSBjcmVhdGVkIChvciBudWxsKSBhbmQgdGhlIGNhbGxiYWNrXG4gKiAgIHJlZiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXNzIHRoZSBtYXAtY29udGFpbmVyIGludG8gdGhpcyBob29rLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYXBpSXNMb2FkZWQgPSB1c2VBcGlJc0xvYWRlZCgpO1xuICAgIGNvbnN0IFttYXAsIHNldE1hcF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY29udGFpbmVyLCBjb250YWluZXJSZWZdID0gdXNlQ2FsbGJhY2tSZWYoKTtcbiAgICBjb25zdCBjYW1lcmFTdGF0ZVJlZiA9IHVzZVRyYWNrZWRDYW1lcmFTdGF0ZVJlZihtYXApO1xuICAgIGNvbnN0IHsgaWQsIGRlZmF1bHRCb3VuZHMsIGRlZmF1bHRDZW50ZXIsIGRlZmF1bHRab29tLCBkZWZhdWx0SGVhZGluZywgZGVmYXVsdFRpbHQsIHJldXNlTWFwcywgcmVuZGVyaW5nVHlwZSwgY29sb3JTY2hlbWUgfSA9IHByb3BzLCBtYXBPcHRpb25zID0gX19yZXN0KHByb3BzLCBbXCJpZFwiLCBcImRlZmF1bHRCb3VuZHNcIiwgXCJkZWZhdWx0Q2VudGVyXCIsIFwiZGVmYXVsdFpvb21cIiwgXCJkZWZhdWx0SGVhZGluZ1wiLCBcImRlZmF1bHRUaWx0XCIsIFwicmV1c2VNYXBzXCIsIFwicmVuZGVyaW5nVHlwZVwiLCBcImNvbG9yU2NoZW1lXCJdKTtcbiAgICBjb25zdCBoYXNab29tID0gcHJvcHMuem9vbSAhPT0gdW5kZWZpbmVkIHx8IHByb3BzLmRlZmF1bHRab29tICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzQ2VudGVyID0gcHJvcHMuY2VudGVyICE9PSB1bmRlZmluZWQgfHwgcHJvcHMuZGVmYXVsdENlbnRlciAhPT0gdW5kZWZpbmVkO1xuICAgIGlmICghZGVmYXVsdEJvdW5kcyAmJiAoIWhhc1pvb20gfHwgIWhhc0NlbnRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCc8TWFwPiBjb21wb25lbnQgaXMgbWlzc2luZyBjb25maWd1cmF0aW9uLiAnICtcbiAgICAgICAgICAgICdZb3UgaGF2ZSB0byBwcm92aWRlIHpvb20gYW5kIGNlbnRlciAodmlhIHRoZSBgem9vbWAvYGRlZmF1bHRab29tYCBhbmQgJyArXG4gICAgICAgICAgICAnYGNlbnRlcmAvYGRlZmF1bHRDZW50ZXJgIHByb3BzKSBvciBzcGVjaWZ5IHRoZSByZWdpb24gdG8gc2hvdyB1c2luZyAnICtcbiAgICAgICAgICAgICdgZGVmYXVsdEJvdW5kc2AuIFNlZSAnICtcbiAgICAgICAgICAgICdodHRwczovL3Zpc2dsLmdpdGh1Yi5pby9yZWFjdC1nb29nbGUtbWFwcy9kb2NzL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9tYXAjcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gYXBwbHkgZGVmYXVsdCBjYW1lcmEgcHJvcHMgaWYgYXZhaWxhYmxlIGFuZCBub3Qgb3ZlcndyaXR0ZW4gYnkgY29udHJvbGxlZCBwcm9wc1xuICAgIGlmICghbWFwT3B0aW9ucy5jZW50ZXIgJiYgZGVmYXVsdENlbnRlcilcbiAgICAgICAgbWFwT3B0aW9ucy5jZW50ZXIgPSBkZWZhdWx0Q2VudGVyO1xuICAgIGlmICghbWFwT3B0aW9ucy56b29tICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0Wm9vbSkpXG4gICAgICAgIG1hcE9wdGlvbnMuem9vbSA9IGRlZmF1bHRab29tO1xuICAgIGlmICghbWFwT3B0aW9ucy5oZWFkaW5nICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0SGVhZGluZykpXG4gICAgICAgIG1hcE9wdGlvbnMuaGVhZGluZyA9IGRlZmF1bHRIZWFkaW5nO1xuICAgIGlmICghbWFwT3B0aW9ucy50aWx0ICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0VGlsdCkpXG4gICAgICAgIG1hcE9wdGlvbnMudGlsdCA9IGRlZmF1bHRUaWx0O1xuICAgIC8vIEhhbmRsZSBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHNcbiAgICBjb25zdCBjdXN0b21JZHMgPSBtYXBPcHRpb25zLmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbiAgICBpZiAoY3VzdG9tSWRzID09IG51bGwpIHtcbiAgICAgICAgLy8gTm90IHNwZWNpZmllZCAtIHVzZSBjb250ZXh0IGRlZmF1bHQgKHdoaWNoIG1heSBiZSBudWxsIGlmIGRpc2FibGVkKVxuICAgICAgICBtYXBPcHRpb25zLmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyA9XG4gICAgICAgICAgICBjb250ZXh0LmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIGNvbnRleHQgZGVmYXVsdHMgd2l0aCBjdXN0b20gSURzXG4gICAgICAgIG1hcE9wdGlvbnMuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzID0gW1xuICAgICAgICAgICAgLi4uKGNvbnRleHQuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzIHx8IFtdKSxcbiAgICAgICAgICAgIC4uLmN1c3RvbUlkc1xuICAgICAgICBdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXBPcHRpb25zKSlcbiAgICAgICAgaWYgKG1hcE9wdGlvbnNba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGVsZXRlIG1hcE9wdGlvbnNba2V5XTtcbiAgICBjb25zdCBzYXZlZE1hcFN0YXRlUmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgLy8gY3JlYXRlIHRoZSBtYXAgaW5zdGFuY2UgYW5kIHJlZ2lzdGVyIGl0IGluIHRoZSBjb250ZXh0XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWFwaUlzTG9hZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSB9ID0gY29udGV4dDtcbiAgICAgICAgLy8gbm90ZTogY29sb3JTY2hlbWUgKHVwY29taW5nIGZlYXR1cmUpIGlzbid0IHlldCBpbiB0aGUgdHlwaW5ncywgcmVtb3ZlIG9uY2UgdGhhdCBpcyBmaXhlZDpcbiAgICAgICAgY29uc3QgeyBtYXBJZCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7bWFwSWQgfHwgJ2RlZmF1bHQnfToke3JlbmRlcmluZ1R5cGUgfHwgJ2RlZmF1bHQnfToke2NvbG9yU2NoZW1lIHx8ICdMSUdIVCd9YDtcbiAgICAgICAgbGV0IG1hcERpdjtcbiAgICAgICAgbGV0IG1hcDtcbiAgICAgICAgaWYgKHJldXNlTWFwcyAmJiBDYWNoZWRNYXBTdGFjay5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICBtYXAgPSBDYWNoZWRNYXBTdGFjay5wb3AoY2FjaGVLZXkpO1xuICAgICAgICAgICAgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcERpdik7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyhtYXBPcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGRldGFjaGluZyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00gbGV0cyB0aGUgbWFwIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdFxuICAgICAgICAgICAgLy8gc2l6ZSwgc2V0dGluZyB0aGUgY2VudGVyIHdpbGwgdHJpZ2dlciByZWxvYWRpbmcgdGhlIG1hcC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbWFwLnNldENlbnRlcihtYXAuZ2V0Q2VudGVyKCkpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWFwRGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtYXBEaXYpO1xuICAgICAgICAgICAgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChtYXBEaXYsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYXBPcHRpb25zKSwgKHJlbmRlcmluZ1R5cGVcbiAgICAgICAgICAgICAgICA/IHsgcmVuZGVyaW5nVHlwZTogcmVuZGVyaW5nVHlwZSB9XG4gICAgICAgICAgICAgICAgOiB7fSkpLCAoY29sb3JTY2hlbWVcbiAgICAgICAgICAgICAgICA/IHsgY29sb3JTY2hlbWU6IGNvbG9yU2NoZW1lIH1cbiAgICAgICAgICAgICAgICA6IHt9KSkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE1hcChtYXApO1xuICAgICAgICBhZGRNYXBJbnN0YW5jZShtYXAsIGlkKTtcbiAgICAgICAgaWYgKGRlZmF1bHRCb3VuZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFkZGluZyB9ID0gZGVmYXVsdEJvdW5kcywgZGVmQm91bmRzID0gX19yZXN0KGRlZmF1bHRCb3VuZHMsIFtcInBhZGRpbmdcIl0pO1xuICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhkZWZCb3VuZHMsIHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgbWFwIG5vdCByZW5kZXJpbmcgZHVlIHRvIG1pc3NpbmcgY29uZmlndXJhdGlvblxuICAgICAgICBlbHNlIGlmICghaGFzWm9vbSB8fCAhaGFzQ2VudGVyKSB7XG4gICAgICAgICAgICBtYXAuZml0Qm91bmRzKHsgZWFzdDogMTgwLCB3ZXN0OiAtMTgwLCBzb3V0aDogLTkwLCBub3J0aDogOTAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHNhdmVkTWFwU3RhdGUgaXMgdXNlZCB0byByZXN0b3JlIHRoZSBjYW1lcmEgcGFyYW1ldGVycyB3aGVuIHRoZSBtYXBJZCBpcyBjaGFuZ2VkXG4gICAgICAgIGlmIChzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWFwSWQ6IHNhdmVkTWFwSWQsIGNhbWVyYVN0YXRlOiBzYXZlZENhbWVyYVN0YXRlIH0gPSBzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoc2F2ZWRNYXBJZCAhPT0gbWFwSWQpIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyhzYXZlZENhbWVyYVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIG1hcElkLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgICAgICAgICBjYW1lcmFTdGF0ZTogY2FtZXJhU3RhdGVSZWYuY3VycmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGRldGFjaCB0aGUgbWFwLWRpdiBmcm9tIHRoZSBkb21cbiAgICAgICAgICAgIG1hcERpdi5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmIChyZXVzZU1hcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGJhY2sgb24gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgQ2FjaGVkTWFwU3RhY2sucHVzaChjYWNoZUtleSwgbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnQtbGlzdGVuZXJzIHRvIG1pbmltaXplIHRoZSBwb3NzaWJpbGl0eSBvZiBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNYXAobnVsbCk7XG4gICAgICAgICAgICByZW1vdmVNYXBJbnN0YW5jZShpZCk7XG4gICAgICAgIH07XG4gICAgfSwgXG4gICAgLy8gc29tZSBkZXBlbmRlbmNpZXMgYXJlIGlnbm9yZWQgaW4gdGhlIGxpc3QgYmVsb3c6XG4gICAgLy8gIC0gZGVmYXVsdEJvdW5kcyBhbmQgdGhlIGRlZmF1bHQqIGNhbWVyYSBwcm9wcyB3aWxsIG9ubHkgYmUgdXNlZCBvbmNlLCBhbmRcbiAgICAvLyAgICBjaGFuZ2VzIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgLy8gIC0gbWFwT3B0aW9ucyBoYXMgc3BlY2lhbCBob29rcyB0aGF0IHRha2UgY2FyZSBvZiB1cGRhdGluZyB0aGUgb3B0aW9uc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYXBpSXNMb2FkZWQsXG4gICAgICAgIGlkLFxuICAgICAgICAvLyB0aGVzZSBwcm9wcyBjYW4ndCBiZSBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIGFuZCByZXF1aXJlIGEgbmV3XG4gICAgICAgIC8vIGluc3RhbmNlIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgcHJvcHMubWFwSWQsXG4gICAgICAgIHByb3BzLnJlbmRlcmluZ1R5cGUsXG4gICAgICAgIHByb3BzLmNvbG9yU2NoZW1lXG4gICAgXSk7XG4gICAgcmV0dXJuIFttYXAsIGNvbnRhaW5lclJlZiwgY2FtZXJhU3RhdGVSZWZdO1xufVxuXG5jb25zdCBHb29nbGVNYXBzQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vLyBDb2xvclNjaGVtZSBhbmQgUmVuZGVyaW5nVHlwZSBhcmUgcmVkZWZpbmVkIGhlcmUgdG8gbWFrZSB0aGVtIHVzYWJsZSBiZWZvcmUgdGhlXG4vLyBtYXBzIEFQSSBoYXMgYmVlbiBmdWxseSBsb2FkZWQuXG5jb25zdCBDb2xvclNjaGVtZSA9IHtcbiAgICBEQVJLOiAnREFSSycsXG4gICAgTElHSFQ6ICdMSUdIVCcsXG4gICAgRk9MTE9XX1NZU1RFTTogJ0ZPTExPV19TWVNURU0nXG59O1xuY29uc3QgUmVuZGVyaW5nVHlwZSA9IHtcbiAgICBWRUNUT1I6ICdWRUNUT1InLFxuICAgIFJBU1RFUjogJ1JBU1RFUicsXG4gICAgVU5JTklUSUFMSVpFRDogJ1VOSU5JVElBTElaRUQnXG59O1xuY29uc3QgTWFwID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaWQsIGNsYXNzTmFtZSwgc3R5bGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gICAgY29uc3QgbG9hZGluZ1N0YXR1cyA9IHVzZUFwaUxvYWRpbmdTdGF0dXMoKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8TWFwPiBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiA8QXBpUHJvdmlkZXI+IGNvbXBvbmVudC4nKTtcbiAgICB9XG4gICAgY29uc3QgW21hcCwgbWFwUmVmLCBjYW1lcmFTdGF0ZVJlZl0gPSB1c2VNYXBJbnN0YW5jZShwcm9wcywgY29udGV4dCk7XG4gICAgdXNlTWFwQ2FtZXJhUGFyYW1zKG1hcCwgY2FtZXJhU3RhdGVSZWYsIHByb3BzKTtcbiAgICB1c2VNYXBFdmVudHMobWFwLCBwcm9wcyk7XG4gICAgdXNlTWFwT3B0aW9ucyhtYXAsIHByb3BzKTtcbiAgICBjb25zdCBpc0RlY2tHbENvbnRyb2xsZWQgPSB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcyk7XG4gICAgY29uc3QgaXNDb250cm9sbGVkRXh0ZXJuYWxseSA9ICEhcHJvcHMuY29udHJvbGxlZDtcbiAgICAvLyBkaXNhYmxlIGludGVyYWN0aW9ucyB3aXRoIHRoZSBtYXAgZm9yIGV4dGVybmFsbHkgY29udHJvbGxlZCBtYXBzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGZpeG1lOiB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZWxvbmcgaGVyZSAoYW5kIGl0J3MgbW9zdGx5IHRoZXJlIGZvciBjb252ZW5pZW5jZSBhbnl3YXkpLlxuICAgICAgICAvLyAgIFRoZSByZWFzb25pbmcgaXMgdGhhdCBhIGRlY2suZ2wgY2FudmFzIHdpbGwgYmUgcHV0IG9uIHRvcCBvZiB0aGUgbWFwLCByZW5kZXJpbmdcbiAgICAgICAgLy8gICBhbnkgZGVmYXVsdCBtYXAgY29udHJvbHMgcHJldHR5IG11Y2ggdXNlbGVzc1xuICAgICAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkKSB7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyh7IGRpc2FibGVEZWZhdWx0VUk6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzYWJsZSBhbGwgY29udHJvbC1pbnB1dHMgd2hlbiB0aGUgbWFwIGlzIGNvbnRyb2xsZWQgZXh0ZXJuYWxseVxuICAgICAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkIHx8IGlzQ29udHJvbGxlZEV4dGVybmFsbHkpIHtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlSGFuZGxpbmc6ICdub25lJyxcbiAgICAgICAgICAgICAgICBrZXlib2FyZFNob3J0Y3V0czogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZUhhbmRsaW5nOiBwcm9wcy5nZXN0dXJlSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG1hcCxcbiAgICAgICAgaXNEZWNrR2xDb250cm9sbGVkLFxuICAgICAgICBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5LFxuICAgICAgICBwcm9wcy5nZXN0dXJlSGFuZGxpbmcsXG4gICAgICAgIHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXG4gICAgXSk7XG4gICAgLy8gc2V0dXAgYSBzdGFibGUgY2FtZXJhT3B0aW9ucyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBkZXBlbmRlbmN5XG4gICAgY29uc3QgY2VudGVyID0gcHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKHByb3BzLmNlbnRlcikgOiBudWxsO1xuICAgIGxldCBsYXQgPSBudWxsO1xuICAgIGxldCBsbmcgPSBudWxsO1xuICAgIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgICAgICBsYXQgPSBjZW50ZXIubGF0O1xuICAgICAgICBsbmcgPSBjZW50ZXIubG5nO1xuICAgIH1cbiAgICBjb25zdCBjYW1lcmFPcHRpb25zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogbGF0ICE9PSBudWxsICYmIGxhdCAhPT0gdm9pZCAwID8gbGF0IDogMCwgbG5nOiBsbmcgIT09IG51bGwgJiYgbG5nICE9PSB2b2lkIDAgPyBsbmcgOiAwIH0sXG4gICAgICAgICAgICB6b29tOiAoX2EgPSBwcm9wcy56b29tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgICAgICAgaGVhZGluZzogKF9iID0gcHJvcHMuaGVhZGluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCxcbiAgICAgICAgICAgIHRpbHQ6IChfYyA9IHByb3BzLnRpbHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDBcbiAgICAgICAgfTtcbiAgICB9LCBbbGF0LCBsbmcsIHByb3BzLnpvb20sIHByb3BzLmhlYWRpbmcsIHByb3BzLnRpbHRdKTtcbiAgICAvLyBleHRlcm5hbGx5IGNvbnRyb2xsZWQgbW9kZTogcmVqZWN0IGFsbCBjYW1lcmEgY2hhbmdlcyB0aGF0IGRvbid0IGNvcnJlc3BvbmQgdG8gY2hhbmdlcyBpbiBwcm9wc1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwIHx8ICFpc0NvbnRyb2xsZWRFeHRlcm5hbGx5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYXAubW92ZUNhbWVyYShjYW1lcmFPcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBtYXAuYWRkTGlzdGVuZXIoJ2JvdW5kc19jaGFuZ2VkJywgKCkgPT4ge1xuICAgICAgICAgICAgbWFwLm1vdmVDYW1lcmEoY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW21hcCwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSwgY2FtZXJhT3B0aW9uc10pO1xuICAgIGNvbnN0IGNvbWJpbmVkU3R5bGUgPSB1c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBcbiAgICAgICAgLy8gd2hlbiB1c2luZyBkZWNrZ2wsIHRoZSBtYXAgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIGJhY2tcbiAgICAgICAgekluZGV4OiBpc0RlY2tHbENvbnRyb2xsZWQgPyAtMSA6IDAgfSwgc3R5bGUpKSwgW3N0eWxlLCBpc0RlY2tHbENvbnRyb2xsZWRdKTtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7IG1hcCB9KSwgW21hcF0pO1xuICAgIGlmIChsb2FkaW5nU3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRSkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uOiAncmVsYXRpdmUnIH0sIChjbGFzc05hbWUgPyB7fSA6IGNvbWJpbmVkU3R5bGUpKSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0aEZhaWx1cmVNZXNzYWdlLCBudWxsKSkpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogbWFwUmVmLCBcImRhdGEtdGVzdGlkXCI6ICdtYXAnLCBzdHlsZTogY2xhc3NOYW1lID8gdW5kZWZpbmVkIDogY29tYmluZWRTdHlsZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgKGlkID8geyBpZCB9IDoge30pKSwgbWFwID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoR29vZ2xlTWFwc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCBjaGlsZHJlbikpIDogbnVsbCkpO1xufTtcbi8vIFRoZSBkZWNrR0xWaWV3UHJvcHMgZmxhZyBoZXJlIGluZGljYXRlcyB0byBkZWNrLmdsIHRoYXQgdGhlIE1hcCBjb21wb25lbnQgaXNcbi8vIGFibGUgdG8gaGFuZGxlIHZpZXdQcm9wcyBmcm9tIGRlY2suZ2wgd2hlbiBkZWNrLmdsIGlzIHVzZWQgdG8gY29udHJvbCB0aGUgbWFwLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbk1hcC5kZWNrR0xWaWV3UHJvcHMgPSB0cnVlO1xuXG5jb25zdCBzaG93bk1lc3NhZ2VzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gbG9nRXJyb3JPbmNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICBpZiAoIXNob3duTWVzc2FnZXMuaGFzKGtleSkpIHtcbiAgICAgICAgc2hvd25NZXNzYWdlcy5hZGQoa2V5KTtcbiAgICAgICAgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0cmlldmVzIGEgbWFwLWluc3RhbmNlIGZyb20gdGhlIGNvbnRleHQuIFRoaXMgaXMgZWl0aGVyIGFuIGluc3RhbmNlXG4gKiBpZGVudGlmaWVkIGJ5IGlkIG9yIHRoZSBwYXJlbnQgbWFwIGluc3RhbmNlIGlmIG5vIGlkIGlzIHNwZWNpZmllZC5cbiAqIFJldHVybnMgbnVsbCBpZiBuZWl0aGVyIGNhbiBiZSBmb3VuZC5cbiAqL1xuY29uc3QgdXNlTWFwID0gKGlkID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgICBjb25zdCB7IG1hcCB9ID0gdXNlQ29udGV4dChHb29nbGVNYXBzQ29udGV4dCkgfHwge307XG4gICAgaWYgKGN0eCA9PT0gbnVsbCkge1xuICAgICAgICBsb2dFcnJvck9uY2UoJ3VzZU1hcCgpOiBmYWlsZWQgdG8gcmV0cmlldmUgQVBJUHJvdmlkZXJDb250ZXh0LiAnICtcbiAgICAgICAgICAgICdNYWtlIHN1cmUgdGhhdCB0aGUgPEFQSVByb3ZpZGVyPiBjb21wb25lbnQgZXhpc3RzIGFuZCB0aGF0IHRoZSAnICtcbiAgICAgICAgICAgICdjb21wb25lbnQgeW91IGFyZSBjYWxsaW5nIGB1c2VNYXAoKWAgZnJvbSBpcyBhIHNpYmxpbmcgb2YgdGhlICcgK1xuICAgICAgICAgICAgJzxBUElQcm92aWRlcj4uJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IG1hcEluc3RhbmNlcyB9ID0gY3R4O1xuICAgIC8vIGlmIGFuIGlkIGlzIHNwZWNpZmllZCwgdGhlIGNvcnJlc3BvbmRpbmcgbWFwIG9yIG51bGwgaXMgcmV0dXJuZWRcbiAgICBpZiAoaWQgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBtYXBJbnN0YW5jZXNbaWRdIHx8IG51bGw7XG4gICAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIGNsb3Nlc3QgYW5jZXN0b3JcbiAgICBpZiAobWFwKVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIC8vIGZpbmFsbHksIHJldHVybiB0aGUgZGVmYXVsdCBtYXAgaW5zdGFuY2VcbiAgICByZXR1cm4gbWFwSW5zdGFuY2VzWydkZWZhdWx0J10gfHwgbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHVzZU1hcHNMaWJyYXJ5KG5hbWUpIHtcbiAgICBjb25zdCBhcGlJc0xvYWRlZCA9IHVzZUFwaUlzTG9hZGVkKCk7XG4gICAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghYXBpSXNMb2FkZWQgfHwgIWN0eClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVHJpZ2dlciBsb2FkaW5nIHRoZSBsaWJyYXJpZXMgdmlhIG91ciBwcm94eS1tZXRob2QuXG4gICAgICAgIC8vIFRoZSByZXR1cm5lZCBwcm9taXNlIGlzIGlnbm9yZWQsIHNpbmNlIGltcG9ydExpYnJhcnkgd2lsbCB1cGRhdGUgbG9hZGVkTGlicmFyaWVzXG4gICAgICAgIC8vIGxpc3QgaW4gdGhlIGNvbnRleHQsIHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICAgIHZvaWQgY3R4LmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgfSwgW2FwaUlzTG9hZGVkLCBjdHgsIG5hbWVdKTtcbiAgICByZXR1cm4gKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5sb2FkZWRMaWJyYXJpZXNbbmFtZV0pIHx8IG51bGw7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogSW50ZXJuYWxseSB1c2VkIHRvIGJpbmQgZXZlbnRzIHRvIE1hcHMgSmF2YVNjcmlwdCBBUEkgb2JqZWN0cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBzRXZlbnRMaXN0ZW5lcih0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIW5hbWUgfHwgIWNhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW3RhcmdldCwgbmFtZSwgY2FsbGJhY2tdKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gY29weSB2YWx1ZXMgZnJvbSBwcm9wcyBpbnRvIEFQSS1PYmplY3RzXG4gKiB3aGVuZXZlciB0aGV5IGNoYW5nZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICB1c2VQcm9wQmluZGluZyhtYXJrZXIsICdwb3NpdGlvbicsIHBvc2l0aW9uKTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlUHJvcEJpbmRpbmcob2JqZWN0LCBwcm9wLCB2YWx1ZSkge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvaW1tdXRhYmlsaXR5XG4gICAgICAgIG9iamVjdFtwcm9wXSA9IHZhbHVlO1xuICAgIH0sIFtvYmplY3QsIHByb3AsIHZhbHVlXSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogSW50ZXJuYWxseSB1c2VkIHRvIGJpbmQgZXZlbnRzIHRvIERPTSBub2Rlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEb21FdmVudExpc3RlbmVyKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhbmFtZSB8fCAhY2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LCBbdGFyZ2V0LCBuYW1lLCBjYWxsYmFja10pO1xufVxuXG4vLyBHbG9iYWwgc3R5bGUgbWFuYWdlciB0byB0cmFjayByZW5kZXJlZCBzdHlsZXMgYW5kIGF2b2lkIGR1cGxpY2F0ZXNcbmNsYXNzIEdsb2JhbFN0eWxlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRTdHlsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0U3R5bGVFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmdtLWFuY2hvci1zdHlsZXMnLCAnJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZUVsZW1lbnQ7XG4gICAgfVxuICAgIGFkZEFkdmFuY2VkTWFya2VyUG9pbnRlckV2ZW50c092ZXJ3cml0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRTdHlsZXMuaGFzKCdtYXJrZXItcG9pbnRlci1ldmVudHMnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IHRoaXMuZ2V0U3R5bGVFbGVtZW50KCk7XG4gICAgICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCArPSBgXG4gICAgICBnbXAtYWR2YW5jZWQtbWFya2VyW2RhdGEtb3JpZ2luPSdyZ20nXSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgYDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcy5hZGQoJ21hcmtlci1wb2ludGVyLWV2ZW50cycpO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZ2xvYmFsU3R5bGVNYW5hZ2VyID0gbmV3IEdsb2JhbFN0eWxlTWFuYWdlcigpO1xuXG5mdW5jdGlvbiBpc1ZlcnNpb25HcmVhdGVyRXF1YWwobWFqb3IsIG1pbm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghKChfYSA9IGdvb2dsZSA9PT0gbnVsbCB8fCBnb29nbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdvb2dsZS5tYXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmVyc2lvbikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdmVyc2lvbiA9IGdvb2dsZS5tYXBzLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICBjb25zdCBjdXJyZW50TWFqb3IgPSBwYXJzZUludCh2ZXJzaW9uWzBdLCAxMCk7XG4gICAgY29uc3QgY3VycmVudE1pbm9yID0gcGFyc2VJbnQodmVyc2lvblsxXSwgMTApO1xuICAgIHJldHVybiAoY3VycmVudE1ham9yID4gbWFqb3IgfHwgKGN1cnJlbnRNYWpvciA9PT0gbWFqb3IgJiYgY3VycmVudE1pbm9yID49IG1pbm9yKSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2ltbXV0YWJpbGl0eSAqL1xuLy8gVGhlIGByZWFjdC1ob29rcy9pbW11dGFiaWxpdHlgIHJ1bGUgaXMgZGlzYWJsZWQgaW4gdGhpcyBmaWxlIGJlY2F1c2UgdGhlXG4vLyBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50IG9iamVjdCBpcyBkZXNpZ25lZCB0byBiZSBtdXRhdGVkXG4vLyBkaXJlY3RseS4gVGhpcyBpcyBhIGNvbW1vbiBwYXR0ZXJuIHdoZW4gd29ya2luZyB3aXRoIGltcGVyYXRpdmUgQVBJcyBsaWtlXG4vLyB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkuIFdoaWxlIHRoaXMgZ29lcyBhZ2FpbnN0IHRoZSBwcmluY2lwbGVzIG9mXG4vLyBpbW11dGFibGUgc3RhdGUgaW4gUmVhY3QsIGl0IGlzIGEgbmVjZXNzYXJ5IGV2aWwgdG8gaW50ZWdyYXRlIHdpdGggdGhlXG4vLyBHb29nbGUgTWFwcyBBUEkuIFRoZSBtdXRhdGlvbnMgYXJlIGNhcmVmdWxseSBtYW5hZ2VkIHdpdGhpbiB0aGUgYHVzZUVmZmVjdGBcbi8vIGhvb2tzIHRvIGVuc3VyZSB0aGF0IHRoZXkgb25seSBoYXBwZW4gd2hlbiB0aGUgcHJvcHMgY2hhbmdlLlxuLyoqXG4gKiBDb3B5IG9mIHRoZSBgZ29vZ2xlLm1hcHMuQ29sbGlzaW9uQmVoYXZpb3JgIGNvbnN0YW50cy5cbiAqIFRoZXkgaGF2ZSB0byBiZSBkdXBsaWNhdGVkIGhlcmUgc2luY2Ugd2UgY2FuJ3Qgd2FpdCBmb3IgdGhlIG1hcHMgQVBJIHRvIGxvYWQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbS5cbiAqL1xuY29uc3QgQ29sbGlzaW9uQmVoYXZpb3IgPSB7XG4gICAgUkVRVUlSRUQ6ICdSRVFVSVJFRCcsXG4gICAgUkVRVUlSRURfQU5EX0hJREVTX09QVElPTkFMOiAnUkVRVUlSRURfQU5EX0hJREVTX09QVElPTkFMJyxcbiAgICBPUFRJT05BTF9BTkRfSElERVNfTE9XRVJfUFJJT1JJVFk6ICdPUFRJT05BTF9BTkRfSElERVNfTE9XRVJfUFJJT1JJVFknXG59O1xuY29uc3QgQWR2YW5jZWRNYXJrZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8vIFt4UG9zaXRpb24sIHlQb3NpdGlvbl0gd2hlbiB0aGUgdG9wIGxlZnQgY29ybmVyIGlzIFswLCAwXVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2luZyBgYW5jaG9yUG9zaXRpb25gIGlzIGRlcHJlY2F0ZWQuXG4gKiAgIFVzZSBgYW5jaG9yTGVmdGAgYW5kIGBhbmNob3JUb3BgIGluc3RlYWQuXG4gKi9cbmNvbnN0IEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnQgPSB7XG4gICAgVE9QX0xFRlQ6IFsnMCUnLCAnMCUnXSxcbiAgICBUT1BfQ0VOVEVSOiBbJzUwJScsICcwJSddLFxuICAgIFRPUDogWyc1MCUnLCAnMCUnXSxcbiAgICBUT1BfUklHSFQ6IFsnMTAwJScsICcwJSddLFxuICAgIExFRlRfQ0VOVEVSOiBbJzAlJywgJzUwJSddLFxuICAgIExFRlRfVE9QOiBbJzAlJywgJzAlJ10sXG4gICAgTEVGVDogWycwJScsICc1MCUnXSxcbiAgICBMRUZUX0JPVFRPTTogWycwJScsICcxMDAlJ10sXG4gICAgUklHSFRfVE9QOiBbJzEwMCUnLCAnMCUnXSxcbiAgICBSSUdIVDogWycxMDAlJywgJzUwJSddLFxuICAgIFJJR0hUX0NFTlRFUjogWycxMDAlJywgJzUwJSddLFxuICAgIFJJR0hUX0JPVFRPTTogWycxMDAlJywgJzEwMCUnXSxcbiAgICBCT1RUT01fTEVGVDogWycwJScsICcxMDAlJ10sXG4gICAgQk9UVE9NX0NFTlRFUjogWyc1MCUnLCAnMTAwJSddLFxuICAgIEJPVFRPTTogWyc1MCUnLCAnMTAwJSddLFxuICAgIEJPVFRPTV9SSUdIVDogWycxMDAlJywgJzEwMCUnXSxcbiAgICBDRU5URVI6IFsnNTAlJywgJzUwJSddXG59O1xuY29uc3QgQWR2YW5jZWRNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgc3R5bGUsIGNsYXNzTmFtZSwgYW5jaG9yUG9pbnQgfSA9IHByb3BzO1xuICAgIGNvbnN0IFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdID0gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpO1xuICAgIGNvbnN0IGFkdmFuY2VkTWFya2VyQ29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAobWFya2VyID8geyBtYXJrZXIgfSA6IG51bGwpLCBbbWFya2VyXSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IG1hcmtlciwgW21hcmtlcl0pO1xuICAgIGlmICghY29udGVudENvbnRhaW5lcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEFkdmFuY2VkTWFya2VyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogYWR2YW5jZWRNYXJrZXJDb250ZXh0VmFsdWUgfSwgY3JlYXRlUG9ydGFsKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2VyQ29udGVudCwgeyBhbmNob3JQb2ludDogYW5jaG9yUG9pbnQsIHN0eWxlczogc3R5bGUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSwgY29udGVudENvbnRhaW5lcikpKTtcbn0pO1xuQWR2YW5jZWRNYXJrZXIuZGlzcGxheU5hbWUgPSAnQWR2YW5jZWRNYXJrZXInO1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXJSZWYoKSB7XG4gICAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKG0pID0+IHtcbiAgICAgICAgc2V0TWFya2VyKG0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gW3JlZkNhbGxiYWNrLCBtYXJrZXJdO1xufVxuZnVuY3Rpb24gaXNBZHZhbmNlZE1hcmtlcihtYXJrZXIpIHtcbiAgICByZXR1cm4gKG1hcmtlci5jb250ZW50ICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuY29uc3QgTWFya2VyQ29udGVudCA9ICh7IGNoaWxkcmVuLCBzdHlsZXMsIGNsYXNzTmFtZSB9KSA9PiB7XG4gICAgLyogQWR2YW5jZWRNYXJrZXIgZGl2IHRoYXQgdXNlciBjYW4gZ2l2ZSBzdHlsZXMgYW5kIGNsYXNzZXMgKi9cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlcyB9LCBjaGlsZHJlbikpO1xufTtcbmZ1bmN0aW9uIHVzZUFkdmFuY2VkTWFya2VyKHByb3BzKSB7XG4gICAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtjb250ZW50Q29udGFpbmVyLCBzZXRDb250ZW50Q29udGFpbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICAgIGNvbnN0IG1hcmtlckxpYnJhcnkgPSB1c2VNYXBzTGlicmFyeSgnbWFya2VyJyk7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgb25DbGljaywgY2xhc3NOYW1lLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgb25EcmFnLCBvbkRyYWdTdGFydCwgb25EcmFnRW5kLCBjb2xsaXNpb25CZWhhdmlvciwgY2xpY2thYmxlLCBkcmFnZ2FibGUsIHBvc2l0aW9uLCB0aXRsZSwgekluZGV4LCBhbmNob3JQb2ludCwgYW5jaG9yTGVmdCwgYW5jaG9yVG9wIH0gPSBwcm9wcztcbiAgICBjb25zdCBudW1DaGlsZHJlbiA9IENoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgICAvLyBjcmVhdGUgYW4gQWR2YW5jZWRNYXJrZXJFbGVtZW50IGluc3RhbmNlIGFuZCBhZGQgaXQgdG8gdGhlIG1hcCBvbmNlIGF2YWlsYWJsZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwIHx8ICFtYXJrZXJMaWJyYXJ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgbWFya2VyTGlicmFyeS5BZHZhbmNlZE1hcmtlckVsZW1lbnQoKTtcbiAgICAgICAgbmV3TWFya2VyLm1hcCA9IG1hcDtcbiAgICAgICAgc2V0TWFya2VyKG5ld01hcmtlcik7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgY29udGFpbmVyIGZvciBtYXJrZXIgY29udGVudCBpZiB0aGVyZSBhcmUgY2hpbGRyZW5cbiAgICAgICAgbGV0IGNvbnRlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKG51bUNoaWxkcmVuID4gMCkge1xuICAgICAgICAgICAgY29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5ld01hcmtlci5jb250ZW50ID0gY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICBzZXRDb250ZW50Q29udGFpbmVyKGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbmV3TWFya2VyLm1hcCA9IG51bGw7XG4gICAgICAgICAgICBjb250ZW50RWxlbWVudCA9PT0gbnVsbCB8fCBjb250ZW50RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICBzZXRNYXJrZXIobnVsbCk7XG4gICAgICAgICAgICBzZXRDb250ZW50Q29udGFpbmVyKG51bGwpO1xuICAgICAgICB9O1xuICAgIH0sIFttYXAsIG1hcmtlckxpYnJhcnksIG51bUNoaWxkcmVuXSk7XG4gICAgLy8gV2hlbiBubyBjaGlsZHJlbiBhcmUgcHJlc2VudCB3ZSBkb24ndCBoYXZlIG91ciBvd24gd3JhcHBlciBkaXZcbiAgICAvLyB3aGljaCB1c3VhbGx5IGdldHMgdGhlIHVzZXIgcHJvdmlkZWQgY2xhc3NOYW1lLiBJbiB0aGlzIGNhc2VcbiAgICAvLyB3ZSBzZXQgdGhlIGNsYXNzTmFtZSBkaXJlY3RseSBvbiB0aGUgbWFya2VyLmNvbnRlbnQgZWxlbWVudCB0aGF0IGNvbWVzXG4gICAgLy8gd2l0aCB0aGUgQWR2YW5jZWRNYXJrZXIuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCEobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmNvbnRlbnQpIHx8ICFpc0VsZW1lbnROb2RlKG1hcmtlci5jb250ZW50KSB8fCBudW1DaGlsZHJlbiA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hcmtlci5jb250ZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSAhPT0gbnVsbCAmJiBjbGFzc05hbWUgIT09IHZvaWQgMCA/IGNsYXNzTmFtZSA6ICcnO1xuICAgIH0sIFttYXJrZXIsIGNsYXNzTmFtZSwgbnVtQ2hpbGRyZW5dKTtcbiAgICB1c2VBZHZhbmNlZE1hcmtlckFuY2hvcmluZyhtYXJrZXIsIGFuY2hvclBvaW50LCBhbmNob3JMZWZ0LCBhbmNob3JUb3AsIG51bUNoaWxkcmVuID4gMCk7XG4gICAgLy8gY29weSBvdGhlciBwcm9wc1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3RpdGxlJywgdGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09IHZvaWQgMCA/IHRpdGxlIDogJycpO1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3pJbmRleCcsIHpJbmRleCk7XG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAnY29sbGlzaW9uQmVoYXZpb3InLCBjb2xsaXNpb25CZWhhdmlvcik7XG4gICAgLy8gc2V0IGdtcERyYWdnYWJsZSBmcm9tIHByb3BzICh3aGVuIHVuc3BlY2lmaWVkLCBpdCdzIHRydWUgaWYgYW55IGRyYWctZXZlbnRcbiAgICAvLyBjYWxsYmFja3MgYXJlIHNwZWNpZmllZClcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGRyYWdnYWJsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbWFya2VyLmdtcERyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICAgICAgZWxzZSBpZiAob25EcmFnIHx8IG9uRHJhZ1N0YXJ0IHx8IG9uRHJhZ0VuZClcbiAgICAgICAgICAgIG1hcmtlci5nbXBEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXJrZXIuZ21wRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgfSwgW21hcmtlciwgZHJhZ2dhYmxlLCBvbkRyYWcsIG9uRHJhZ0VuZCwgb25EcmFnU3RhcnRdKTtcbiAgICAvLyBzZXQgZ21wQ2xpY2thYmxlIGZyb20gcHJvcHMgKHdoZW4gdW5zcGVjaWZpZWQsIGl0J3MgdHJ1ZSBpZiB0aGUgb25DbGljayBvciBvbmUgb2ZcbiAgICAvLyB0aGUgaG92ZXIgZXZlbnRzIGNhbGxiYWNrcyBhcmUgc3BlY2lmaWVkKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBnbXBDbGlja2FibGUgPSBjbGlja2FibGUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgQm9vbGVhbihvbkNsaWNrKSB8fFxuICAgICAgICAgICAgQm9vbGVhbihvbk1vdXNlRW50ZXIpIHx8XG4gICAgICAgICAgICBCb29sZWFuKG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIC8vIGdtcENsaWNrYWJsZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBiZXRhIHZlcnNpb24gb2YgdGhlXG4gICAgICAgIC8vIG1hcHMgYXBpIChhcyBvZiAyMDI0LTEwLTEwKVxuICAgICAgICBtYXJrZXIuZ21wQ2xpY2thYmxlID0gZ21wQ2xpY2thYmxlO1xuICAgICAgICAvLyBlbmFibGUgcG9pbnRlciBldmVudHMgZm9yIHRoZSBtYXJrZXJzIHdpdGggY3VzdG9tIGNvbnRlbnRcbiAgICAgICAgaWYgKGdtcENsaWNrYWJsZSAmJiAobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmNvbnRlbnQpICYmIGlzRWxlbWVudE5vZGUobWFya2VyLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBtYXJrZXIuY29udGVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFttYXJrZXIsIGNsaWNrYWJsZSwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmVdKTtcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2RyYWcnLCBvbkRyYWcpO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KTtcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICB1c2VEb21FdmVudExpc3RlbmVyKG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5lbGVtZW50LCAnbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgdXNlRG9tRXZlbnRMaXN0ZW5lcihtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuZWxlbWVudCwgJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgIHJldHVybiBbbWFya2VyLCBjb250ZW50Q29udGFpbmVyXTtcbn1cbmZ1bmN0aW9uIHVzZUFkdmFuY2VkTWFya2VyQW5jaG9yaW5nKG1hcmtlciwgYW5jaG9yUG9pbnQsIGFuY2hvckxlZnQsIGFuY2hvclRvcCwgaGFzQ2hpbGRyZW4pIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcmtlciB8fCAhaGFzQ2hpbGRyZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRoZSBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3Agb3B0aW9ucyBhcmUgYXZhaWxhYmxlIHNpbmNlIHZlcnNpb24gMy42Mi45Y1xuICAgICAgICAvLyBXaXRoIHRoZSByZWxlYXNlIG9mIDMuNjUgKH5NYXkgMjAyNikgdGhlcmUgd2lsbCBubyBsb25nZXIgYmUgYSB2ZXJzaW9uXG4gICAgICAgIC8vIHRoYXQgZG9lc24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBjb25zdCBhbmNob3JPcHRpb25zU3VwcG9ydGVkID0gaXNWZXJzaW9uR3JlYXRlckVxdWFsKDMsIDYyKTtcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBtYXJrZXIuY29udGVudDtcbiAgICAgICAgaWYgKCFjb250ZW50RWxlbWVudCB8fCAhaXNFbGVtZW50Tm9kZShjb250ZW50RWxlbWVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhbmNob3JMZWZ0ICE9PSB1bmRlZmluZWQgfHwgYW5jaG9yVG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghYW5jaG9yT3B0aW9uc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQWR2YW5jZWRNYXJrZXI6IFRoZSBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3AgcHJvcHMgYXJlIG9ubHkgc3VwcG9ydGVkICcgK1xuICAgICAgICAgICAgICAgICAgICAnaW4gR29vZ2xlIE1hcHMgQVBJIHZlcnNpb24gMy42MiBhbmQgYWJvdmUuICcgK1xuICAgICAgICAgICAgICAgICAgICBgVGhlIGN1cnJlbnQgdmVyc2lvbiBpcyAke2dvb2dsZS5tYXBzLnZlcnNpb259LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya2VyLmFuY2hvckxlZnQgPSBhbmNob3JMZWZ0O1xuICAgICAgICAgICAgbWFya2VyLmFuY2hvclRvcCA9IGFuY2hvclRvcDtcbiAgICAgICAgICAgIC8vIHdoZW4gYW5jaG9yTGVmdCBhbmQvb3IgYW5jaG9yVG9wIGFyZSBzZXQsIHdlJ2xsIGlnbm9yZSB0aGUgYW5jaG9yUG9pbnRcbiAgICAgICAgICAgIGlmIChhbmNob3JQb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBZHZhbmNlZE1hcmtlcjogdGhlIGFuY2hvclBvaW50IHByb3AgaXMgaWdub3JlZCB3aGVuIGFuY2hvckxlZnQgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbmQvb3IgYW5jaG9yVG9wIGFyZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvclBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZCBjb25zb2xlLndhcm4gaW4gYSBmdXR1cmUgdmVyc2lvbiB0byBpbmZvcm0gYWJvdXQgZGVwcmVjYXRpb25cbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGFuY2hvclBvaW50ICE9PSBudWxsICYmIGFuY2hvclBvaW50ICE9PSB2b2lkIDAgPyBhbmNob3JQb2ludCA6IEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnRbJ0JPVFRPTSddO1xuICAgICAgICAgICAgLy8gTk9URTogc2luY2UgeCBhbmQgeSBjYW4gYmUgYW55IHZhbGlkIENTUyBsZW5ndGgtcGVyY2VudGFnZVxuICAgICAgICAgICAgLy8gICB2YWx1ZSwgd2UgbmVlZCB0byB1c2UgY2FsYygpIHRvIG5lZ2F0ZSB0aGVtLlxuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWCA9IGBjYWxjKC0xICogJHt4fSlgO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IGBjYWxjKC0xICogJHt5fSlgO1xuICAgICAgICAgICAgaWYgKGFuY2hvck9wdGlvbnNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnQgYW5jaG9yUG9pbnQgdXNpbmcgdGhlIG5ldyBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3Agb3B0aW9uc1xuICAgICAgICAgICAgICAgIG1hcmtlci5hbmNob3JMZWZ0ID0gdHJhbnNsYXRlWDtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYW5jaG9yVG9wID0gdHJhbnNsYXRlWTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0cmFuc2Zvcm0gZnJvbSBsZWdhY3kgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcInRyYW5zbGF0ZSg1MCUsIDEwMCUpXCIgY291bnRlcnMgYW5kIHJlc2V0cyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIGFuY2hvcmluZyBvZiB0aGUgYWR2YW5jZWQgbWFya2VyIGVsZW1lbnQgZnJvbSB0aGUgYXBpXG4gICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSg1MCUsIDEwMCUpIHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVh9LCAke3RyYW5zbGF0ZVl9KWA7XG4gICAgICAgICAgICAgICAgLy8gZGF0YS1vcmlnaW4gaXMgbmVlZGVkIHRvIGlkZW50aWZ5IHRoZSBjdXN0b20gbWFya2VyIGNvbnRlbnQgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gSW5mb1dpbmRvdyBjb21wb25lbnQgYXMgd2VsbCBhcyBpbiB0aGUgZ2xvYmFsIENTUyB1c2VkIHRvIGRpc2FibGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgcG9pbnRlciBldmVudCB3aGVuIGFuY2hvciBwb2ludHMgYXJlIHVzZWQgaW4gb2xkZXIgR29vZ2xlIE1hcHNcbiAgICAgICAgICAgICAgICAvLyB2ZXJzaW9ucy5cbiAgICAgICAgICAgICAgICBtYXJrZXIuZGF0YXNldC5vcmlnaW4gPSAncmdtJztcbiAgICAgICAgICAgICAgICBnbG9iYWxTdHlsZU1hbmFnZXIuYWRkQWR2YW5jZWRNYXJrZXJQb2ludGVyRXZlbnRzT3ZlcndyaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbWFya2VyLCBhbmNob3JQb2ludCwgYW5jaG9yTGVmdCwgYW5jaG9yVG9wLCBoYXNDaGlsZHJlbl0pO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhlbGVtZW50LCBzdHlsZXMsIHByZXZTdHlsZXMpIHtcbiAgICBpZiAoc3R5bGVzICE9IG51bGwgJiYgdHlwZW9mIHN0eWxlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgK1xuICAgICAgICAgICAgXCJub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gXCIgK1xuICAgICAgICAgICAgJ3VzaW5nIEpTWC4nKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAvLyB3aXRob3V0IGBwcmV2U3R5bGVzYCwganVzdCBzZXQgYWxsIHZhbHVlc1xuICAgIGlmIChwcmV2U3R5bGVzID09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0eWxlcyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB1bnNldCBhbGwgc3R5bGVzIGluIGBwcmV2U3R5bGVzYCB0aGF0IGFyZW4ndCBpbiBgc3R5bGVzYFxuICAgIGZvciAoY29uc3Qgc3R5bGVOYW1lIGluIHByZXZTdHlsZXMpIHtcbiAgICAgICAgaWYgKHByZXZTdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJlxuICAgICAgICAgICAgKHN0eWxlcyA9PSBudWxsIHx8ICFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHN0eWxlXG4gICAgICAgICAgICBjb25zdCBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5jc3NGbG9hdCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmx5IGFzc2lnbiB2YWx1ZXMgZnJvbSBgc3R5bGVzYCB0aGF0IGFyZSBkaWZmZXJlbnQgZnJvbSBgcHJldlN0eWxlc2BcbiAgICBpZiAoc3R5bGVzID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICBwcmV2U3R5bGVzW3N0eWxlTmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAvLyBmYWxzeSB2YWx1ZXMgd2lsbCB1bnNldCB0aGUgc3R5bGUgcHJvcGVydHlcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5jc3NGbG9hdCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjdXN0b20gcHJvcGVydGllcyBjYW4ndCBiZSBkaXJlY3RseSBhc3NpZ25lZFxuICAgIGVsc2UgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBudW1lcmljIHZhbHVlcyBhcmUgdHJlYXRlZCBhcyAncHgnIHVubGVzcyB0aGUgc3R5bGUgcHJvcGVydHkgZXhwZWN0cyB1bml0bGVzcyBudW1iZXJzXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSAhPT0gMCAmJlxuICAgICAgICAhaXNVbml0bGVzc051bWJlcihzdHlsZU5hbWUpKSB7XG4gICAgICAgIGVsZW1lbnRTdHlsZVtzdHlsZU5hbWVdID0gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICAgIH1cbiAgICAvLyBldmVyeXRoaW5nIGVsc2UgY2FuIGp1c3QgYmUgYXNzaWduZWRcbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGVbc3R5bGVOYW1lXSA9ICgnJyArIHZhbHVlKS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG5jb25zdCB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFtcbiAgICAnYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLFxuICAgICdhc3BlY3RSYXRpbycsXG4gICAgJ2JvcmRlckltYWdlT3V0c2V0JyxcbiAgICAnYm9yZGVySW1hZ2VTbGljZScsXG4gICAgJ2JvcmRlckltYWdlV2lkdGgnLFxuICAgICdib3hGbGV4JyxcbiAgICAnYm94RmxleEdyb3VwJyxcbiAgICAnYm94T3JkaW5hbEdyb3VwJyxcbiAgICAnY29sdW1uQ291bnQnLFxuICAgICdjb2x1bW5zJyxcbiAgICAnZmxleCcsXG4gICAgJ2ZsZXhHcm93JyxcbiAgICAnZmxleFBvc2l0aXZlJyxcbiAgICAnZmxleFNocmluaycsXG4gICAgJ2ZsZXhOZWdhdGl2ZScsXG4gICAgJ2ZsZXhPcmRlcicsXG4gICAgJ2dyaWRBcmVhJyxcbiAgICAnZ3JpZFJvdycsXG4gICAgJ2dyaWRSb3dFbmQnLFxuICAgICdncmlkUm93U3BhbicsXG4gICAgJ2dyaWRSb3dTdGFydCcsXG4gICAgJ2dyaWRDb2x1bW4nLFxuICAgICdncmlkQ29sdW1uRW5kJyxcbiAgICAnZ3JpZENvbHVtblNwYW4nLFxuICAgICdncmlkQ29sdW1uU3RhcnQnLFxuICAgICdmb250V2VpZ2h0JyxcbiAgICAnbGluZUNsYW1wJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ29wYWNpdHknLFxuICAgICdvcmRlcicsXG4gICAgJ29ycGhhbnMnLFxuICAgICdzY2FsZScsXG4gICAgJ3RhYlNpemUnLFxuICAgICd3aWRvd3MnLFxuICAgICd6SW5kZXgnLFxuICAgICd6b29tJyxcbiAgICAnZmlsbE9wYWNpdHknLCAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gICAgJ2Zsb29kT3BhY2l0eScsXG4gICAgJ3N0b3BPcGFjaXR5JyxcbiAgICAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgICAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICAgJ3N0cm9rZU1pdGVybGltaXQnLFxuICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAnc3Ryb2tlV2lkdGgnXG5dKTtcbmZ1bmN0aW9uIGlzVW5pdGxlc3NOdW1iZXIobmFtZSkge1xuICAgIHJldHVybiB1bml0bGVzc051bWJlcnMuaGFzKG5hbWUpO1xufVxuXG4vKipcbiAqIENvbXBvbmVudCB0byByZW5kZXIgYW4gSW5mbyBXaW5kb3cgd2l0aCB0aGUgTWFwcyBKYXZhU2NyaXB0IEFQSVxuICovXG5jb25zdCBJbmZvV2luZG93ID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IHsgXG4gICAgLy8gY29udGVudCBvcHRpb25zXG4gICAgY2hpbGRyZW4sIGhlYWRlckNvbnRlbnQsIHN0eWxlLCBjbGFzc05hbWUsIHBpeGVsT2Zmc2V0LCBcbiAgICAvLyBvcGVuIG9wdGlvbnNcbiAgICBhbmNob3IsIHNob3VsZEZvY3VzLCBcbiAgICAvLyBldmVudHNcbiAgICBvbkNsb3NlLCBvbkNsb3NlQ2xpY2sgfSA9IHByb3BzLCBcbiAgICAvLyBvdGhlciBvcHRpb25zXG4gICAgdm9sYXRpbGVJbmZvV2luZG93T3B0aW9ucyA9IF9fcmVzdChwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJoZWFkZXJDb250ZW50XCIsIFwic3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJwaXhlbE9mZnNldFwiLCBcImFuY2hvclwiLCBcInNob3VsZEZvY3VzXCIsIFwib25DbG9zZVwiLCBcIm9uQ2xvc2VDbGlja1wiXSk7XG4gICAgLy8gIyMgY3JlYXRlIGluZm93aW5kb3cgaW5zdGFuY2Ugb25jZSB0aGUgbWFwc0xpYnJhcnkgaXMgYXZhaWxhYmxlLlxuICAgIGNvbnN0IG1hcHNMaWJyYXJ5ID0gdXNlTWFwc0xpYnJhcnkoJ21hcHMnKTtcbiAgICBjb25zdCBbaW5mb1dpbmRvdywgc2V0SW5mb1dpbmRvd10gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb250ZW50Q29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGhlYWRlckNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpbmZvV2luZG93T3B0aW9ucyA9IHVzZU1lbW9pemVkKHZvbGF0aWxlSW5mb1dpbmRvd09wdGlvbnMsIGlzRGVlcEVxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcHNMaWJyYXJ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGluZm9XaW5kb3dPcHRpb25zO1xuICAgICAgICBpZiAocGl4ZWxPZmZzZXQpIHtcbiAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaXhlbE9mZnNldFswXSwgcGl4ZWxPZmZzZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBpZiBoZWFkZXJDb250ZW50IGlzIHNwZWNpZmllZCBhcyBzdHJpbmcgd2UgY2FuIGRpcmVjdGx5IGZvcndhcmQgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UnbGwgcGFzcyB0aGUgZWxlbWVudCB0aGUgcG9ydGFsIHdpbGwgcmVuZGVyIGludG9cbiAgICAgICAgICAgIG9wdHMuaGVhZGVyQ29udGVudCA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGhlYWRlckNvbnRlbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gaGVhZGVyQ29udGVudFxuICAgICAgICAgICAgICAgICAgICA6IGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgc2hhZG93aW5nIHRoZSBzdGF0ZSB2YXJpYWJsZXMgaGVyZVxuICAgICAgICBjb25zdCBpbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3coaW5mb1dpbmRvd09wdGlvbnMpO1xuICAgICAgICBpbmZvV2luZG93LnNldENvbnRlbnQoY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICAgICAgc2V0SW5mb1dpbmRvdyhpbmZvV2luZG93KTtcbiAgICAgICAgLy8gdW5tb3VudDogcmVtb3ZlIGluZm9XaW5kb3cgYW5kIGNvbnRlbnQgZWxlbWVudHMgKG5vdGU6IGNsb3NlIGlzIGNhbGxlZCBpbiBhIGRpZmZlcmVudCBlZmZlY3QtY2xlYW51cClcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpbmZvV2luZG93LnNldENvbnRlbnQobnVsbCk7XG4gICAgICAgICAgICAoX2EgPSBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgICAgICAgIChfYiA9IGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlKCk7XG4gICAgICAgICAgICBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgc2V0SW5mb1dpbmRvdyhudWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBcbiAgICAvLyBgaW5mb1dpbmRvd09wdGlvbnNgIGFuZCBvdGhlciBwcm9wcyBhcmUgbWlzc2luZyBmcm9tIGRlcGVuZGVuY2llczpcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmUtY3JlYXRlIHRoZSBpbmZvd2luZG93IGluc3RhbmNlXG4gICAgLy8gd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG4gICAgLy8gVXBkYXRpbmcgdGhlIG9wdGlvbnMgaXMgaGFuZGxlZCBpbiB0aGUgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFttYXBzTGlicmFyeV0pO1xuICAgIC8vIC0tLS0gdXBkYXRlIGNsYXNzTmFtZSBhbmQgc3R5bGVzIGZvciBgY29udGVudENvbnRhaW5lcmBcbiAgICAvLyBwcmV2U3R5bGVSZWYgc3RvcmVzIHByZXZpb3VzbHkgYXBwbGllZCBzdHlsZSBwcm9wZXJ0aWVzLCBzbyB0aGV5IGNhbiBiZVxuICAgIC8vIHJlbW92ZWQgd2hlbiB1bnNldFxuICAgIGNvbnN0IHByZXZTdHlsZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWluZm9XaW5kb3cgfHwgIWNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LCBzdHlsZSB8fCBudWxsLCBwcmV2U3R5bGVSZWYuY3VycmVudCk7XG4gICAgICAgIHByZXZTdHlsZVJlZi5jdXJyZW50ID0gc3R5bGUgfHwgbnVsbDtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LmNsYXNzTmFtZSlcbiAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XG4gICAgfSwgW2luZm9XaW5kb3csIGNsYXNzTmFtZSwgc3R5bGVdKTtcbiAgICAvLyAtLS0tIHVwZGF0ZSBvcHRpb25zXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpbmZvV2luZG93KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgICAgIGlmICghcGl4ZWxPZmZzZXQpIHtcbiAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG5ldyBnb29nbGUubWFwcy5TaXplKHBpeGVsT2Zmc2V0WzBdLCBwaXhlbE9mZnNldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoZWFkZXJDb250ZW50KSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlckNvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJDb250ZW50ID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaGVhZGVyQ29udGVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBoZWFkZXJDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDogaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1dpbmRvdy5zZXRPcHRpb25zKGluZm9XaW5kb3dPcHRpb25zKTtcbiAgICB9LCBcbiAgICAvLyBkZXBlbmRlbmN5IGBpbmZvV2luZG93YCBpc24ndCBuZWVkZWQgc2luY2Ugb3B0aW9ucyBhcmUgYWxzbyBwYXNzZWRcbiAgICAvLyB0byB0aGUgY29uc3RydWN0b3Igd2hlbiBhIG5ldyBpbmZvV2luZG93IGlzIGNyZWF0ZWQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtpbmZvV2luZG93T3B0aW9ucywgcGl4ZWxPZmZzZXQsIGhlYWRlckNvbnRlbnRdKTtcbiAgICAvLyAjIyBiaW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIoaW5mb1dpbmRvdywgJ2Nsb3NlJywgb25DbG9zZSk7XG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIoaW5mb1dpbmRvdywgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spO1xuICAgIC8vIC0tLS0gb3BlbiBpbmZvIHdpbmRvdyB3aGVuIGNvbnRlbnQgYW5kIG1hcCBhcmUgYXZhaWxhYmxlXG4gICAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBgYW5jaG9yID09PSBudWxsYCBtZWFucyBhbiBhbmNob3IgaXMgZGVmaW5lZCBidXQgbm90IHJlYWR5IHlldC5cbiAgICAgICAgaWYgKCFtYXAgfHwgIWluZm9XaW5kb3cgfHwgYW5jaG9yID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpc09wZW5lZFdpdGhBbmNob3IgPSAhIWFuY2hvcjtcbiAgICAgICAgY29uc3Qgb3Blbk9wdGlvbnMgPSB7IG1hcCB9O1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICBvcGVuT3B0aW9ucy5hbmNob3IgPSBhbmNob3I7XG4gICAgICAgICAgICAvLyBPbmx5IGRvIHRoZSBpbmZvd2luZG93IGFkanVzdGluZyB3aGVuIGRlYWxpbmcgd2l0aCBhbiBBZHZhbmNlZE1hcmtlclxuICAgICAgICAgICAgaWYgKGlzQWR2YW5jZWRNYXJrZXIoYW5jaG9yKSAmJiBhbmNob3IuY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JCY3IgPSBhbmNob3IgPT09IG51bGwgfHwgYW5jaG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGFuY2hvciBoYXMgY3VzdG9tIGNvbnRlbnQgd2l0aCBvdXIgb3duXG4gICAgICAgICAgICAgICAgLy8gZGl2IHdyYXBwZXIuIElmIG5vdCwgdGhhdCBtZWFucyB3ZSBoYXZlIGEgcmVndWxhciBBZHZhbmNlZE1hcmtlciB3aXRob3V0XG4gICAgICAgICAgICAgICAgLy8gY2hpbGRyZW4sIG9yIGFuIEFkdmFuY2VkTWFya2VyIHRoYXQgdXNlcyB0aGUgYW5jaG9yTGVmdC9hbmNob3JUb3AgcHJvcHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIGFkanVzdCB0aGUgaW5mb3dpbmRvdyBzaW5jZSBpdCBpcyBhbGwgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBieSB0aGUgR29vZ2xlIE1hcHMgQVBJLlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3JCY3IgJiYgYW5jaG9yLmRhdGFzZXQub3JpZ2luID09PSAncmdtJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc2FmZWx5IHR5cGVjYXN0IGhlcmUgc2luY2Ugd2UgY29udHJvbCB0aGF0IGVsZW1lbnQgYW5kIHdlIGtub3cgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBhIGRpdlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JEb21Db250ZW50ID0gKF9hID0gYW5jaG9yLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudEJjciA9IGFuY2hvckRvbUNvbnRlbnQgPT09IG51bGwgfHwgYW5jaG9yRG9tQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5jaG9yRG9tQ29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VudGVyIGluZm93aW5kb3cgYWJvdmUgbWFya2VyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvck9mZnNldFggPSBjb250ZW50QmNyLnggLVxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yQmNyLnggK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnRCY3Iud2lkdGggLSBhbmNob3JCY3Iud2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0WSA9IGNvbnRlbnRCY3IueSAtIGFuY2hvckJjci55O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaXhlbE9mZnNldCA/IHBpeGVsT2Zmc2V0WzBdICsgYW5jaG9yT2Zmc2V0WCA6IGFuY2hvck9mZnNldFgsIHBpeGVsT2Zmc2V0ID8gcGl4ZWxPZmZzZXRbMV0gKyBhbmNob3JPZmZzZXRZIDogYW5jaG9yT2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0T3B0aW9ucyhvcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZEZvY3VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZW5PcHRpb25zLnNob3VsZEZvY3VzID0gc2hvdWxkRm9jdXM7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG9wZW5PcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHdoZW4gdGhlIGluZm93aW5kb3cgaGFzIGFuIGFuY2hvciwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHNob3cgdXAgYWdhaW4gd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGFuY2hvciB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYmVmb3JlIGluZm9XaW5kb3cuY2xvc2UoKSBpcyBjYWxsZWQgYnV0IHRoZSBpdCBnZXRzXG4gICAgICAgICAgICAvLyBhZGRlZCBiYWNrIHRvIHRoZSBtYXAgYWZ0ZXIgdGhhdC5cbiAgICAgICAgICAgIC8vIE1vcmUgaW5mb3JtYXRpb24gaGVyZTogaHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvMzQzNzUwODQ5XG4gICAgICAgICAgICBpZiAoaXNPcGVuZWRXaXRoQW5jaG9yKVxuICAgICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0KCdhbmNob3InLCBudWxsKTtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaW5mb1dpbmRvdywgYW5jaG9yLCBtYXAsIHNob3VsZEZvY3VzLCBpbmZvV2luZG93T3B0aW9ucywgcGl4ZWxPZmZzZXRdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpLFxuICAgICAgICBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgY3JlYXRlUG9ydGFsKGhlYWRlckNvbnRlbnQsIGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50KSkpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbG9jYXRpb24gaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBzdWl0YWJsZSBmb3IgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSS5cbiAqXG4gKiBAcGFyYW0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gZm9ybWF0LCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdCB3aXRoIGxhdC9sbmcgcHJvcGVydGllc1xuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxvY2F0aW9uIGluIHRoZSBmb3JtYXQgXCJsYXQsbG5nXCIgb3IgdGhlIG9yaWdpbmFsIHN0cmluZ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXR1cm5zIFwiNDAuNzE0NzI4LC03My45OTg2NzJcIlxuICogZm9ybWF0TG9jYXRpb24oeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0pXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJldHVybnMgXCJOZXcgWW9yaywgTllcIlxuICogZm9ybWF0TG9jYXRpb24oXCJOZXcgWW9yaywgTllcIilcbiAqL1xuZnVuY3Rpb24gZm9ybWF0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGxvY2F0aW9uXG4gICAgICAgIDogYCR7bG9jYXRpb24ubGF0fSwke2xvY2F0aW9uLmxuZ31gO1xufVxuLy8gVXNlZCBmb3IgcmVtb3ZpbmcgdGhlIGxlYWRpbmcgcGlwZSBmcm9tIHRoZSBwYXJhbSBzdHJpbmdcbmZ1bmN0aW9uIGZvcm1hdFBhcmFtKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQXNzZW1ibGVzIG1hcmtlciBwYXJhbWV0ZXJzIGZvciBzdGF0aWMgbWFwcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIGdyb3VwcyB0aGVtIGJ5IHRoZWlyIHN0eWxlIHByb3BlcnRpZXMuXG4gKiBJdCB0aGVuIGNyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbWFya2VycywgaW5jbHVkaW5nIHRoZWlyIHN0eWxlcyBhbmQgbG9jYXRpb25zLFxuICogd2hpY2ggY2FuIGJlIHVzZWQgYXMgcGFyYW1ldGVycyBmb3Igc3RhdGljIG1hcCBBUElzLlxuICpcbiAqIEBwYXJhbSB7U3RhdGljTWFwc01hcmtlcltdfSBbbWFya2Vycz1bXV0gLSBBbiBhcnJheSBvZiBtYXJrZXJzIHRvIGJlIHByb2Nlc3NlZC4gRWFjaCBtYXJrZXIgY2FuIGhhdmUgcHJvcGVydGllcyBzdWNoIGFzIGNvbG9yLCBsYWJlbCwgc2l6ZSwgc2NhbGUsIGljb24sIGFuY2hvciwgYW5kIGxvY2F0aW9uLlxuICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBzdHJpbmdzLCBlYWNoIHJlcHJlc2VudGluZyBhIGdyb3VwIG9mIG1hcmtlcnMgd2l0aCB0aGVpciBzdHlsZXMgYW5kIGxvY2F0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWFya2VycyA9IFtcbiAqICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ0EnLCBzaXplOiAnbWlkJywgbG9jYXRpb246ICc0MC43MTQ3MjgsLTczLjk5ODY3MicgfSxcbiAqICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ0InLCBzaXplOiAnbWlkJywgbG9jYXRpb246ICc0MC43MTQ3MjgsLTczLjk5ODY3MicgfSxcbiAqICAgeyBpY29uOiAnaHR0cDovL2V4YW1wbGUuY29tL2ljb24ucG5nJywgbG9jYXRpb246IHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9IH1cbiAqIF07XG4gKiBjb25zdCBwYXJhbXMgPSBhc3NlbWJsZU1hcmtlclBhcmFtcyhtYXJrZXJzKTtcbiAqIC8vIFBhcmFtcyB3aWxsIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBtYXJrZXIgcGFyYW1ldGVyc1xuICogRXhhbXBsZSBvdXRwdXQ6IFtcbiAqICAgXCJjb2xvcjpibHVlfGxhYmVsOkF8c2l6ZTptaWR8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE0NzI4LC03My45OTg2NzJcIixcbiAqICAgXCJjb2xvcjpibHVlfGxhYmVsOkJ8c2l6ZTptaWR8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE0NzI4LC03My45OTg2NzJcIixcbiAqICAgXCJpY29uOmh0dHA6Ly9leGFtcGxlLmNvbS9pY29uLnBuZ3w0MC43MTQ3MjgsLTczLjk5ODY3MlwiXG4gKiBdXG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlTWFya2VyUGFyYW1zKG1hcmtlcnMgPSBbXSkge1xuICAgIGNvbnN0IG1hcmtlclBhcmFtcyA9IFtdO1xuICAgIC8vIEdyb3VwIG1hcmtlcnMgYnkgc3R5bGVcbiAgICBjb25zdCBtYXJrZXJzQnlTdHlsZSA9IG1hcmtlcnMgPT09IG51bGwgfHwgbWFya2VycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2Vycy5yZWR1Y2UoKHN0eWxlcywgbWFya2VyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IgPSAncmVkJywgbGFiZWwsIHNpemUsIHNjYWxlLCBpY29uLCBhbmNob3IgfSA9IG1hcmtlcjtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIHN0eWxlIGtleSBiYXNlZCBvbiBlaXRoZXIgaWNvbiBwcm9wZXJ0aWVzIG9yIHN0YW5kYXJkIG1hcmtlciBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHJlbGV2YW50UHJvcHMgPSBpY29uID8gW2ljb24sIGFuY2hvciwgc2NhbGVdIDogW2NvbG9yLCBsYWJlbCwgc2l6ZV07XG4gICAgICAgIGNvbnN0IGtleSA9IHJlbGV2YW50UHJvcHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKTtcbiAgICAgICAgc3R5bGVzW2tleV0gPSBzdHlsZXNba2V5XSB8fCBbXTtcbiAgICAgICAgc3R5bGVzW2tleV0ucHVzaChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sIHt9KTtcbiAgICBPYmplY3QudmFsdWVzKG1hcmtlcnNCeVN0eWxlICE9PSBudWxsICYmIG1hcmtlcnNCeVN0eWxlICE9PSB2b2lkIDAgPyBtYXJrZXJzQnlTdHlsZSA6IHt9KS5mb3JFYWNoKG1hcmtlcnMgPT4ge1xuICAgICAgICBsZXQgbWFya2VyUGFyYW0gPSAnJztcbiAgICAgICAgY29uc3QgeyBpY29uIH0gPSBtYXJrZXJzWzBdO1xuICAgICAgICAvLyBDcmVhdGUgbWFya2VyIHN0eWxlIGZyb20gZmlyc3QgbWFya2VyIGluIGdyb3VwIHNpbmNlIGFsbCBtYXJrZXJzIHNoYXJlIHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICBPYmplY3QuZW50cmllcyhtYXJrZXJzWzBdKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgYmFzZWQgb24gd2hldGhlciBtYXJrZXIgdXNlcyBjdXN0b20gaWNvblxuICAgICAgICAgICAgY29uc3QgcmVsZXZhbnRLZXlzID0gaWNvblxuICAgICAgICAgICAgICAgID8gWydpY29uJywgJ2FuY2hvcicsICdzY2FsZSddXG4gICAgICAgICAgICAgICAgOiBbJ2NvbG9yJywgJ2xhYmVsJywgJ3NpemUnXTtcbiAgICAgICAgICAgIGlmIChyZWxldmFudEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlclBhcmFtICs9IGB8JHtrZXl9OiR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBsb2NhdGlvbiBjb29yZGluYXRlcyBmb3IgZWFjaCBtYXJrZXIgaW4gdGhlIHN0eWxlIGdyb3VwXG4gICAgICAgIC8vIEhhbmRsZXMgYm90aCBzdHJpbmcgbG9jYXRpb25zIGFuZCBsYXQvbG5nIG9iamVjdCBmb3JtYXRzLlxuICAgICAgICBmb3IgKGNvbnN0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHR5cGVvZiBtYXJrZXIubG9jYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBtYXJrZXIubG9jYXRpb25cbiAgICAgICAgICAgICAgICA6IGAke21hcmtlci5sb2NhdGlvbi5sYXR9LCR7bWFya2VyLmxvY2F0aW9uLmxuZ31gO1xuICAgICAgICAgICAgbWFya2VyUGFyYW0gKz0gYHwke2xvY2F0aW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyUGFyYW1zLnB1c2gobWFya2VyUGFyYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJrZXJQYXJhbXMubWFwKGZvcm1hdFBhcmFtKTtcbn1cblxuLy8gU3R5bGUgcHJvcGVydGllcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHBhdGhzIGluIHRoZSBTdGF0aWMgTWFwcyBBUElcbmNvbnN0IFBBVEhfU1RZTEVfS0VZUyA9IFsnY29sb3InLCAnd2VpZ2h0JywgJ2ZpbGxjb2xvcicsICdnZW9kZXNpYyddO1xuLyoqXG4gKiBCdWlsZHMgdGhlIHN0eWxlIHBvcnRpb24gb2YgYSBwYXRoIHBhcmFtZXRlciBzdHJpbmcuXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIG9iamVjdCBjb250YWluaW5nIHN0eWxlIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHdpdGggc3R5bGUgcGFyYW1ldGVycyBpbiB0aGUgZm9ybWF0IFwifGtleTp2YWx1ZVwiXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3R5bGVQYXJhbXMocGF0aCkge1xuICAgIGxldCBzdHlsZVBhcmFtcyA9ICcnO1xuICAgIFBBVEhfU1RZTEVfS0VZUy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChwYXRoW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVQYXJhbXMgKz0gYHwke2tleX06JHtwYXRoW2tleV19YDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZVBhcmFtcztcbn1cbi8qKlxuICogQnVpbGRzIHRoZSBjb29yZGluYXRlcyBwb3J0aW9uIG9mIGEgcGF0aCBwYXJhbWV0ZXIgc3RyaW5nLlxuICogQHBhcmFtIGNvb3JkaW5hdGVzIC0gRWl0aGVyIGEgc3RyaW5nIG9yIGFycmF5IG9mIGxvY2F0aW9uIG9iamVjdHNcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHdpdGggY29vcmRpbmF0ZXMgaW4gdGhlIGZvcm1hdCBcInxsYXQsbG5nfGxhdCxsbmdcIlxuICovXG5mdW5jdGlvbiBidWlsZENvb3JkaW5hdGVQYXJhbXMoY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGNvb3JkaW5hdGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYHwke2RlY29kZVVSSUNvbXBvbmVudChjb29yZGluYXRlcyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzLm1hcChsb2NhdGlvbiA9PiBgfCR7Zm9ybWF0TG9jYXRpb24obG9jYXRpb24pfWApLmpvaW4oJycpO1xufVxuLyoqXG4gKiBBc3NlbWJsZXMgcGF0aCBwYXJhbWV0ZXJzIGZvciB0aGUgU3RhdGljIE1hcHMgQVBJIGZyb20gYW4gYXJyYXkgb2YgcGF0aHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIGEgc3RyaW5nIG9mIHBhdGggcGFyYW1ldGVycyBmb3IgZWFjaCBwYXRoLiBFYWNoIHBhdGggcGFyYW1ldGVyIHN0cmluZ1xuICogaW5jbHVkZXMgdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcGF0aHMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdGF0aWNNYXBzUGF0aD59IFtwYXRocz1bXV0gLSBBbiBhcnJheSBvZiBwYXRocyB0byBiZSBhc3NlbWJsZWQgaW50byBwYXRoIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gQW4gYXJyYXkgb2YgcGF0aCBwYXJhbWV0ZXIgc3RyaW5ncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcGF0aHMgPSBbXG4gKiAgIHtcbiAqICAgICBjb2xvcjogJ3JlZCcsXG4gKiAgICAgd2VpZ2h0OiA1LFxuICogICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgICAgIHsgbGF0OiA0MC43MTgyMTcsIGxuZzogLTczLjk5ODI4NCB9XG4gKiAgICAgXVxuICogICB9XG4gKiBdO1xuICpcbiAqIGNvbnN0IHBhdGhQYXJhbXMgPSBhc3NlbWJsZVBhdGhQYXJhbXMocGF0aHMpO1xuICogLy8gT3V0cHV0OiBbJ2NvbG9yOnJlZHx3ZWlnaHQ6NXw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTgyMTcsLTczLjk5ODI4NCddXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVQYXRoUGFyYW1zKHBhdGhzID0gW10pIHtcbiAgICByZXR1cm4gcGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgICBjb25zdCBzdHlsZVBhcmFtcyA9IGJ1aWxkU3R5bGVQYXJhbXMocGF0aCk7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVQYXJhbXMgPSBidWlsZENvb3JkaW5hdGVQYXJhbXMocGF0aC5jb29yZGluYXRlcyk7XG4gICAgICAgIGNvbnN0IHBhdGhQYXJhbSA9IHN0eWxlUGFyYW1zICsgY29vcmRpbmF0ZVBhcmFtcztcbiAgICAgICAgcmV0dXJuIGZvcm1hdFBhcmFtKHBhdGhQYXJhbSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgR29vZ2xlIE1hcHMgc3R5bGUgb2JqZWN0cyBpbnRvIGFuIGFycmF5IG9mIHN0eWxlIHN0cmluZ3NcbiAqIGNvbXBhdGlibGUgd2l0aCB0aGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSS5cbiAqXG4gKiBAcGFyYW0gc3R5bGVzIC0gQW4gYXJyYXkgb2YgR29vZ2xlIE1hcHMgTWFwVHlwZVN0eWxlIG9iamVjdHMgdGhhdCBkZWZpbmUgdGhlIHN0eWxpbmcgcnVsZXNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGZvcm1hdHRlZCBzdHlsZSBzdHJpbmdzIHJlYWR5IHRvIGJlIHVzZWQgd2l0aCB0aGUgU3RhdGljIE1hcHMgQVBJXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0eWxlcyA9IFt7XG4gKiAgIGZlYXR1cmVUeXBlOiBcInJvYWRcIixcbiAqICAgZWxlbWVudFR5cGU6IFwiZ2VvbWV0cnlcIixcbiAqICAgc3R5bGVyczogW3tjb2xvcjogXCIjZmYwMDAwXCJ9LCB7d2VpZ2h0OiAxfV1cbiAqIH1dO1xuICpcbiAqIGNvbnN0IHN0eWxlU3RyaW5ncyA9IGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZXMpO1xuICogLy8gUmV0dXJuczogW1wifGZlYXR1cmU6cm9hZHxlbGVtZW50Omdlb21ldHJ5fGNvbG9yOjB4ZmYwMDAwfHdlaWdodDoxXCJdXG4gKlxuICogRWFjaCBzdHlsZSBzdHJpbmcgZm9sbG93cyB0aGUgZm9ybWF0OlxuICogXCJmZWF0dXJlOntmZWF0dXJlVHlwZX18ZWxlbWVudDp7ZWxlbWVudFR5cGV9fHtzdHlsZXJOYW1lfTp7c3R5bGVyVmFsdWV9XCJcbiAqXG4gKiBOb3RlOiBDb2xvciB2YWx1ZXMgd2l0aCBoZXhhZGVjaW1hbCBub3RhdGlvbiAoIykgYXJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkXG4gKiB0byB0aGUgcmVxdWlyZWQgMHggZm9ybWF0IGZvciB0aGUgU3RhdGljIE1hcHMgQVBJLlxuICovXG5mdW5jdGlvbiBhc3NlbWJsZU1hcFR5cGVTdHlsZXMoc3R5bGVzKSB7XG4gICAgcmV0dXJuIHN0eWxlc1xuICAgICAgICAubWFwKChtYXBUeXBlU3R5bGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBmZWF0dXJlVHlwZSwgZWxlbWVudFR5cGUsIHN0eWxlcnMgPSBbXSB9ID0gbWFwVHlwZVN0eWxlO1xuICAgICAgICBsZXQgc3R5bGVTdHJpbmcgPSAnJztcbiAgICAgICAgaWYgKGZlYXR1cmVUeXBlKSB7XG4gICAgICAgICAgICBzdHlsZVN0cmluZyArPSBgfGZlYXR1cmU6JHtmZWF0dXJlVHlwZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgc3R5bGVTdHJpbmcgKz0gYHxlbGVtZW50OiR7ZWxlbWVudFR5cGV9YDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlciBvZiBzdHlsZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhzdHlsZXIpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBzdHlsZVN0cmluZyArPSBgfCR7bmFtZX06JHtTdHJpbmcodmFsdWUpLnJlcGxhY2UoJyMnLCAnMHgnKX1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlU3RyaW5nO1xuICAgIH0pXG4gICAgICAgIC5tYXAoZm9ybWF0UGFyYW0pO1xufVxuXG5jb25zdCBTVEFUSUNfTUFQU19CQVNFID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9zdGF0aWNtYXAnO1xuLyoqXG4gKiBDcmVhdGVzIGEgVVJMIGZvciB0aGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSSB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBzdGF0aWMgbWFwXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hcGlLZXkgLSBZb3VyIEdvb2dsZSBNYXBzIEFQSSBrZXkgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIG1hcCBpbWFnZSBpbiBwaXhlbHMgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgbWFwIGltYWdlIGluIHBpeGVscyAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNMb2NhdGlvbn0gW29wdGlvbnMuY2VudGVyXSAtIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIG1hcCAobGF0L2xuZyBvciBhZGRyZXNzKS5cbiAqICBSZXF1aXJlZCBpZiBubyBtYXJrZXJzIG9yIHBhdGhzIG9yIFwidmlzaWJsZSBsb2NhdGlvbnNcIiBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuem9vbV0gLSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBSZXF1aXJlZCBpZiBubyBtYXJrZXJzIG9yIHBhdGhzIG9yIFwidmlzaWJsZSBsb2NhdGlvbnNcIiBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0gezF8Mnw0fSBbb3B0aW9ucy5zY2FsZV0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgbWFwICgxLCAyLCBvciA0KVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZvcm1hdF0gLSBUaGUgaW1hZ2UgZm9ybWF0IChwbmcsIHBuZzgsIHBuZzMyLCBnaWYsIGpwZywganBnLWJhc2VsaW5lKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcFR5cGVdIC0gVGhlIHR5cGUgb2YgbWFwIChyb2FkbWFwLCBzYXRlbGxpdGUsIHRlcnJhaW4sIGh5YnJpZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV0gLSBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIG1hcCBsYWJlbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWdpb25dIC0gVGhlIHJlZ2lvbiBjb2RlIGZvciB0aGUgbWFwXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFwX2lkXSAtIFRoZSBDbG91ZC1iYXNlZCBtYXAgc3R5bGUgSURcbiAqIEBwYXJhbSB7U3RhdGljTWFwc01hcmtlcltdfSBbb3B0aW9ucy5tYXJrZXJzPVtdXSAtIEFycmF5IG9mIG1hcmtlcnMgdG8gZGlzcGxheSBvbiB0aGUgbWFwXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNQYXRoW119IFtvcHRpb25zLnBhdGhzPVtdXSAtIEFycmF5IG9mIHBhdGhzIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxuICogQHBhcmFtIHtTdGF0aWNNYXBzTG9jYXRpb25bXX0gW29wdGlvbnMudmlzaWJsZT1bXV0gLSBBcnJheSBvZiBsb2NhdGlvbnMgdGhhdCBzaG91bGQgYmUgdmlzaWJsZSBvbiB0aGUgbWFwXG4gKiBAcGFyYW0ge01hcFR5cGVTdHlsZVtdfSBbb3B0aW9ucy5zdHlsZT1bXV0gLSBBcnJheSBvZiBzdHlsZSBvYmplY3RzIHRvIGN1c3RvbWl6ZSB0aGUgbWFwIGFwcGVhcmFuY2VcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tcGxldGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSSBVUkxcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgQVBJIGtleSBpcyBub3QgcHJvdmlkZWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB3aWR0aCBvciBoZWlnaHQgaXMgbm90IHByb3ZpZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHVybCA9IGNyZWF0ZVN0YXRpY01hcHNVcmwoe1xuICogICBhcGlLZXk6ICdZT1VSX0FQSV9LRVknLFxuICogICB3aWR0aDogNjAwLFxuICogICBoZWlnaHQ6IDQwMCxcbiAqICAgY2VudGVyOiB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgem9vbTogMTIsXG4gKiAgIG1hcmtlcnM6IFtcbiAqICAgICB7XG4gKiAgICAgICBsb2NhdGlvbjogeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0sXG4gKiAgICAgICBjb2xvcjogJ3JlZCcsXG4gKiAgICAgICBsYWJlbDogJ0EnXG4gKiAgICAgfVxuICogICBdLFxuICogICBwYXRoczogW1xuICogICAgIHtcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICAgIHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9LFxuICogICAgICAgICB7IGxhdDogNDAuNzE5NzI4LCBsbmc6IC03My45OTE2NzIgfVxuICogICAgICAgXSxcbiAqICAgICAgIGNvbG9yOiAnMHgwMDAwZmYnLFxuICogICAgICAgd2VpZ2h0OiA1XG4gKiAgICAgfVxuICogICBdLFxuICogICBzdHlsZTogW1xuICogICAgIHtcbiAqICAgICAgIGZlYXR1cmVUeXBlOiAncm9hZCcsXG4gKiAgICAgICBlbGVtZW50VHlwZTogJ2dlb21ldHJ5JyxcbiAqICAgICAgIHN0eWxlcnM6IFt7Y29sb3I6ICcjMDBmZjAwJ31dXG4gKiAgICAgfVxuICogICBdXG4gKiB9KTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIFVSTCBzaW1pbGFyIHRvOlxuICogLy8gaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL3N0YXRpY21hcD9rZXk9WU9VUl9BUElfS0VZXG4gKiAvLyAmc2l6ZT02MDB4NDAwXG4gKiAvLyAmY2VudGVyPTQwLjcxNDcyOCwtNzMuOTk4NjcyJnpvb209MTJcbiAqIC8vICZtYXJrZXJzPWNvbG9yOnJlZHxsYWJlbDpBfDQwLjcxNDcyOCwtNzMuOTk4NjcyXG4gKiAvLyAmcGF0aD1jb2xvcjoweDAwMDBmZnx3ZWlnaHQ6NXw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTk3MjgsLTczLjk5MTY3MlxuICogLy8gJnN0eWxlPWZlYXR1cmU6cm9hZHxlbGVtZW50Omdlb21ldHJ5fGNvbG9yOjB4MDBmZjAwXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY01hcHNVcmwoeyBhcGlLZXksIHdpZHRoLCBoZWlnaHQsIGNlbnRlciwgem9vbSwgc2NhbGUsIGZvcm1hdCwgbWFwVHlwZSwgbGFuZ3VhZ2UsIHJlZ2lvbiwgbWFwSWQsIG1hcmtlcnMgPSBbXSwgcGF0aHMgPSBbXSwgdmlzaWJsZSA9IFtdLCBzdHlsZSA9IFtdIH0pIHtcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0FQSSBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV2lkdGggYW5kIGhlaWdodCBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsga2V5OiBhcGlLZXksIHNpemU6IGAke3dpZHRofXgke2hlaWdodH1gIH0sIChjZW50ZXIgJiYgeyBjZW50ZXI6IGZvcm1hdExvY2F0aW9uKGNlbnRlcikgfSkpLCAoem9vbSAmJiB7IHpvb20gfSkpLCAoc2NhbGUgJiYgeyBzY2FsZSB9KSksIChmb3JtYXQgJiYgeyBmb3JtYXQgfSkpLCAobWFwVHlwZSAmJiB7IG1hcHR5cGU6IG1hcFR5cGUgfSkpLCAobGFuZ3VhZ2UgJiYgeyBsYW5ndWFnZSB9KSksIChyZWdpb24gJiYgeyByZWdpb24gfSkpLCAobWFwSWQgJiYgeyBtYXBfaWQ6IG1hcElkIH0pKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFNUQVRJQ19NQVBTX0JBU0UpO1xuICAgIC8vIFBhcmFtcyB0aGF0IGRvbid0IG5lZWQgc3BlY2lhbCBoYW5kbGluZ1xuICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfSk7XG4gICAgLy8gQXNzZW1ibGUgTWFya2Vyc1xuICAgIGZvciAoY29uc3QgbWFya2VyUGFyYW0gb2YgYXNzZW1ibGVNYXJrZXJQYXJhbXMobWFya2VycykpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ21hcmtlcnMnLCBtYXJrZXJQYXJhbSk7XG4gICAgfVxuICAgIC8vIEFzc2VtYmxlIFBhdGhzXG4gICAgZm9yIChjb25zdCBwYXRoUGFyYW0gb2YgYXNzZW1ibGVQYXRoUGFyYW1zKHBhdGhzKSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgncGF0aCcsIHBhdGhQYXJhbSk7XG4gICAgfVxuICAgIC8vIEFzc2VtYmxlIHZpc2libGUgbG9jYXRpb25zXG4gICAgaWYgKHZpc2libGUubGVuZ3RoKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd2aXNpYmxlJywgdmlzaWJsZS5tYXAobG9jYXRpb24gPT4gZm9ybWF0TG9jYXRpb24obG9jYXRpb24pKS5qb2luKCd8JykpO1xuICAgIH1cbiAgICAvLyBBc3NlbWJsZSBNYXAgVHlwZSBTdHlsZXNcbiAgICBmb3IgKGNvbnN0IHN0eWxlU3RyaW5nIG9mIGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZSkpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3N0eWxlJywgc3R5bGVTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG5cbmNvbnN0IFN0YXRpY01hcCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCBjbGFzc05hbWUgfSA9IHByb3BzO1xuICAgIGlmICghdXJsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBpcyByZXF1aXJlZCcpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHNyYzogdXJsLCB3aWR0aDogXCIxMDAlXCIgfSk7XG59O1xuXG4vKipcbiAqIENvcHkgb2YgdGhlIGBnb29nbGUubWFwcy5Db250cm9sUG9zaXRpb25gIGNvbnN0YW50cy5cbiAqIFRoZXkgaGF2ZSB0byBiZSBkdXBsaWNhdGVkIGhlcmUgc2luY2Ugd2UgY2FuJ3Qgd2FpdCBmb3IgdGhlIG1hcHMgQVBJIHRvIGxvYWQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbS5cbiAqL1xuY29uc3QgQ29udHJvbFBvc2l0aW9uID0ge1xuICAgIFRPUF9MRUZUOiAxLFxuICAgIFRPUF9DRU5URVI6IDIsXG4gICAgVE9QOiAyLFxuICAgIFRPUF9SSUdIVDogMyxcbiAgICBMRUZUX0NFTlRFUjogNCxcbiAgICBMRUZUX1RPUDogNSxcbiAgICBMRUZUOiA1LFxuICAgIExFRlRfQk9UVE9NOiA2LFxuICAgIFJJR0hUX1RPUDogNyxcbiAgICBSSUdIVDogNyxcbiAgICBSSUdIVF9DRU5URVI6IDgsXG4gICAgUklHSFRfQk9UVE9NOiA5LFxuICAgIEJPVFRPTV9MRUZUOiAxMCxcbiAgICBCT1RUT01fQ0VOVEVSOiAxMSxcbiAgICBCT1RUT006IDExLFxuICAgIEJPVFRPTV9SSUdIVDogMTIsXG4gICAgQ0VOVEVSOiAxMyxcbiAgICBCTE9DS19TVEFSVF9JTkxJTkVfU1RBUlQ6IDE0LFxuICAgIEJMT0NLX1NUQVJUX0lOTElORV9DRU5URVI6IDE1LFxuICAgIEJMT0NLX1NUQVJUX0lOTElORV9FTkQ6IDE2LFxuICAgIElOTElORV9TVEFSVF9CTE9DS19DRU5URVI6IDE3LFxuICAgIElOTElORV9TVEFSVF9CTE9DS19TVEFSVDogMTgsXG4gICAgSU5MSU5FX1NUQVJUX0JMT0NLX0VORDogMTksXG4gICAgSU5MSU5FX0VORF9CTE9DS19TVEFSVDogMjAsXG4gICAgSU5MSU5FX0VORF9CTE9DS19DRU5URVI6IDIxLFxuICAgIElOTElORV9FTkRfQkxPQ0tfRU5EOiAyMixcbiAgICBCTE9DS19FTkRfSU5MSU5FX1NUQVJUOiAyMyxcbiAgICBCTE9DS19FTkRfSU5MSU5FX0NFTlRFUjogMjQsXG4gICAgQkxPQ0tfRU5EX0lOTElORV9FTkQ6IDI1XG59O1xuY29uc3QgTWFwQ29udHJvbCA9ICh7IGNoaWxkcmVuLCBwb3NpdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgY29udHJvbENvbnRhaW5lciA9IHVzZU1lbW8oKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIFtdKTtcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY29udHJvbHMgPSBtYXAuY29udHJvbHNbcG9zaXRpb25dO1xuICAgICAgICBjb250cm9scy5wdXNoKGNvbnRyb2xDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbHNBcnJheSA9IGNvbnRyb2xzLmdldEFycmF5KCk7XG4gICAgICAgICAgICAvLyBjb250cm9sc0FycmF5IGNvdWxkIGJlIHVuZGVmaW5lZCBpZiB0aGUgbWFwIGlzIGluIGFuIHVuZGVmaW5lZCBzdGF0ZSAoZS5nLiBpbnZhbGlkIEFQSS1rZXksIHNlZSAjMjc2XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xzQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjb250cm9sc0FycmF5LmluZGV4T2YoY29udHJvbENvbnRhaW5lcik7XG4gICAgICAgICAgICBjb250cm9scy5yZW1vdmVBdChpbmRleCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NvbnRyb2xDb250YWluZXIsIG1hcCwgcG9zaXRpb25dKTtcbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250cm9sQ29udGFpbmVyKTtcbn07XG5cbmZ1bmN0aW9uIHVzZU1hcmtlcihwcm9wcykge1xuICAgIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICBjb25zdCB7IG9uQ2xpY2ssIG9uRHJhZywgb25EcmFnU3RhcnQsIG9uRHJhZ0VuZCwgb25Nb3VzZU92ZXIsIG9uTW91c2VPdXQgfSA9IHByb3BzLCBtYXJrZXJPcHRpb25zID0gX19yZXN0KHByb3BzLCBbXCJvbkNsaWNrXCIsIFwib25EcmFnXCIsIFwib25EcmFnU3RhcnRcIiwgXCJvbkRyYWdFbmRcIiwgXCJvbk1vdXNlT3ZlclwiLCBcIm9uTW91c2VPdXRcIl0pO1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIGRyYWdnYWJsZSB9ID0gbWFya2VyT3B0aW9ucztcbiAgICAvLyBjcmVhdGUgbWFya2VyIGluc3RhbmNlIGFuZCBhZGQgdG8gdGhlIG1hcCBvbmNlIHRoZSBtYXAgaXMgYXZhaWxhYmxlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCc8TWFya2VyPiBoYXMgdG8gYmUgaW5zaWRlIGEgTWFwIGNvbXBvbmVudC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG1hcmtlck9wdGlvbnMpO1xuICAgICAgICBuZXdNYXJrZXIuc2V0TWFwKG1hcCk7XG4gICAgICAgIHNldE1hcmtlcihuZXdNYXJrZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbmV3TWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gcmUtcmVuZGVyIHRoZSB3aG9sZSBtYXJrZXIgd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG4gICAgICAgIC8vIE1hcmtlciBvcHRpb25zIHVwZGF0ZSBpcyBoYW5kbGVkIGluIGEgdXNlRWZmZWN0IGJlbG93LlxuICAgICAgICAvLyBFeGNsdWRpbmcgbWFya2VyT3B0aW9ucyBmcm9tIGRlcGVuZGVuY3kgYXJyYXkgb24gcHVycG9zZSBoZXJlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW21hcF0pO1xuICAgIC8vIGF0dGFjaCBhbmQgcmUtYXR0YWNoIGV2ZW50LWhhbmRsZXJzIHdoZW4gYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGNoYW5nZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtID0gbWFya2VyO1xuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IGdtZSA9IGdvb2dsZS5tYXBzLmV2ZW50O1xuICAgICAgICBpZiAob25DbGljaylcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICAgICAgaWYgKG9uRHJhZylcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnZHJhZycsIG9uRHJhZyk7XG4gICAgICAgIGlmIChvbkRyYWdTdGFydClcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpO1xuICAgICAgICBpZiAob25EcmFnRW5kKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICAgICAgaWYgKG9uTW91c2VPdmVyKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdtb3VzZW91dCcsIG9uTW91c2VPdXQpO1xuICAgICAgICBtYXJrZXIuc2V0RHJhZ2dhYmxlKEJvb2xlYW4oZHJhZ2dhYmxlKSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBnbWUuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhtKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG1hcmtlcixcbiAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICBvbkNsaWNrLFxuICAgICAgICBvbkRyYWcsXG4gICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRyYWdFbmQsXG4gICAgICAgIG9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlT3V0XG4gICAgXSk7XG4gICAgLy8gdXBkYXRlIG1hcmtlck9wdGlvbnMgKG5vdGUgdGhlIGRlcGVuZGVuY2llcyBhcmVuJ3QgcHJvcGVybHkgY2hlY2tlZFxuICAgIC8vIGhlcmUsIHdlIGp1c3QgYXNzdW1lIHRoYXQgc2V0T3B0aW9ucyBpcyBzbWFydCBlbm91Z2ggdG8gbm90IHdhc3RlIGFcbiAgICAvLyBsb3Qgb2YgdGltZSB1cGRhdGluZyB2YWx1ZXMgdGhhdCBkaWRuJ3QgY2hhbmdlKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobWFya2VyT3B0aW9ucylcbiAgICAgICAgICAgIG1hcmtlci5zZXRPcHRpb25zKG1hcmtlck9wdGlvbnMpO1xuICAgIH0sIFttYXJrZXIsIG1hcmtlck9wdGlvbnNdKTtcbiAgICAvLyB1cGRhdGUgcG9zaXRpb24gd2hlbiBjaGFuZ2VkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gU2hvdWxkIG5vdCB1cGRhdGUgcG9zaXRpb24gd2hlbiBkcmFnZ2FibGVcbiAgICAgICAgaWYgKGRyYWdnYWJsZSB8fCAhcG9zaXRpb24gfHwgIW1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFya2VyLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9LCBbZHJhZ2dhYmxlLCBwb3NpdGlvbiwgbWFya2VyXSk7XG4gICAgcmV0dXJuIG1hcmtlcjtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIG1hcmtlciBvbiBhIG1hcFxuICovXG5jb25zdCBNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgbWFya2VyID0gdXNlTWFya2VyKHByb3BzKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbbWFya2VyXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpO1xufSk7XG5NYXJrZXIuZGlzcGxheU5hbWUgPSAnTWFya2VyJztcbmZ1bmN0aW9uIHVzZU1hcmtlclJlZigpIHtcbiAgICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgcmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygobSkgPT4ge1xuICAgICAgICBzZXRNYXJrZXIobSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIGNvbmZpZ3VyZSB0aGUgYXBwZWFyYW5jZSBvZiBhbiBBZHZhbmNlZE1hcmtlclxuICovXG5jb25zdCBQaW4gPSBwcm9wcyA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFkdmFuY2VkTWFya2VyID0gKF9hID0gdXNlQ29udGV4dChBZHZhbmNlZE1hcmtlckNvbnRleHQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VyO1xuICAgIGNvbnN0IGdseXBoQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICAgIC8vIENyZWF0ZSBQaW4gVmlldyBpbnN0YW5jZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFhZHZhbmNlZE1hcmtlcikge1xuICAgICAgICAgICAgaWYgKGFkdmFuY2VkTWFya2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgPFBpbj4gY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIDxBZHZhbmNlZE1hcmtlcj4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmdseXBoICYmIHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsb2dFcnJvck9uY2UoJ1RoZSA8UGluPiBjb21wb25lbnQgb25seSB1c2VzIGNoaWxkcmVuIHRvIHJlbmRlciB0aGUgZ2x5cGggaWYgYm90aCB0aGUgZ2x5cGggcHJvcGVydHkgYW5kIGNoaWxkcmVuIGFyZSBwcmVzZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbikgPiAxKSB7XG4gICAgICAgICAgICBsb2dFcnJvck9uY2UoJ1Bhc3NpbmcgbXVsdGlwbGUgY2hpbGRyZW4gdG8gdGhlIDxQaW4+IGNvbXBvbmVudCBtaWdodCBsZWFkIHRvIHVuZXhwZWN0ZWQgcmVzdWx0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaW5WaWV3T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKTtcbiAgICAgICAgY29uc3QgcGluRWxlbWVudCA9IG5ldyBnb29nbGUubWFwcy5tYXJrZXIuUGluRWxlbWVudChwaW5WaWV3T3B0aW9ucyk7XG4gICAgICAgIC8vIFNldCBnbHlwaCB0byBnbHlwaCBjb250YWluZXIgaWYgY2hpbGRyZW4gYXJlIHByZXNlbnQgKHJlbmRlcmVkIHZpYSBwb3J0YWwpLlxuICAgICAgICAvLyBJZiBib3RoIHByb3BzLmdseXBoIGFuZCBwcm9wcy5jaGlsZHJlbiBhcmUgcHJlc2VudCwgcHJvcHMuY2hpbGRyZW4gdGFrZXMgcHJpb3JpdHkuXG4gICAgICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcGluRWxlbWVudC5nbHlwaCA9IGdseXBoQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBjb250ZW50IG9mIEFkdmFuY2VkIE1hcmtlciBWaWV3IHRvIHRoZSBQaW4gVmlldyBlbGVtZW50XG4gICAgICAgIC8vIEhlcmUgd2UgYXJlIHNlbGVjdGluZyB0aGUgYW5jaG9yIGNvbnRhaW5lci5cbiAgICAgICAgLy8gVGhlIGhpZXJhcmNoeSBpcyBhcyBmb2xsb3dzOlxuICAgICAgICAvLyBcImFkdmFuY2VkTWFya2VyLmNvbnRlbnRcIiAoZnJvbSBnb29nbGUpIC0+IFwiYW5jaG9yIGNvbnRhaW5lclwiXG4gICAgICAgIGNvbnN0IG1hcmtlckNvbnRlbnQgPSAoX2EgPSBhZHZhbmNlZE1hcmtlci5jb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKG1hcmtlckNvbnRlbnQgPT09IG51bGwgfHwgbWFya2VyQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyQ29udGVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBtYXJrZXJDb250ZW50LnJlbW92ZUNoaWxkKG1hcmtlckNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlckNvbnRlbnQpIHtcbiAgICAgICAgICAgIG1hcmtlckNvbnRlbnQuYXBwZW5kQ2hpbGQocGluRWxlbWVudC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0sIFthZHZhbmNlZE1hcmtlciwgZ2x5cGhDb250YWluZXIsIHByb3BzXSk7XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChwcm9wcy5jaGlsZHJlbiwgZ2x5cGhDb250YWluZXIpO1xufTtcblxuY29uc3QgbWFwTGluZWFyID0gKHgsIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArICgoeCAtIGExKSAqIChiMiAtIGIxKSkgLyAoYTIgLSBhMSk7XG5jb25zdCBnZXRNYXBNYXhUaWx0ID0gKHpvb20pID0+IHtcbiAgICBpZiAoem9vbSA8PSAxMCkge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfVxuICAgIGlmICh6b29tID49IDE1LjUpIHtcbiAgICAgICAgcmV0dXJuIDY3LjU7XG4gICAgfVxuICAgIC8vIHJhbmdlIFsxMC4uLjE0XVxuICAgIGlmICh6b29tIDw9IDE0KSB7XG4gICAgICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTAsIDE0LCAzMCwgNDUpO1xuICAgIH1cbiAgICAvLyByYW5nZSBbMTQuLi4xNS41XVxuICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTQsIDE1LjUsIDQ1LCA2Ny41KTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHRvIGxpbWl0IHRoZSB0aWx0IHJhbmdlIG9mIHRoZSBHb29nbGUgbWFwIHdoZW4gdXBkYXRpbmcgdGhlIHZpZXcgc3RhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGxpbWl0VGlsdFJhbmdlID0gKHsgdmlld1N0YXRlIH0pID0+IHtcbiAgICBjb25zdCBwaXRjaCA9IHZpZXdTdGF0ZS5waXRjaDtcbiAgICBjb25zdCBnbVpvb20gPSB2aWV3U3RhdGUuem9vbSArIDE7XG4gICAgY29uc3QgbWF4VGlsdCA9IGdldE1hcE1heFRpbHQoZ21ab29tKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWV3U3RhdGUpLCB7IGZvdnk6IDI1LCBwaXRjaDogTWF0aC5taW4obWF4VGlsdCwgcGl0Y2gpIH0pO1xufTtcblxuZXhwb3J0IHsgQVBJTG9hZGluZ1N0YXR1cywgQVBJUHJvdmlkZXIsIEFQSVByb3ZpZGVyQ29udGV4dCwgQWR2YW5jZWRNYXJrZXIsIEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnQsIEFkdmFuY2VkTWFya2VyQ29udGV4dCwgQ29sbGlzaW9uQmVoYXZpb3IsIENvbG9yU2NoZW1lLCBDb250cm9sUG9zaXRpb24sIEdvb2dsZU1hcHNDb250ZXh0LCBJbmZvV2luZG93LCBNYXAsIE1hcENvbnRyb2wsIE1hcmtlciwgUGluLCBSZW5kZXJpbmdUeXBlLCBTdGF0aWNNYXAsIFZFUlNJT04sIGNyZWF0ZVN0YXRpY01hcHNVcmwsIGlzQWR2YW5jZWRNYXJrZXIsIGlzTGF0TG5nTGl0ZXJhbCwgbGF0TG5nRXF1YWxzLCBsaW1pdFRpbHRSYW5nZSwgdG9MYXRMbmdMaXRlcmFsLCB1c2VBZHZhbmNlZE1hcmtlclJlZiwgdXNlQXBpSXNMb2FkZWQsIHVzZUFwaUxvYWRpbmdTdGF0dXMsIHVzZU1hcCwgdXNlTWFwc0xpYnJhcnksIHVzZU1hcmtlclJlZiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubW9kZXJuLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInVzZVJlZHVjZXIiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNvbnRleHQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJmb3J3YXJkUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsIkNoaWxkcmVuIiwiY3JlYXRlUG9ydGFsIiwiaXNEZWVwRXF1YWwiLCJWRVJTSU9OIiwiX19yZXN0IiwicyIsImUiLCJ0IiwicCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpIiwibGVuZ3RoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIlN1cHByZXNzZWRFcnJvciIsImVycm9yIiwic3VwcHJlc3NlZCIsIm1lc3NhZ2UiLCJFcnJvciIsIm5hbWUiLCJBUElMb2FkaW5nU3RhdHVzIiwiTk9UX0xPQURFRCIsIkxPQURJTkciLCJMT0FERUQiLCJGQUlMRUQiLCJBVVRIX0ZBSUxVUkUiLCJNQVBTX0FQSV9CQVNFX1VSTCIsIkdvb2dsZU1hcHNBcGlMb2FkZXIiLCJsb2FkIiwicGFyYW1zIiwib25Mb2FkaW5nU3RhdHVzQ2hhbmdlIiwiX2EiLCJfYiIsImxpYnJhcmllcyIsInNwbGl0Iiwic2VyaWFsaXplZFBhcmFtcyIsInNlcmlhbGl6ZVBhcmFtcyIsImxpc3RlbmVycyIsInB1c2giLCJ3aW5kb3ciLCJnb29nbGUiLCJtYXBzIiwiaW1wb3J0TGlicmFyeSIsInNlcmlhbGl6ZWRBcGlQYXJhbXMiLCJsb2FkaW5nU3RhdHVzIiwibm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycyIsImluaXRJbXBvcnRMaWJyYXJ5IiwiY29uc29sZSIsIndhcm4iLCJsaWJyYXJpZXNUb0xvYWQiLCJhbGwiLCJtYXAiLCJ2Iiwia2V5IiwibGFuZ3VhZ2UiLCJyZWdpb24iLCJhdXRoUmVmZXJyZXJQb2xpY3kiLCJzb2x1dGlvbkNoYW5uZWwiLCJqb2luIiwiYXBpUHJvbWlzZSIsImxvYWRBcGkiLCJzY3JpcHRFbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidXJsUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiZW50cmllcyIsInVybFBhcmFtTmFtZSIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInNldCIsIlN0cmluZyIsImFzeW5jIiwic3JjIiwidG9TdHJpbmciLCJub25jZSIsInF1ZXJ5U2VsZWN0b3IiLCJvbmVycm9yIiwiX19nb29nbGVNYXBzQ2FsbGJhY2tfXyIsImdtX2F1dGhGYWlsdXJlIiwiaGVhZCIsImFwcGVuZCIsImxpYnJhcnlOYW1lIiwiZm4iLCJERUZBVUxUX1NPTFVUSU9OX0NIQU5ORUwiLCJERUZBVUxUX0lOVEVSTkFMX1VTQUdFX0FUVFJJQlVUSU9OX0lEUyIsIkFQSVByb3ZpZGVyQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VNYXBJbnN0YW5jZXMiLCJtYXBJbnN0YW5jZXMiLCJzZXRNYXBJbnN0YW5jZXMiLCJhZGRNYXBJbnN0YW5jZSIsIm1hcEluc3RhbmNlIiwiaWQiLCJpbnN0YW5jZXMiLCJhc3NpZ24iLCJyZW1vdmVNYXBJbnN0YW5jZSIsInJlbWFpbmluZyIsImNsZWFyTWFwSW5zdGFuY2VzIiwidXNlR29vZ2xlTWFwc0FwaUxvYWRlciIsInByb3BzIiwib25Mb2FkIiwib25FcnJvciIsImFwaUtleSIsInZlcnNpb24iLCJvdGhlckFwaVBhcmFtcyIsInN0YXR1cyIsInNldFN0YXR1cyIsImxvYWRlZExpYnJhcmllcyIsImFkZExvYWRlZExpYnJhcnkiLCJhY3Rpb24iLCJsaWJyYXJpZXNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicmVzIiwiY2hhbm5lbCIsInVuZGVmaW5lZCIsInVzZUludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyIsImludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyIsImRpc2FibGVVc2FnZUF0dHJpYnV0aW9uIiwiQVBJUHJvdmlkZXIiLCJjaGlsZHJlbiIsImxvYWRlclByb3BzIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ1c2VNYXBFdmVudHMiLCJwcm9wTmFtZSIsImV2ZW50UHJvcE5hbWVzIiwiaGFuZGxlciIsImV2ZW50VHlwZSIsInByb3BOYW1lVG9FdmVudFR5cGUiLCJsaXN0ZW5lciIsImV2ZW50IiwiYWRkTGlzdGVuZXIiLCJldiIsImNyZWF0ZU1hcEV2ZW50IiwicmVtb3ZlIiwidHlwZSIsInNyY0V2ZW50IiwiZGV0YWlsIiwic3RvcHBhYmxlIiwic3RvcCIsImNhbWVyYUV2ZW50VHlwZXMiLCJpbmNsdWRlcyIsImNhbUV2ZW50IiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwiem9vbSIsImdldFpvb20iLCJoZWFkaW5nIiwiZ2V0SGVhZGluZyIsInRpbHQiLCJnZXRUaWx0IiwiYm91bmRzIiwiZ2V0Qm91bmRzIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJsYXQiLCJsbmciLCJub3J0aCIsImVhc3QiLCJzb3V0aCIsIndlc3QiLCJtb3VzZUV2ZW50VHlwZXMiLCJtb3VzZUV2ZW50IiwiZG9tRXZlbnQiLCJsYXRMbmciLCJwbGFjZUlkIiwib25Cb3VuZHNDaGFuZ2VkIiwib25DZW50ZXJDaGFuZ2VkIiwib25DbGljayIsIm9uQ29udGV4dG1lbnUiLCJvbkRibGNsaWNrIiwib25EcmFnIiwib25EcmFnZW5kIiwib25EcmFnc3RhcnQiLCJvbkhlYWRpbmdDaGFuZ2VkIiwib25JZGxlIiwib25Jc0ZyYWN0aW9uYWxab29tRW5hYmxlZENoYW5nZWQiLCJvbk1hcENhcGFiaWxpdGllc0NoYW5nZWQiLCJvbk1hcFR5cGVJZENoYW5nZWQiLCJvbk1vdXNlbW92ZSIsIm9uTW91c2VvdXQiLCJvbk1vdXNlb3ZlciIsIm9uUHJvamVjdGlvbkNoYW5nZWQiLCJvblJlbmRlcmluZ1R5cGVDaGFuZ2VkIiwib25UaWxlc0xvYWRlZCIsIm9uVGlsdENoYW5nZWQiLCJvblpvb21DaGFuZ2VkIiwib25DYW1lcmFDaGFuZ2VkIiwia2V5cyIsInVzZVByZXZpb3VzIiwicmVmIiwiY3VycmVudCIsInVzZU1lbW9pemVkIiwiaXNFcXVhbCIsInByZXZpb3VzIiwidXNlQ3VzdG9tQ29tcGFyZUVmZmVjdCIsImVmZmVjdCIsImRlcGVuZGVuY2llcyIsInVzZURlZXBDb21wYXJlRWZmZWN0IiwibWFwT3B0aW9uS2V5cyIsIlNldCIsInVzZU1hcE9wdGlvbnMiLCJtYXBQcm9wcyIsIm1hcE9wdGlvbnMiLCJoYXMiLCJzZXRPcHRpb25zIiwidXNlQXBpTG9hZGluZ1N0YXR1cyIsInVzZURlY2tHTENhbWVyYVVwZGF0ZSIsInZpZXdwb3J0Iiwidmlld1N0YXRlIiwiaXNEZWNrR2xDb250cm9sbGVkIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJiZWFyaW5nIiwicGl0Y2giLCJtb3ZlQ2FtZXJhIiwiaXNMYXRMbmdMaXRlcmFsIiwib2JqIiwibGF0TG5nRXF1YWxzIiwiYSIsImIiLCJBIiwidG9MYXRMbmdMaXRlcmFsIiwiQiIsInVzZU1hcENhbWVyYVBhcmFtcyIsImNhbWVyYVN0YXRlUmVmIiwibmV4dENhbWVyYSIsIm5lZWRzVXBkYXRlIiwiQXV0aEZhaWx1cmVNZXNzYWdlIiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInpJbmRleCIsImRpc3BsYXkiLCJmbGV4RmxvdyIsInRleHRBbGlnbiIsImp1c3RpZnlDb250ZW50IiwiZm9udFNpemUiLCJjb2xvciIsImJhY2tncm91bmQiLCJwYWRkaW5nIiwidXNlQ2FsbGJhY2tSZWYiLCJlbCIsInNldEVsIiwidXNlQXBpSXNMb2FkZWQiLCJ1c2VGb3JjZVVwZGF0ZSIsImZvcmNlVXBkYXRlIiwieCIsImhhbmRsZUJvdW5kc0NoYW5nZSIsInVzZVRyYWNrZWRDYW1lcmFTdGF0ZVJlZiIsIkNhY2hlZE1hcFN0YWNrIiwicG9wIiwidXNlTWFwSW5zdGFuY2UiLCJjb250ZXh0IiwiYXBpSXNMb2FkZWQiLCJzZXRNYXAiLCJjb250YWluZXIiLCJjb250YWluZXJSZWYiLCJkZWZhdWx0Qm91bmRzIiwiZGVmYXVsdENlbnRlciIsImRlZmF1bHRab29tIiwiZGVmYXVsdEhlYWRpbmciLCJkZWZhdWx0VGlsdCIsInJldXNlTWFwcyIsInJlbmRlcmluZ1R5cGUiLCJjb2xvclNjaGVtZSIsImhhc1pvb20iLCJoYXNDZW50ZXIiLCJjdXN0b21JZHMiLCJzYXZlZE1hcFN0YXRlUmVmIiwibWFwSWQiLCJjYWNoZUtleSIsIm1hcERpdiIsImdldERpdiIsImFwcGVuZENoaWxkIiwic2V0VGltZW91dCIsInNldENlbnRlciIsImhlaWdodCIsIk1hcCIsImRlZkJvdW5kcyIsImZpdEJvdW5kcyIsInNhdmVkTWFwSWQiLCJjYW1lcmFTdGF0ZSIsInNhdmVkQ2FtZXJhU3RhdGUiLCJjbGVhckluc3RhbmNlTGlzdGVuZXJzIiwiR29vZ2xlTWFwc0NvbnRleHQiLCJDb2xvclNjaGVtZSIsIkRBUksiLCJMSUdIVCIsIkZPTExPV19TWVNURU0iLCJSZW5kZXJpbmdUeXBlIiwiVkVDVE9SIiwiUkFTVEVSIiwiVU5JTklUSUFMSVpFRCIsImNsYXNzTmFtZSIsIm1hcFJlZiIsImlzQ29udHJvbGxlZEV4dGVybmFsbHkiLCJjb250cm9sbGVkIiwiZGlzYWJsZURlZmF1bHRVSSIsImdlc3R1cmVIYW5kbGluZyIsImtleWJvYXJkU2hvcnRjdXRzIiwiY2FtZXJhT3B0aW9ucyIsIl9jIiwiY29tYmluZWRTdHlsZSIsIndpZHRoIiwiZGVja0dMVmlld1Byb3BzIiwic2hvd25NZXNzYWdlcyIsImxvZ0Vycm9yT25jZSIsImFyZ3MiLCJhZGQiLCJ1c2VNYXAiLCJjdHgiLCJ1c2VNYXBzTGlicmFyeSIsInVzZU1hcHNFdmVudExpc3RlbmVyIiwidGFyZ2V0IiwiY2FsbGJhY2siLCJ1c2VQcm9wQmluZGluZyIsIm9iamVjdCIsInByb3AiLCJ1c2VEb21FdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJHbG9iYWxTdHlsZU1hbmFnZXIiLCJnZXRTdHlsZUVsZW1lbnQiLCJzdHlsZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhZGRBZHZhbmNlZE1hcmtlclBvaW50ZXJFdmVudHNPdmVyd3JpdGUiLCJyZW5kZXJlZFN0eWxlcyIsInRleHRDb250ZW50IiwiY2xlYW51cCIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJnbG9iYWxTdHlsZU1hbmFnZXIiLCJpc1ZlcnNpb25HcmVhdGVyRXF1YWwiLCJtYWpvciIsIm1pbm9yIiwiY3VycmVudE1ham9yIiwicGFyc2VJbnQiLCJjdXJyZW50TWlub3IiLCJDb2xsaXNpb25CZWhhdmlvciIsIlJFUVVJUkVEIiwiUkVRVUlSRURfQU5EX0hJREVTX09QVElPTkFMIiwiT1BUSU9OQUxfQU5EX0hJREVTX0xPV0VSX1BSSU9SSVRZIiwiQWR2YW5jZWRNYXJrZXJDb250ZXh0IiwiQWR2YW5jZWRNYXJrZXJBbmNob3JQb2ludCIsIlRPUF9MRUZUIiwiVE9QX0NFTlRFUiIsIlRPUCIsIlRPUF9SSUdIVCIsIkxFRlRfQ0VOVEVSIiwiTEVGVF9UT1AiLCJMRUZUIiwiTEVGVF9CT1RUT00iLCJSSUdIVF9UT1AiLCJSSUdIVCIsIlJJR0hUX0NFTlRFUiIsIlJJR0hUX0JPVFRPTSIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NX0NFTlRFUiIsIkJPVFRPTSIsIkJPVFRPTV9SSUdIVCIsIkNFTlRFUiIsIkFkdmFuY2VkTWFya2VyIiwiYW5jaG9yUG9pbnQiLCJtYXJrZXIiLCJjb250ZW50Q29udGFpbmVyIiwidXNlQWR2YW5jZWRNYXJrZXIiLCJhZHZhbmNlZE1hcmtlckNvbnRleHRWYWx1ZSIsIk1hcmtlckNvbnRlbnQiLCJzdHlsZXMiLCJkaXNwbGF5TmFtZSIsInVzZUFkdmFuY2VkTWFya2VyUmVmIiwic2V0TWFya2VyIiwicmVmQ2FsbGJhY2siLCJtIiwiaXNBZHZhbmNlZE1hcmtlciIsImNvbnRlbnQiLCJpc0VsZW1lbnROb2RlIiwibm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsInNldENvbnRlbnRDb250YWluZXIiLCJtYXJrZXJMaWJyYXJ5Iiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25EcmFnU3RhcnQiLCJvbkRyYWdFbmQiLCJjb2xsaXNpb25CZWhhdmlvciIsImNsaWNrYWJsZSIsImRyYWdnYWJsZSIsInRpdGxlIiwiYW5jaG9yTGVmdCIsImFuY2hvclRvcCIsIm51bUNoaWxkcmVuIiwiY291bnQiLCJuZXdNYXJrZXIiLCJBZHZhbmNlZE1hcmtlckVsZW1lbnQiLCJjb250ZW50RWxlbWVudCIsInVzZUFkdmFuY2VkTWFya2VyQW5jaG9yaW5nIiwiZ21wRHJhZ2dhYmxlIiwiZ21wQ2xpY2thYmxlIiwiQm9vbGVhbiIsInBvaW50ZXJFdmVudHMiLCJjdXJzb3IiLCJlbGVtZW50IiwiaGFzQ2hpbGRyZW4iLCJhbmNob3JPcHRpb25zU3VwcG9ydGVkIiwieSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwidHJhbnNmb3JtIiwiZGF0YXNldCIsIm9yaWdpbiIsInNldFZhbHVlRm9yU3R5bGVzIiwicHJldlN0eWxlcyIsImVsZW1lbnRTdHlsZSIsInN0eWxlTmFtZSIsInNldFZhbHVlRm9yU3R5bGUiLCJpc0N1c3RvbVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJjc3NGbG9hdCIsImlzVW5pdGxlc3NOdW1iZXIiLCJ0cmltIiwidW5pdGxlc3NOdW1iZXJzIiwiSW5mb1dpbmRvdyIsImhlYWRlckNvbnRlbnQiLCJwaXhlbE9mZnNldCIsImFuY2hvciIsInNob3VsZEZvY3VzIiwib25DbG9zZSIsIm9uQ2xvc2VDbGljayIsInZvbGF0aWxlSW5mb1dpbmRvd09wdGlvbnMiLCJtYXBzTGlicmFyeSIsImluZm9XaW5kb3ciLCJzZXRJbmZvV2luZG93IiwiY29udGVudENvbnRhaW5lclJlZiIsImhlYWRlckNvbnRhaW5lclJlZiIsImluZm9XaW5kb3dPcHRpb25zIiwib3B0cyIsIlNpemUiLCJzZXRDb250ZW50IiwicHJldlN0eWxlUmVmIiwiaXNPcGVuZWRXaXRoQW5jaG9yIiwib3Blbk9wdGlvbnMiLCJFbGVtZW50IiwiYW5jaG9yQmNyIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYW5jaG9yRG9tQ29udGVudCIsImZpcnN0RWxlbWVudENoaWxkIiwiY29udGVudEJjciIsImFuY2hvck9mZnNldFgiLCJhbmNob3JPZmZzZXRZIiwib3BlbiIsImNsb3NlIiwiRnJhZ21lbnQiLCJmb3JtYXRMb2NhdGlvbiIsImxvY2F0aW9uIiwiZm9ybWF0UGFyYW0iLCJzdHJpbmciLCJzbGljZSIsImFzc2VtYmxlTWFya2VyUGFyYW1zIiwibWFya2VycyIsIm1hcmtlclBhcmFtcyIsIm1hcmtlcnNCeVN0eWxlIiwicmVkdWNlIiwibGFiZWwiLCJzaXplIiwic2NhbGUiLCJpY29uIiwicmVsZXZhbnRQcm9wcyIsImZpbHRlciIsInZhbHVlcyIsImZvckVhY2giLCJtYXJrZXJQYXJhbSIsInJlbGV2YW50S2V5cyIsIlBBVEhfU1RZTEVfS0VZUyIsImJ1aWxkU3R5bGVQYXJhbXMiLCJwYXRoIiwic3R5bGVQYXJhbXMiLCJidWlsZENvb3JkaW5hdGVQYXJhbXMiLCJjb29yZGluYXRlcyIsImRlY29kZVVSSUNvbXBvbmVudCIsImFzc2VtYmxlUGF0aFBhcmFtcyIsInBhdGhzIiwiY29vcmRpbmF0ZVBhcmFtcyIsInBhdGhQYXJhbSIsImFzc2VtYmxlTWFwVHlwZVN0eWxlcyIsIm1hcFR5cGVTdHlsZSIsImZlYXR1cmVUeXBlIiwiZWxlbWVudFR5cGUiLCJzdHlsZXJzIiwic3R5bGVTdHJpbmciLCJzdHlsZXIiLCJTVEFUSUNfTUFQU19CQVNFIiwiY3JlYXRlU3RhdGljTWFwc1VybCIsImZvcm1hdCIsIm1hcFR5cGUiLCJ2aXNpYmxlIiwibWFwdHlwZSIsIm1hcF9pZCIsInVybCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsIlN0YXRpY01hcCIsIkNvbnRyb2xQb3NpdGlvbiIsIkJMT0NLX1NUQVJUX0lOTElORV9TVEFSVCIsIkJMT0NLX1NUQVJUX0lOTElORV9DRU5URVIiLCJCTE9DS19TVEFSVF9JTkxJTkVfRU5EIiwiSU5MSU5FX1NUQVJUX0JMT0NLX0NFTlRFUiIsIklOTElORV9TVEFSVF9CTE9DS19TVEFSVCIsIklOTElORV9TVEFSVF9CTE9DS19FTkQiLCJJTkxJTkVfRU5EX0JMT0NLX1NUQVJUIiwiSU5MSU5FX0VORF9CTE9DS19DRU5URVIiLCJJTkxJTkVfRU5EX0JMT0NLX0VORCIsIkJMT0NLX0VORF9JTkxJTkVfU1RBUlQiLCJCTE9DS19FTkRfSU5MSU5FX0NFTlRFUiIsIkJMT0NLX0VORF9JTkxJTkVfRU5EIiwiTWFwQ29udHJvbCIsImNvbnRyb2xDb250YWluZXIiLCJjb250cm9scyIsImNvbnRyb2xzQXJyYXkiLCJnZXRBcnJheSIsImluZGV4IiwicmVtb3ZlQXQiLCJ1c2VNYXJrZXIiLCJvbk1vdXNlT3ZlciIsIm9uTW91c2VPdXQiLCJtYXJrZXJPcHRpb25zIiwiTWFya2VyIiwiZ21lIiwic2V0RHJhZ2dhYmxlIiwic2V0UG9zaXRpb24iLCJ1c2VNYXJrZXJSZWYiLCJQaW4iLCJhZHZhbmNlZE1hcmtlciIsImdseXBoQ29udGFpbmVyIiwiZ2x5cGgiLCJwaW5WaWV3T3B0aW9ucyIsInBpbkVsZW1lbnQiLCJQaW5FbGVtZW50IiwibWFya2VyQ29udGVudCIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsIm1hcExpbmVhciIsImExIiwiYTIiLCJiMSIsImIyIiwiZ2V0TWFwTWF4VGlsdCIsImxpbWl0VGlsdFJhbmdlIiwiZ21ab29tIiwibWF4VGlsdCIsImZvdnkiLCJNYXRoIiwibWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n"));

/***/ })

}]);